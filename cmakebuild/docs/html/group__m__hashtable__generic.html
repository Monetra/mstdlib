<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mstdlib-1.0.0: Hashtable generic/base implementation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mstdlib-1.0.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__m__hashtable__generic.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Hashtable generic/base implementation<div class="ingroups"><a class="el" href="group__mstdlib__base.html">Base</a> &raquo; <a class="el" href="group__m__datastructures.html">Data Structures/Algorithms</a> &raquo; <a class="el" href="group__m__hashtable.html">Hashtable</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structM__hashtable__enum"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#structM__hashtable__enum">M_hashtable_enum_t</a></td></tr>
<tr class="separator:structM__hashtable__enum"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:unionM__hashtable__enum_8entry"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#unionM__hashtable__enum_8entry">M_hashtable_enum.entry</a></td></tr>
<tr class="separator:unionM__hashtable__enum_8entry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structM__hashtable__enum_8entry_8unordered"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#structM__hashtable__enum_8entry_8unordered">M_hashtable_enum.entry.unordered</a></td></tr>
<tr class="separator:structM__hashtable__enum_8entry_8unordered"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structM__hashtable__enum_8entry_8ordered"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#structM__hashtable__enum_8entry_8ordered">M_hashtable_enum.entry.ordered</a></td></tr>
<tr class="separator:structM__hashtable__enum_8entry_8ordered"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structM__hashtable__callbacks"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#structM__hashtable__callbacks">M_hashtable_callbacks</a></td></tr>
<tr class="separator:structM__hashtable__callbacks"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga8880e7102d93baf643395d2234914682"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#ga8880e7102d93baf643395d2234914682">M_HASHTABLE_MAX_BUCKETS</a>&#160;&#160;&#160;(1U&lt;&lt;24)</td></tr>
<tr class="separator:ga8880e7102d93baf643395d2234914682"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga282cebedc4ffc574f68baa87fa956e99"><td class="memItemLeft" align="right" valign="top">typedef struct M_hashtable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a></td></tr>
<tr class="separator:ga282cebedc4ffc574f68baa87fa956e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6538fc32437c2ed90fe8d72e45930c4e"><td class="memItemLeft" align="right" valign="top">typedef M_uint32(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#ga6538fc32437c2ed90fe8d72e45930c4e">M_hashtable_hash_func</a>) (const void *, M_uint32)</td></tr>
<tr class="separator:ga6538fc32437c2ed90fe8d72e45930c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f184444b40a0b597298d94ce3a1cd88"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#ga1f184444b40a0b597298d94ce3a1cd88">M_hashtable_duplicate_func</a>) (const void *)</td></tr>
<tr class="separator:ga1f184444b40a0b597298d94ce3a1cd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31e66cdbed93208b7874be0955c8eba8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#ga31e66cdbed93208b7874be0955c8eba8">M_hashtable_free_func</a>) (void *)</td></tr>
<tr class="separator:ga31e66cdbed93208b7874be0955c8eba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gad13365674e45cd99be915fbc66b31ce8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#gad13365674e45cd99be915fbc66b31ce8">M_hashtable_flags_t</a> { <br />
&#160;&#160;<a class="el" href="group__m__hashtable__generic.html#ggad13365674e45cd99be915fbc66b31ce8a9e50f4e9e987676773501bc328670de4">M_HASHTABLE_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__m__hashtable__generic.html#ggad13365674e45cd99be915fbc66b31ce8ad2001c81452a606a343fdd4bb0056db0">M_HASHTABLE_KEYS_ORDERED</a> = 1 &lt;&lt; 0, 
<br />
&#160;&#160;<a class="el" href="group__m__hashtable__generic.html#ggad13365674e45cd99be915fbc66b31ce8a5a71b54a692d1f7a4260538a49c71aec">M_HASHTABLE_KEYS_SORTED</a> = 1 &lt;&lt; 1, 
<br />
&#160;&#160;<a class="el" href="group__m__hashtable__generic.html#ggad13365674e45cd99be915fbc66b31ce8a837e00e0a455c823bf55a8f4f2d2b32b">M_HASHTABLE_MULTI_VALUE</a> = 1 &lt;&lt; 2, 
<br />
&#160;&#160;<a class="el" href="group__m__hashtable__generic.html#ggad13365674e45cd99be915fbc66b31ce8aaecbe61ac29093c9d37b846e4cd0fbaf">M_HASHTABLE_MULTI_SORTED</a> = 1 &lt;&lt; 3, 
<br />
&#160;&#160;<a class="el" href="group__m__hashtable__generic.html#ggad13365674e45cd99be915fbc66b31ce8aac246c5f930524e2246ed3aae46af09b">M_HASHTABLE_MULTI_GETLAST</a> = 1 &lt;&lt; 4
<br />
 }</td></tr>
<tr class="separator:gad13365674e45cd99be915fbc66b31ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2a3fff2032f4d5349ed5e1f91adb30fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#ga2a3fff2032f4d5349ed5e1f91adb30fa">M_hashtable_create</a> (size_t size, M_uint8 fillpct, <a class="el" href="group__m__hashtable__generic.html#ga6538fc32437c2ed90fe8d72e45930c4e">M_hashtable_hash_func</a> key_hash, <a class="el" href="group__m__sort.html#gac72502df2ae525e19025d37cf3c77c17">M_sort_compar_t</a> key_equality, M_uint32 flags, const struct <a class="el" href="group__m__hashtable__generic.html#structM__hashtable__callbacks">M_hashtable_callbacks</a> *callbacks) M_MALLOC</td></tr>
<tr class="separator:ga2a3fff2032f4d5349ed5e1f91adb30fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee21e727a948e6e24ff5098d14ae4628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#gaee21e727a948e6e24ff5098d14ae4628">M_hashtable_destroy</a> (<a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *h, M_bool destroy_vals) M_FREE(1)</td></tr>
<tr class="separator:gaee21e727a948e6e24ff5098d14ae4628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a3c6ea1647539743d74f21ea5353046"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#ga8a3c6ea1647539743d74f21ea5353046">M_hashtable_insert</a> (<a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *h, const void *key, const void *value)</td></tr>
<tr class="separator:ga8a3c6ea1647539743d74f21ea5353046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cc0f451df5106d38c3543c9d7e62f23"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#ga4cc0f451df5106d38c3543c9d7e62f23">M_hashtable_remove</a> (<a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *h, const void *key, M_bool destroy_vals)</td></tr>
<tr class="separator:ga4cc0f451df5106d38c3543c9d7e62f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf110f08ad20a61cea0834dd85c99e744"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#gaf110f08ad20a61cea0834dd85c99e744">M_hashtable_get</a> (const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *h, const void *key, void **value)</td></tr>
<tr class="separator:gaf110f08ad20a61cea0834dd85c99e744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b51626c6849e1f2f698683607bc839b"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#ga3b51626c6849e1f2f698683607bc839b">M_hashtable_multi_len</a> (const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *h, const void *key, size_t *len)</td></tr>
<tr class="separator:ga3b51626c6849e1f2f698683607bc839b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d3c54178f0fb5fb2e7fba0df5103a14"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#ga2d3c54178f0fb5fb2e7fba0df5103a14">M_hashtable_multi_get</a> (const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *h, const void *key, size_t idx, void **value)</td></tr>
<tr class="separator:ga2d3c54178f0fb5fb2e7fba0df5103a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae8f9c55497ca4335f09444aea1774c"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#ga4ae8f9c55497ca4335f09444aea1774c">M_hashtable_multi_remove</a> (<a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *h, const void *key, size_t idx, M_bool destroy_vals)</td></tr>
<tr class="separator:ga4ae8f9c55497ca4335f09444aea1774c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d3c82a12d9f224dd639a069e855b8b7"><td class="memItemLeft" align="right" valign="top">M_uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#ga6d3c82a12d9f224dd639a069e855b8b7">M_hashtable_size</a> (const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *h)</td></tr>
<tr class="separator:ga6d3c82a12d9f224dd639a069e855b8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b97ca6e0d523397b3c09d9e7434ed7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#ga25b97ca6e0d523397b3c09d9e7434ed7">M_hashtable_num_collisions</a> (const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *h)</td></tr>
<tr class="separator:ga25b97ca6e0d523397b3c09d9e7434ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6adb4b9ed40e572254b884f345937d48"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#ga6adb4b9ed40e572254b884f345937d48">M_hashtable_num_expansions</a> (const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *h)</td></tr>
<tr class="separator:ga6adb4b9ed40e572254b884f345937d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38b0a15c35fa97e003c7d3f5a84741a1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#ga38b0a15c35fa97e003c7d3f5a84741a1">M_hashtable_num_keys</a> (const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *h)</td></tr>
<tr class="separator:ga38b0a15c35fa97e003c7d3f5a84741a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf989bde17812db14003d0052e5661301"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#gaf989bde17812db14003d0052e5661301">M_hashtable_enumerate</a> (const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *h, M_hashtable_enum_t *hashenum)</td></tr>
<tr class="separator:gaf989bde17812db14003d0052e5661301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44f4ff607fd064cc3a69fd2f507358ef"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#ga44f4ff607fd064cc3a69fd2f507358ef">M_hashtable_enumerate_next</a> (const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *h, M_hashtable_enum_t *hashenum, const void **key, const void **value)</td></tr>
<tr class="separator:ga44f4ff607fd064cc3a69fd2f507358ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5db2e2a410acee6f6dc070d884f1fcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#gad5db2e2a410acee6f6dc070d884f1fcf">M_hashtable_merge</a> (<a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> **dest, <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *src)</td></tr>
<tr class="separator:gad5db2e2a410acee6f6dc070d884f1fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2556b10545ee42e6a8dafb5f4635120"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__hashtable__generic.html#gae2556b10545ee42e6a8dafb5f4635120">M_hashtable_duplicate</a> (const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *h)</td></tr>
<tr class="separator:gae2556b10545ee42e6a8dafb5f4635120"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Hashtable, meant for storing key/value pairs.</p>
<p>This should not be used directly. It is a base implementation that should be used by a type safe wrapper. For example: M_hash_dict.</p>
<p>The h can uses a set of callback functions to determine behavior. Such as if it should duplicate or free values.</p>
<p>An optional hash algorithm can be specified when creating a type safe wrapper. It is highly recommended to provide a hash algorithm. The default algorithm is an FNV1a variant using the pointer of the key.</p>
<p>The currently provided wrappers (str and u64) use an FNV1a variant. Multiple hashing algorithms were considered but FNV1a was ultimately chosen because testing with real world data sets it was found to provide the best performance.</p>
<p>The following hash functions were evaluated:</p><ul>
<li>FNV1</li>
<li>FNV1a</li>
<li>Lookup2</li>
<li>Qt4's hash function</li>
<li>djb2</li>
</ul>
<p>Overall performance was tested. We looked at time to generate the hash, time for insert, and lookup time. The insert and lookup are specific to see how chaining due to increased collisions impacted overall performance.</p>
<p>FNV1a had average collision performance and average hash time. Some hash functions had fewer collisions but the time it took to generate the hash far exceeded the chaining time. Others had very fast generation time but had so many collisions that the chaining time exceeded the benefit of being quick.</p>
<p>FNV1a was found to have few enough collisions to keep any chains sort and the combined hash generation and chaining time (when chaining happened) was overall faster than the other hash's times.</p>
<p>In order to prevent denial of service attacks by an attacker causing generation of extremely large chains FNV1a was modified. A random hash seed that is unique per hashtable object (each hashtable created using _create(...)) is used as the offset bias for the algorithm.</p>
<p>According to draft-eastlake-fnv-09 at <a href="https://tools.ietf.org/html/draft-eastlake-fnv-09#section-2.2">https://tools.ietf.org/html/draft-eastlake-fnv-09#section-2.2</a> . "In the general case, almost any offset_basis will serve so long as it is non-zero." This information can also be found on Noll's website <a href="http://isthe.com/chongo/tech/comp/fnv/index.html">http://isthe.com/chongo/tech/comp/fnv/index.html</a> in the section, "Parameters of the FNV-1/FNV-1a hash".</p>
<p>In our variation care has been taken to ensure the bias is never 0.</p>
<p>The random seed is created using M_rand. While M_rand is not a secure random number generator the random seed for M_rand is created from unlikely to be known data such as stack and heap memory addresses at the time the hashtable is created. It is unlikely an attacker would be able to determine the random seed to be able to get the hash seed. Nor is it likely for an attacker to be able to determine the hash seed. Testing using a random hash seed was found to alleviate chaining attacks. </p>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structM__hashtable__enum" id="structM__hashtable__enum"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structM__hashtable__enum">&#9670;&nbsp;</a></span>M_hashtable_enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct M_hashtable_enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>State tracking object for enumerating a Hashtable. This is explicitly not hidden so it doesn't require a malloc() </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ab6de81a4c1c90919e449712eca9090f8"></a>union <a class="el" href="group__m__hashtable__generic.html#unionM__hashtable__enum_8entry">M_hashtable_enum</a></td>
<td class="fieldname">
entry</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a2d0b93dcab3ab31afe2372bfac1363e7"></a>size_t</td>
<td class="fieldname">
valueidx</td>
<td class="fielddoc">
<p>When multi-value is in use which index of next value. </p>
</td></tr>
</table>

</div>
</div>
<a name="unionM__hashtable__enum_8entry" id="unionM__hashtable__enum_8entry"></a>
<h2 class="memtitle"><span class="permalink"><a href="#unionM__hashtable__enum_8entry">&#9670;&nbsp;</a></span>M_hashtable_enum.entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union M_hashtable_enum.entry</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a2e3a2fe1ab6a59f682eec190c2b1fe27"></a><a class="el" href="group__m__hashtable__generic.html#structM__hashtable__enum_8entry_8unordered">entry</a></td>
<td class="fieldname">
unordered</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ac934e7c6da08a36804ba7339c23644b5"></a><a class="el" href="group__m__hashtable__generic.html#structM__hashtable__enum_8entry_8ordered">entry</a></td>
<td class="fieldname">
ordered</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structM__hashtable__enum_8entry_8unordered" id="structM__hashtable__enum_8entry_8unordered"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structM__hashtable__enum_8entry_8unordered">&#9670;&nbsp;</a></span>M_hashtable_enum.entry.unordered</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct M_hashtable_enum.entry.unordered</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a0800fc577294c34e0b28ad2839435945"></a>M_uint32</td>
<td class="fieldname">
hash</td>
<td class="fielddoc">
<p>Hash of last processed entry </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a373dcde4871c8c17a6543cd0259ae25d"></a>size_t</td>
<td class="fieldname">
chainid</td>
<td class="fielddoc">
<p>1-based offset within linked list of clashes of last processed entry. This value is 1-based specifically so when starting an enumeration, a 0,0 value would indicate this </p>
</td></tr>
</table>

</div>
</div>
<a name="structM__hashtable__enum_8entry_8ordered" id="structM__hashtable__enum_8entry_8ordered"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structM__hashtable__enum_8entry_8ordered">&#9670;&nbsp;</a></span>M_hashtable_enum.entry.ordered</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct M_hashtable_enum.entry.ordered</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ab3bb3cc61a2416fc0d78cefdff382fae"></a><a class="el" href="group__m__llist__generic.html#ga9c73f7cf0b24ee76a4fff3770558523d">M_llist_node_t</a> *</td>
<td class="fieldname">
keynode</td>
<td class="fielddoc">
<p>When ordered keys are in use this is the node of the key currently being processed. </p>
</td></tr>
</table>

</div>
</div>
<a name="structM__hashtable__callbacks" id="structM__hashtable__callbacks"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structM__hashtable__callbacks">&#9670;&nbsp;</a></span>M_hashtable_callbacks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct M_hashtable_callbacks</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Structure of callbacks that can be registered to override default behavior for h implementation.</p>
<p>This allows a great deal of flexibility. For instance, you may want the HashTable to take ownership of the 'value' passed to it and clean up when the entry is replaced, removed, or the h is destroyed. In this implementation, you could use NULL for 'value_duplicate' so the pointer passed in is used directly, but register an appropriate 'value_free' to auto-cleanup.</p>
<p>Note that there are two duplicate callbacks for keys and values. There are two times a key or value can be duplicated. When it is first inserted into the h and when the h itself is duplicated.</p>
<p>In some cases the key or value needs to be duplicated by the h wrapper instead of by the base itself. For example storing unbounded binary data as a value. To prevent extra allocations and additional wrapping the value is duplicated by the wrapper and the length is prepended. This duplicate needs the length in order to work where the other duplicate (copy of h) will get the length from the fist few bytes of the value itself. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ab129c04d57512b46fca8ea3694fbfe8e"></a><a class="el" href="group__m__hashtable__generic.html#ga1f184444b40a0b597298d94ce3a1cd88">M_hashtable_duplicate_func</a></td>
<td class="fieldname">
key_duplicate_insert</td>
<td class="fielddoc">
<p>Callback to duplicate a key on insert. Default if NULL is pass-thru pointer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a7d2337fe7c7d3e6633d8ea363ed75946"></a><a class="el" href="group__m__hashtable__generic.html#ga1f184444b40a0b597298d94ce3a1cd88">M_hashtable_duplicate_func</a></td>
<td class="fieldname">
key_duplicate_copy</td>
<td class="fielddoc">
<p>Callback to duplicate a key on copy. Default if NULL is pass-thru pointer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad413bbd43e6dc5671f087565acf1addc"></a><a class="el" href="group__m__hashtable__generic.html#ga31e66cdbed93208b7874be0955c8eba8">M_hashtable_free_func</a></td>
<td class="fieldname">
key_free</td>
<td class="fielddoc">
<p>Callback to free a key. Default if NULL is no-op </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ac3023b748b3c5369646d74b2e575e5d6"></a><a class="el" href="group__m__hashtable__generic.html#ga1f184444b40a0b597298d94ce3a1cd88">M_hashtable_duplicate_func</a></td>
<td class="fieldname">
value_duplicate_insert</td>
<td class="fielddoc">
<p>Callback to duplicate a value on insert. Default if NULL is pass-thru pointer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a96f58448b7308dc21ef8559e62cb9d5d"></a><a class="el" href="group__m__hashtable__generic.html#ga1f184444b40a0b597298d94ce3a1cd88">M_hashtable_duplicate_func</a></td>
<td class="fieldname">
value_duplicate_copy</td>
<td class="fielddoc">
<p>Callback to duplicate a value on copy. Default if NULL is pass-thru pointer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ad0f01055ddbf1ca024f71159784c24cd"></a><a class="el" href="group__m__sort.html#gac72502df2ae525e19025d37cf3c77c17">M_sort_compar_t</a></td>
<td class="fieldname">
value_equality</td>
<td class="fielddoc">
<p>Callback used to determine if two values are equal. Primarily used for sorting muli-values stores. Default is all values are equal. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="acbb748c1a34727d46012791afb5debbc"></a><a class="el" href="group__m__hashtable__generic.html#ga31e66cdbed93208b7874be0955c8eba8">M_hashtable_free_func</a></td>
<td class="fieldname">
value_free</td>
<td class="fielddoc">
<p>Callback to free a value. Default if NULL is a no-op </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga8880e7102d93baf643395d2234914682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8880e7102d93baf643395d2234914682">&#9670;&nbsp;</a></span>M_HASHTABLE_MAX_BUCKETS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M_HASHTABLE_MAX_BUCKETS&#160;&#160;&#160;(1U&lt;&lt;24)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga282cebedc4ffc574f68baa87fa956e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga282cebedc4ffc574f68baa87fa956e99">&#9670;&nbsp;</a></span>M_hashtable_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct M_hashtable <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6538fc32437c2ed90fe8d72e45930c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6538fc32437c2ed90fe8d72e45930c4e">&#9670;&nbsp;</a></span>M_hashtable_hash_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_uint32(* M_hashtable_hash_func) (const void *, M_uint32)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function definition for callback to hash a key </p>

</div>
</div>
<a id="ga1f184444b40a0b597298d94ce3a1cd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f184444b40a0b597298d94ce3a1cd88">&#9670;&nbsp;</a></span>M_hashtable_duplicate_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* M_hashtable_duplicate_func) (const void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function definition to duplicate a key or value </p>

</div>
</div>
<a id="ga31e66cdbed93208b7874be0955c8eba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31e66cdbed93208b7874be0955c8eba8">&#9670;&nbsp;</a></span>M_hashtable_free_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* M_hashtable_free_func) (void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function definition to free a key or value </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gad13365674e45cd99be915fbc66b31ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad13365674e45cd99be915fbc66b31ce8">&#9670;&nbsp;</a></span>M_hashtable_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__m__hashtable__generic.html#gad13365674e45cd99be915fbc66b31ce8">M_hashtable_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags for controlling the behavior of the hash </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad13365674e45cd99be915fbc66b31ce8a9e50f4e9e987676773501bc328670de4"></a>M_HASHTABLE_NONE&#160;</td><td class="fielddoc"><p>Case sensitive single value (new values replace). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad13365674e45cd99be915fbc66b31ce8ad2001c81452a606a343fdd4bb0056db0"></a>M_HASHTABLE_KEYS_ORDERED&#160;</td><td class="fielddoc"><p>Keys should be ordered. Default is insertion order unless the sorted option is specified. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad13365674e45cd99be915fbc66b31ce8a5a71b54a692d1f7a4260538a49c71aec"></a>M_HASHTABLE_KEYS_SORTED&#160;</td><td class="fielddoc"><p>When the keys are ordered sort them using the key_equality function. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad13365674e45cd99be915fbc66b31ce8a837e00e0a455c823bf55a8f4f2d2b32b"></a>M_HASHTABLE_MULTI_VALUE&#160;</td><td class="fielddoc"><p>Allow keys to contain multiple values. Sorted in insertion order another sorting is specified. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad13365674e45cd99be915fbc66b31ce8aaecbe61ac29093c9d37b846e4cd0fbaf"></a>M_HASHTABLE_MULTI_SORTED&#160;</td><td class="fielddoc"><p>Allow keys to contain multiple values sorted in ascending order </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad13365674e45cd99be915fbc66b31ce8aac246c5f930524e2246ed3aae46af09b"></a>M_HASHTABLE_MULTI_GETLAST&#160;</td><td class="fielddoc"><p>When using the get function will get the last value from the list when allowing multiple values. The default is to get the first value. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2a3fff2032f4d5349ed5e1f91adb30fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a3fff2032f4d5349ed5e1f91adb30fa">&#9670;&nbsp;</a></span>M_hashtable_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a>* M_hashtable_create </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint8&#160;</td>
          <td class="paramname"><em>fillpct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__hashtable__generic.html#ga6538fc32437c2ed90fe8d72e45930c4e">M_hashtable_hash_func</a>&#160;</td>
          <td class="paramname"><em>key_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__sort.html#gac72502df2ae525e19025d37cf3c77c17">M_sort_compar_t</a>&#160;</td>
          <td class="paramname"><em>key_equality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint32&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="group__m__hashtable__generic.html#structM__hashtable__callbacks">M_hashtable_callbacks</a> *&#160;</td>
          <td class="paramname"><em>callbacks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new h.</p>
<p>The h will pre-allocate an array of buckets based on the rounded up size specified. Any hash collisions will result in those collisions being chained together via a linked list. The h will auto-expand by a power of 2 when the fill percentage specified is reached. All key entries are compared in a case-insensitive fashion, and are duplicated internally. Values are duplicated. Case is preserved for both keys and values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the hash table. If not specified as a power of 2, will be rounded up to the nearest power of 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fillpct</td><td>The maximum fill percentage before the hash table is expanded. If 0 is specified, the h will never expand, otherwise the value must be between 1 and 99 (recommended: 75). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_hash</td><td>The function to use for hashing a key. If not specified will use the pointer address as the key and use FNV1a. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_equality</td><td>The function to use to determine if two keys are equal. If not specified, will compare pointer addresses. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>M_hash_strvp_flags_t flags for modifying behavior. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callbacks</td><td>Register callbacks for overriding default behavior.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Allocated h.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__hashtable__generic.html#gaee21e727a948e6e24ff5098d14ae4628">M_hashtable_destroy</a> </dd></dl>

</div>
</div>
<a id="gaee21e727a948e6e24ff5098d14ae4628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee21e727a948e6e24ff5098d14ae4628">&#9670;&nbsp;</a></span>M_hashtable_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_hashtable_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>destroy_vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy the h.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hashtable to destroy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destroy_vals</td><td>M_TRUE if the values held by the h should be destroyed. This will almost always be M_TRUE. This should only be set to M_FALSE when all values held by the h are being managed externally. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a3c6ea1647539743d74f21ea5353046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a3c6ea1647539743d74f21ea5353046">&#9670;&nbsp;</a></span>M_hashtable_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_hashtable_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert an entry into the h.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hashtable being referenced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to insert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to insert into h. Value will not be duplicated. The h will take ownership of the value. Maybe NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, or M_FALSE on failure. </dd></dl>

</div>
</div>
<a id="ga4cc0f451df5106d38c3543c9d7e62f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cc0f451df5106d38c3543c9d7e62f23">&#9670;&nbsp;</a></span>M_hashtable_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_hashtable_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>destroy_vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an entry from the h.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hashtable being referenced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to remove from the h. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destroy_vals</td><td>M_TRUE if the value held by the h should be destroyed. This will almost always be M_TRUE. This should only be set to M_FALSE when the value held by the h is being managed externally.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, or M_FALSE if key does not exist. </dd></dl>

</div>
</div>
<a id="gaf110f08ad20a61cea0834dd85c99e744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf110f08ad20a61cea0834dd85c99e744">&#9670;&nbsp;</a></span>M_hashtable_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_hashtable_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the value for a key from the h.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hashtable being referenced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key for value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Pointer to value stored in the h. Optional, pass NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if value retrieved, M_FALSE if key does not exist. </dd></dl>

</div>
</div>
<a id="ga3b51626c6849e1f2f698683607bc839b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b51626c6849e1f2f698683607bc839b">&#9670;&nbsp;</a></span>M_hashtable_multi_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_hashtable_multi_len </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of values for a given key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hashtable being referenced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key for value to retrieve. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">len</td><td>The number of values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if length is retrieved, M_FALSE if key does not exist. </dd></dl>

</div>
</div>
<a id="ga2d3c54178f0fb5fb2e7fba0df5103a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d3c54178f0fb5fb2e7fba0df5103a14">&#9670;&nbsp;</a></span>M_hashtable_multi_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_hashtable_multi_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the value for a key from the given index when supporting muli-values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hashtable being referenced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key for value to retrieve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The index the value resides at. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Pointer to value stored. Optional, pass NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if value retrieved, M_FALSE if key does not exist </dd></dl>

</div>
</div>
<a id="ga4ae8f9c55497ca4335f09444aea1774c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ae8f9c55497ca4335f09444aea1774c">&#9670;&nbsp;</a></span>M_hashtable_multi_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_hashtable_multi_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>destroy_vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a value from the h when supporting muli-values.</p>
<p>If all values have been removed then the key will be removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hashtable being referenced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key for value to retrieve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The index the value resides at. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destroy_vals</td><td>M_TRUE if the value held by the h should be destroyed. This will almost always be M_TRUE. This should only be set to M_FALSE when the value held by the h is being managed externally.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the value was removed, M_FALSE if key does not exist. </dd></dl>

</div>
</div>
<a id="ga6d3c82a12d9f224dd639a069e855b8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d3c82a12d9f224dd639a069e855b8b7">&#9670;&nbsp;</a></span>M_hashtable_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_uint32 M_hashtable_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the current size (number of buckets/slots, not necessarily used).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hashtable being referenced.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the h </dd></dl>

</div>
</div>
<a id="ga25b97ca6e0d523397b3c09d9e7434ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25b97ca6e0d523397b3c09d9e7434ed7">&#9670;&nbsp;</a></span>M_hashtable_num_collisions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_hashtable_num_collisions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the number of collisions for h entries that has occurred since creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hashtable being referenced.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of collisions. </dd></dl>

</div>
</div>
<a id="ga6adb4b9ed40e572254b884f345937d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6adb4b9ed40e572254b884f345937d48">&#9670;&nbsp;</a></span>M_hashtable_num_expansions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_hashtable_num_expansions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the number of expansions/rehashes since creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hashtable being referenced.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of expansions/rehashes. </dd></dl>

</div>
</div>
<a id="ga38b0a15c35fa97e003c7d3f5a84741a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38b0a15c35fa97e003c7d3f5a84741a1">&#9670;&nbsp;</a></span>M_hashtable_num_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_hashtable_num_keys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the number of entries in the h.</p>
<p>This is the number of keys stored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hashtable being referenced.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of entries in the h. </dd></dl>

</div>
</div>
<a id="gaf989bde17812db14003d0052e5661301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf989bde17812db14003d0052e5661301">&#9670;&nbsp;</a></span>M_hashtable_enumerate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_hashtable_enumerate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_hashtable_enum_t *&#160;</td>
          <td class="paramname"><em>hashenum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an enumeration of the keys within a h.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hashtable being referenced. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hashenum</td><td>Outputs an initialized state variable for starting an enumeration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of items in the h </dd></dl>

</div>
</div>
<a id="ga44f4ff607fd064cc3a69fd2f507358ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44f4ff607fd064cc3a69fd2f507358ef">&#9670;&nbsp;</a></span>M_hashtable_enumerate_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_hashtable_enumerate_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_hashtable_enum_t *&#160;</td>
          <td class="paramname"><em>hashenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the next item from a h enumeration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hashtable being referenced. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hashenum</td><td>State variable for tracking the enumeration process. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>Value of next enumerated key. Optional, pass NULL if not needed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Value of next enumerated value. Optional, pass NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if enumeration succeeded, M_FALSE if no more keys. </dd></dl>

</div>
</div>
<a id="gad5db2e2a410acee6f6dc070d884f1fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5db2e2a410acee6f6dc070d884f1fcf">&#9670;&nbsp;</a></span>M_hashtable_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_hashtable_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> **&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge two hashtables together.</p>
<p>The second (src) h will be destroyed automatically upon completion of this function. Any key/value pointers for the h will be directly copied over to the destination h, they will not be duplicated. Any keys which exist in 'dest' that also exist in 'src' will be overwritten by the 'src' value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>Pointer by reference to the h receiving the key/value pairs. if dest is NULL, the src address will simply be copied to dest. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">src</td><td>Pointer to the h giving up its key/value pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae2556b10545ee42e6a8dafb5f4635120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2556b10545ee42e6a8dafb5f4635120">&#9670;&nbsp;</a></span>M_hashtable_duplicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a>* M_hashtable_duplicate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__m__hashtable__generic.html#ga282cebedc4ffc574f68baa87fa956e99">M_hashtable_t</a> *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duplicate an existing h.</p>
<p>Copying all keys and values. As well as other elements such as callbacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>Hashtable to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Duplicated h. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Feb 20 2018 12:46:11 for Mstdlib-1.0.0 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
