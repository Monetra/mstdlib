<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mstdlib-1.0.0: Data Parser</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mstdlib-1.0.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__m__parser.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Data Parser<div class="ingroups"><a class="el" href="group__mstdlib__base.html">Base</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga60164be64f8c962c795e5927642fc473"><td class="memItemLeft" align="right" valign="top">typedef struct M_parser&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a></td></tr>
<tr class="separator:ga60164be64f8c962c795e5927642fc473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf02bf52755e0b9fc5d18dccd81ba55d0"><td class="memItemLeft" align="right" valign="top">typedef M_bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a>) (unsigned char c)</td></tr>
<tr class="separator:gaf02bf52755e0b9fc5d18dccd81ba55d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5f283601804b657a199f6574996ccf87"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga5f283601804b657a199f6574996ccf87">M_PARSER_FLAGS</a> { <br />
&#160;&#160;<a class="el" href="group__m__parser.html#gga5f283601804b657a199f6574996ccf87a5879ad8c9fea3f4031268d7917b03933">M_PARSER_FLAG_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__m__parser.html#gga5f283601804b657a199f6574996ccf87a4dd69b089e5b923f02bf2c38afd32c11">M_PARSER_FLAG_TRACKLINES</a> = 1 &lt;&lt; 0
<br />
 }</td></tr>
<tr class="separator:ga5f283601804b657a199f6574996ccf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31929e2f622a249ba03d8ff374469951"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga31929e2f622a249ba03d8ff374469951">M_PARSER_WHITESPACE_FLAGS</a> { <br />
&#160;&#160;<a class="el" href="group__m__parser.html#gga31929e2f622a249ba03d8ff374469951ad8df579debcff24e7681b598c4ad441f">M_PARSER_WHITESPACE_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__m__parser.html#gga31929e2f622a249ba03d8ff374469951a1971c85ac90d36664ce49fb7eebb500e">M_PARSER_WHITESPACE_TO_NEWLINE</a> = 1 &lt;&lt; 0, 
<br />
&#160;&#160;<a class="el" href="group__m__parser.html#gga31929e2f622a249ba03d8ff374469951a30bfcb0864636783c43a3c35015cf19e">M_PARSER_WHITESPACE_SPACEONLY</a> = 1 &lt;&lt; 1
<br />
 }</td></tr>
<tr class="separator:ga31929e2f622a249ba03d8ff374469951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9512fcb78f39b6ca6a382641820bea9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaf9512fcb78f39b6ca6a382641820bea9">M_PARSER_INTEGER_TYPE</a> { <br />
&#160;&#160;<a class="el" href="group__m__parser.html#ggaf9512fcb78f39b6ca6a382641820bea9abe2371658d8efffa9c57046c0c081996">M_PARSER_INTEGER_ASCII</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__m__parser.html#ggaf9512fcb78f39b6ca6a382641820bea9a5230fd44caeffcbbf0f7042a825ed7eb">M_PARSER_INTEGER_BIGENDIAN</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group__m__parser.html#ggaf9512fcb78f39b6ca6a382641820bea9aa5fad8025be1078f9100d56f2b7a1516">M_PARSER_INTEGER_LITTLEENDIAN</a> = 2
<br />
 }</td></tr>
<tr class="separator:gaf9512fcb78f39b6ca6a382641820bea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa8162f3759d9033f13b4c209b63e46e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gafa8162f3759d9033f13b4c209b63e46e">M_PARSER_SPLIT_FLAGS</a> { <br />
&#160;&#160;<a class="el" href="group__m__parser.html#ggafa8162f3759d9033f13b4c209b63e46ea354d7c9d887a4da603f926c1d8a326c5">M_PARSER_SPLIT_FLAG_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__m__parser.html#ggafa8162f3759d9033f13b4c209b63e46ea1d8b9ec4214637219b0299c4050d181c">M_PARSER_SPLIT_FLAG_NODELIM_ERROR</a> = 1 &lt;&lt; 0
<br />
 }</td></tr>
<tr class="separator:gafa8162f3759d9033f13b4c209b63e46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fbdc774c77f61b74f797598209b682c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga3fbdc774c77f61b74f797598209b682c">M_PARSER_FRAME_BYES</a> { <br />
&#160;&#160;<a class="el" href="group__m__parser.html#gga3fbdc774c77f61b74f797598209b682cabeaf1fa32982e348935e8db5f0f930f3">M_PARSER_FRAME_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__m__parser.html#gga3fbdc774c77f61b74f797598209b682caddc7c80678b6ff04ab9947b5182b1ca9">M_PARSER_FRAME_STX</a> = 1 &lt;&lt; 0, 
<br />
&#160;&#160;<a class="el" href="group__m__parser.html#gga3fbdc774c77f61b74f797598209b682caf93ba74fbec931a58ad1f78964572720">M_PARSER_FRAME_ETX</a> = 1 &lt;&lt; 1
<br />
 }</td></tr>
<tr class="separator:ga3fbdc774c77f61b74f797598209b682c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6993008e1f0881f84431d5813f33d127"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga6993008e1f0881f84431d5813f33d127">M_PARSER_FRAME_ERROR</a> { <br />
&#160;&#160;<a class="el" href="group__m__parser.html#gga6993008e1f0881f84431d5813f33d127a1163baeeb38554303ed45fed0edb15fc">M_PARSER_FRAME_ERROR_SUCCESS</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__m__parser.html#gga6993008e1f0881f84431d5813f33d127a2fad5328c562dcc45572828ef656cfd9">M_PARSER_FRAME_ERROR_INVALID</a>, 
<br />
&#160;&#160;<a class="el" href="group__m__parser.html#gga6993008e1f0881f84431d5813f33d127a4544399f853ded518a022b3f36a123c6">M_PARSER_FRAME_ERROR_NO_STX</a>, 
<br />
&#160;&#160;<a class="el" href="group__m__parser.html#gga6993008e1f0881f84431d5813f33d127af99ee53c87f81cfd85a496a4b6b26e0a">M_PARSER_FRAME_ERROR_NO_ETX</a>, 
<br />
&#160;&#160;<a class="el" href="group__m__parser.html#gga6993008e1f0881f84431d5813f33d127a2d34642d05ef0dd48f6024645b4aa573">M_PARSER_FRAME_ERROR_NO_LRC</a>, 
<br />
&#160;&#160;<a class="el" href="group__m__parser.html#gga6993008e1f0881f84431d5813f33d127a701af53f85eb9dfd398ba8200b4d4059">M_PARSER_FRAME_ERROR_LRC_CALC_FAILED</a>
<br />
 }</td></tr>
<tr class="separator:ga6993008e1f0881f84431d5813f33d127"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac2ea9787b8a0d3876e3f39256a40b41e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gac2ea9787b8a0d3876e3f39256a40b41e">M_parser_create_const</a> (const unsigned char *buf, size_t len, M_uint32 flags)</td></tr>
<tr class="separator:gac2ea9787b8a0d3876e3f39256a40b41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8100f8e139f41315478133992cc8ad1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaf8100f8e139f41315478133992cc8ad1">M_parser_create</a> (M_uint32 flags)</td></tr>
<tr class="separator:gaf8100f8e139f41315478133992cc8ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cd7b444d6f5058b149bc4c7262d5cb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga3cd7b444d6f5058b149bc4c7262d5cb7">M_parser_destroy</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser)</td></tr>
<tr class="separator:ga3cd7b444d6f5058b149bc4c7262d5cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga391a35eb1787b282c73eb1021dc33c2b"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga391a35eb1787b282c73eb1021dc33c2b">M_parser_append</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const unsigned char *data, size_t len)</td></tr>
<tr class="separator:ga391a35eb1787b282c73eb1021dc33c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7c70c0facff28d38d65caafbc326a8f"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gae7c70c0facff28d38d65caafbc326a8f">M_parser_direct_write_start</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t *len)</td></tr>
<tr class="separator:gae7c70c0facff28d38d65caafbc326a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14b91c32b4aae0787a6ad8110211a5c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga14b91c32b4aae0787a6ad8110211a5c2">M_parser_direct_write_end</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len)</td></tr>
<tr class="separator:ga14b91c32b4aae0787a6ad8110211a5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeb4f3232d2d842889823bdf70338ac6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gafeb4f3232d2d842889823bdf70338ac6">M_parser_len</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser)</td></tr>
<tr class="separator:gafeb4f3232d2d842889823bdf70338ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b5781577215858456bdce9155cf69c5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga4b5781577215858456bdce9155cf69c5">M_parser_current_offset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser)</td></tr>
<tr class="separator:ga4b5781577215858456bdce9155cf69c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7870ed0eeccac0f7fb2e38e2ed972e6b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga7870ed0eeccac0f7fb2e38e2ed972e6b">M_parser_current_line</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser)</td></tr>
<tr class="separator:ga7870ed0eeccac0f7fb2e38e2ed972e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ce994229ccd3cb410de40073c92dc55"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga1ce994229ccd3cb410de40073c92dc55">M_parser_current_column</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser)</td></tr>
<tr class="separator:ga1ce994229ccd3cb410de40073c92dc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51887c9bf388c83d48682a627790885e"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga51887c9bf388c83d48682a627790885e">M_parser_compare</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const unsigned char *data, size_t data_len)</td></tr>
<tr class="separator:ga51887c9bf388c83d48682a627790885e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3ad407f9b0c397cea9aa7df6a3f339e"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaa3ad407f9b0c397cea9aa7df6a3f339e">M_parser_compare_str</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const char *str, size_t max_len, M_bool casecmp)</td></tr>
<tr class="separator:gaa3ad407f9b0c397cea9aa7df6a3f339e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f6bcc3999859f9bfabce4679697d30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gad2f6bcc3999859f9bfabce4679697d30">M_parser_mark</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser)</td></tr>
<tr class="separator:gad2f6bcc3999859f9bfabce4679697d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdccdc6d15b58c8bf6fb4084e51da87c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gacdccdc6d15b58c8bf6fb4084e51da87c">M_parser_mark_clear</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser)</td></tr>
<tr class="separator:gacdccdc6d15b58c8bf6fb4084e51da87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b0cd4b491f39713f04bd48fd2703766"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga4b0cd4b491f39713f04bd48fd2703766">M_parser_mark_len</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser)</td></tr>
<tr class="separator:ga4b0cd4b491f39713f04bd48fd2703766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56a859c33b45f16a1af4134a502fc6c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gab56a859c33b45f16a1af4134a502fc6c">M_parser_mark_rewind</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser)</td></tr>
<tr class="separator:gab56a859c33b45f16a1af4134a502fc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbcbd98570e7838c421b18b5a25f7b66"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gadbcbd98570e7838c421b18b5a25f7b66">M_parser_reset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser)</td></tr>
<tr class="separator:gadbcbd98570e7838c421b18b5a25f7b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaa08bacb6e55081f7444849b57ec47f"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gadaa08bacb6e55081f7444849b57ec47f">M_parser_peek</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser)</td></tr>
<tr class="separator:gadaa08bacb6e55081f7444849b57ec47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae435df00260fa4fc23d81b31b28d9d9c"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gae435df00260fa4fc23d81b31b28d9d9c">M_parser_peek_mark</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t *len)</td></tr>
<tr class="separator:gae435df00260fa4fc23d81b31b28d9d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd6687b7e2cb0b7f56cc9f19d6a8673"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gadcd6687b7e2cb0b7f56cc9f19d6a8673">M_parser_peek_byte</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, unsigned char *byte)</td></tr>
<tr class="separator:gadcd6687b7e2cb0b7f56cc9f19d6a8673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadac6c0aa8625b579f2389ea68241dd69"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gadac6c0aa8625b579f2389ea68241dd69">M_parser_peek_bytes</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len, unsigned char *buf)</td></tr>
<tr class="separator:gadac6c0aa8625b579f2389ea68241dd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08f2013de7df0efcd660ac7f2cf38a22"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga08f2013de7df0efcd660ac7f2cf38a22">M_parser_truncate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len)</td></tr>
<tr class="separator:ga08f2013de7df0efcd660ac7f2cf38a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf618c6d365e141cbe49e2d6f79cf8a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gabaf618c6d365e141cbe49e2d6f79cf8a">M_parser_truncate_whitespace</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, M_uint32 flags)</td></tr>
<tr class="separator:gabaf618c6d365e141cbe49e2d6f79cf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16f62929ee6ed59fb1ca56888a81ed91"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga16f62929ee6ed59fb1ca56888a81ed91">M_parser_truncate_until</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const unsigned char *pat, size_t len, M_bool eat_pat)</td></tr>
<tr class="separator:ga16f62929ee6ed59fb1ca56888a81ed91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6116926da6f01506e01ccf4c0ab79d7d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga6116926da6f01506e01ccf4c0ab79d7d">M_parser_truncate_charset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const unsigned char *charset, size_t charset_len)</td></tr>
<tr class="separator:ga6116926da6f01506e01ccf4c0ab79d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec5ac821bb893d26dc377513388d55d5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaec5ac821bb893d26dc377513388d55d5">M_parser_truncate_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a> func)</td></tr>
<tr class="separator:gaec5ac821bb893d26dc377513388d55d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga051d722c724be47a2c9913273a6a2d08"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga051d722c724be47a2c9913273a6a2d08">M_parser_truncate_chr_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__chr.html#ga24152bf5695c3990606a71947526af7e">M_chr_predicate_func</a> func)</td></tr>
<tr class="separator:ga051d722c724be47a2c9913273a6a2d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd862d0a0bbb2ac32253550789672aa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gadbd862d0a0bbb2ac32253550789672aa">M_parser_truncate_str_until</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const char *pat, M_bool eat_pat)</td></tr>
<tr class="separator:gadbd862d0a0bbb2ac32253550789672aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae44bc093c68c07ba655d5efc18d8e556"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gae44bc093c68c07ba655d5efc18d8e556">M_parser_truncate_str_charset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const char *charset)</td></tr>
<tr class="separator:gae44bc093c68c07ba655d5efc18d8e556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeda26cd977e7e60d89b178f6b40eca37"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaeda26cd977e7e60d89b178f6b40eca37">M_parser_consume</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len)</td></tr>
<tr class="separator:gaeda26cd977e7e60d89b178f6b40eca37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga226c2a475fff950ee1e288d47ff4ab6e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga226c2a475fff950ee1e288d47ff4ab6e">M_parser_consume_whitespace</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, M_uint32 flags)</td></tr>
<tr class="separator:ga226c2a475fff950ee1e288d47ff4ab6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae09ef7f274b45bbe005bb7f0d96ae011"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gae09ef7f274b45bbe005bb7f0d96ae011">M_parser_consume_until</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const unsigned char *pat, size_t len, M_bool eat_pat)</td></tr>
<tr class="separator:gae09ef7f274b45bbe005bb7f0d96ae011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94d17dbc917bc704c9fea3030e1f8b45"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga94d17dbc917bc704c9fea3030e1f8b45">M_parser_consume_charset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const unsigned char *charset, size_t charset_len)</td></tr>
<tr class="separator:ga94d17dbc917bc704c9fea3030e1f8b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a0034a0a33bf61fe8e27757deaae37c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga4a0034a0a33bf61fe8e27757deaae37c">M_parser_consume_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a> func)</td></tr>
<tr class="separator:ga4a0034a0a33bf61fe8e27757deaae37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cbbbcde287b18feba2cf8f4395aa799"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga5cbbbcde287b18feba2cf8f4395aa799">M_parser_consume_chr_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__chr.html#ga24152bf5695c3990606a71947526af7e">M_chr_predicate_func</a> func)</td></tr>
<tr class="separator:ga5cbbbcde287b18feba2cf8f4395aa799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36b3403f266cf4effbb0393a64d87828"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga36b3403f266cf4effbb0393a64d87828">M_parser_consume_str_until</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const char *pat, M_bool eat_pat)</td></tr>
<tr class="separator:ga36b3403f266cf4effbb0393a64d87828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d3c31e4bf731248fffc55274b968a6e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga3d3c31e4bf731248fffc55274b968a6e">M_parser_consume_str_charset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const char *charset)</td></tr>
<tr class="separator:ga3d3c31e4bf731248fffc55274b968a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64dd85cefe6dc965fde7532de8710957"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga64dd85cefe6dc965fde7532de8710957">M_parser_consume_not_charset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const unsigned char *charset, size_t charset_len)</td></tr>
<tr class="separator:ga64dd85cefe6dc965fde7532de8710957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6c7cf99a09fdad1ad8a6975d3dbd2d0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gad6c7cf99a09fdad1ad8a6975d3dbd2d0">M_parser_consume_str_not_charset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const char *charset)</td></tr>
<tr class="separator:gad6c7cf99a09fdad1ad8a6975d3dbd2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b8b17b5e3e553ffdaba93a81dae5d50"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga7b8b17b5e3e553ffdaba93a81dae5d50">M_parser_consume_eol</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser)</td></tr>
<tr class="separator:ga7b8b17b5e3e553ffdaba93a81dae5d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9636268867f8c53568b78e9b11b9f19"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gae9636268867f8c53568b78e9b11b9f19">M_parser_read_int</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, enum <a class="el" href="group__m__parser.html#gaf9512fcb78f39b6ca6a382641820bea9">M_PARSER_INTEGER_TYPE</a> type, size_t len, unsigned char base, M_int64 *integer)</td></tr>
<tr class="separator:gae9636268867f8c53568b78e9b11b9f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ad9c749c8cddc5fca4b7b9cbcefdd01"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga7ad9c749c8cddc5fca4b7b9cbcefdd01">M_parser_read_uint</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, enum <a class="el" href="group__m__parser.html#gaf9512fcb78f39b6ca6a382641820bea9">M_PARSER_INTEGER_TYPE</a> type, size_t len, unsigned char base, M_uint64 *integer)</td></tr>
<tr class="separator:ga7ad9c749c8cddc5fca4b7b9cbcefdd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fbaa2939f187d897d21d9182f5b9b23"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga5fbaa2939f187d897d21d9182f5b9b23">M_parser_read_uint_bcd</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len, M_uint64 *integer)</td></tr>
<tr class="separator:ga5fbaa2939f187d897d21d9182f5b9b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a9d5263972f4d6169f829cac1684ab"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__m__decimal.html#ga7c1d6ded689031ea022be05e0a3bcbd8">M_DECIMAL_RETVAL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gae0a9d5263972f4d6169f829cac1684ab">M_parser_read_decimal</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len, M_bool truncate_fail, <a class="el" href="group__m__decimal.html#structM__decimal__t">M_decimal_t</a> *decimal)</td></tr>
<tr class="separator:gae0a9d5263972f4d6169f829cac1684ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba7a40c4c5eb8e069f02d4692183560b"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaba7a40c4c5eb8e069f02d4692183560b">M_parser_read_byte</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, unsigned char *byte)</td></tr>
<tr class="separator:gaba7a40c4c5eb8e069f02d4692183560b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33cfa027ef5dc9282fff60396e0477e3"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga33cfa027ef5dc9282fff60396e0477e3">M_parser_read_bytes</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len, unsigned char *buf)</td></tr>
<tr class="separator:ga33cfa027ef5dc9282fff60396e0477e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadefa7b7229a1ad2e69508e531c8d6f0b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gadefa7b7229a1ad2e69508e531c8d6f0b">M_parser_read_bytes_max</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len, unsigned char *buf, size_t buf_len)</td></tr>
<tr class="separator:gadefa7b7229a1ad2e69508e531c8d6f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcd493e23587c2b4f441737b7d5c371b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gafcd493e23587c2b4f441737b7d5c371b">M_parser_read_bytes_until</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, unsigned char *buf, size_t buf_len, const unsigned char *pat, size_t pat_len, M_bool eat_pat)</td></tr>
<tr class="separator:gafcd493e23587c2b4f441737b7d5c371b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga653e75ca090e6a8c7e3dda5fb6604fd3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga653e75ca090e6a8c7e3dda5fb6604fd3">M_parser_read_bytes_charset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const unsigned char *charset, size_t charset_len, unsigned char *buf, size_t buf_len)</td></tr>
<tr class="separator:ga653e75ca090e6a8c7e3dda5fb6604fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeed5c08551e302f39eec049c988b4082"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaeed5c08551e302f39eec049c988b4082">M_parser_read_bytes_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a> func, unsigned char *buf, size_t buf_len)</td></tr>
<tr class="separator:gaeed5c08551e302f39eec049c988b4082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00c393187e7984c21c1a5f2a8c2e5219"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga00c393187e7984c21c1a5f2a8c2e5219">M_parser_read_bytes_chr_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__chr.html#ga24152bf5695c3990606a71947526af7e">M_chr_predicate_func</a> func, unsigned char *buf, size_t buf_len)</td></tr>
<tr class="separator:ga00c393187e7984c21c1a5f2a8c2e5219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb4c73209e80d9e2a0345c72b08ac34d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gabb4c73209e80d9e2a0345c72b08ac34d">M_parser_read_bytes_mark</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, unsigned char *buf, size_t buf_len)</td></tr>
<tr class="separator:gabb4c73209e80d9e2a0345c72b08ac34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95c6f1b66486d43585e8a2b9dedb49ca"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga95c6f1b66486d43585e8a2b9dedb49ca">M_parser_read_str</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len, char *buf, size_t buf_len)</td></tr>
<tr class="separator:ga95c6f1b66486d43585e8a2b9dedb49ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf65f2c7e819c22d9513311be47a80926"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaf65f2c7e819c22d9513311be47a80926">M_parser_read_str_max</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len, char *buf, size_t buf_len)</td></tr>
<tr class="separator:gaf65f2c7e819c22d9513311be47a80926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b97d270eb217b89c403c5e80e0fc381"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga6b97d270eb217b89c403c5e80e0fc381">M_parser_read_str_until</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, char *buf, size_t buf_len, const char *pat, M_bool eat_pat)</td></tr>
<tr class="separator:ga6b97d270eb217b89c403c5e80e0fc381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf98ba19b8cdaddc55c486b49c123953"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaaf98ba19b8cdaddc55c486b49c123953">M_parser_read_str_charset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const char *charset, char *buf, size_t buf_len)</td></tr>
<tr class="separator:gaaf98ba19b8cdaddc55c486b49c123953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7f2a3af4348fd0ad0b16f48bdf35ae8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gab7f2a3af4348fd0ad0b16f48bdf35ae8">M_parser_read_str_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a> func, char *buf, size_t buf_len)</td></tr>
<tr class="separator:gab7f2a3af4348fd0ad0b16f48bdf35ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bf2ae228f89c06b4ddf311f34c2153c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga8bf2ae228f89c06b4ddf311f34c2153c">M_parser_read_str_chr_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__chr.html#ga24152bf5695c3990606a71947526af7e">M_chr_predicate_func</a> func, char *buf, size_t buf_len)</td></tr>
<tr class="separator:ga8bf2ae228f89c06b4ddf311f34c2153c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf274d0a0cb831e8fd41fc66d166fad48"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaf274d0a0cb831e8fd41fc66d166fad48">M_parser_read_str_mark</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, char *buf, size_t buf_len)</td></tr>
<tr class="separator:gaf274d0a0cb831e8fd41fc66d166fad48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c17e75e8d82879f94dc47209a293ca7"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga0c17e75e8d82879f94dc47209a293ca7">M_parser_read_strdup</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len)</td></tr>
<tr class="separator:ga0c17e75e8d82879f94dc47209a293ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab8428cf93d6cdf48705518084bf9555"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaab8428cf93d6cdf48705518084bf9555">M_parser_read_strdup_hex</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len)</td></tr>
<tr class="separator:gaab8428cf93d6cdf48705518084bf9555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73e0d3b9c2ada037c58264100a862183"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga73e0d3b9c2ada037c58264100a862183">M_parser_read_strdup_until</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const char *pat, M_bool eat_pat)</td></tr>
<tr class="separator:ga73e0d3b9c2ada037c58264100a862183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadc81b291d5b29f2c237dafe8d771512"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaadc81b291d5b29f2c237dafe8d771512">M_parser_read_strdup_charset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const char *charset)</td></tr>
<tr class="separator:gaadc81b291d5b29f2c237dafe8d771512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb1485431bd0d0b299fd6d5986a1b3bb"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gadb1485431bd0d0b299fd6d5986a1b3bb">M_parser_read_strdup_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a> func)</td></tr>
<tr class="separator:gadb1485431bd0d0b299fd6d5986a1b3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b154a08db31ce892470aebdc61d0236"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga6b154a08db31ce892470aebdc61d0236">M_parser_read_strdup_chr_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__chr.html#ga24152bf5695c3990606a71947526af7e">M_chr_predicate_func</a> func)</td></tr>
<tr class="separator:ga6b154a08db31ce892470aebdc61d0236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d79542fe6a498f071bbcc8fcb081949"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga0d79542fe6a498f071bbcc8fcb081949">M_parser_read_strdup_mark</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser)</td></tr>
<tr class="separator:ga0d79542fe6a498f071bbcc8fcb081949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33730a63386c3519b3a5730cd196ad7e"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga33730a63386c3519b3a5730cd196ad7e">M_parser_read_buf</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *buf, size_t len)</td></tr>
<tr class="separator:ga33730a63386c3519b3a5730cd196ad7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ff2b65e5f78f3d32883cbd4fc28be9"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga99ff2b65e5f78f3d32883cbd4fc28be9">M_parser_read_buf_hex</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *buf, size_t len)</td></tr>
<tr class="separator:ga99ff2b65e5f78f3d32883cbd4fc28be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6bb840e9a466ff0ccf3d439b40c0aa0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gad6bb840e9a466ff0ccf3d439b40c0aa0">M_parser_read_buf_max</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *buf, size_t len)</td></tr>
<tr class="separator:gad6bb840e9a466ff0ccf3d439b40c0aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga049ba42f48dd6ca9147d47df0284704d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga049ba42f48dd6ca9147d47df0284704d">M_parser_read_buf_until</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *buf, const unsigned char *pat, size_t pat_len, M_bool eat_pat)</td></tr>
<tr class="separator:ga049ba42f48dd6ca9147d47df0284704d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafadd538e27da591c2960731607fae06d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gafadd538e27da591c2960731607fae06d">M_parser_read_buf_charset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *buf, const unsigned char *charset, size_t charset_len)</td></tr>
<tr class="separator:gafadd538e27da591c2960731607fae06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55820b0eb422fe9c6715e6fe3a7c2cd1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga55820b0eb422fe9c6715e6fe3a7c2cd1">M_parser_read_buf_not_charset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *buf, const unsigned char *charset, size_t charset_len)</td></tr>
<tr class="separator:ga55820b0eb422fe9c6715e6fe3a7c2cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba5b5ccc50da131855aaf9c335a779c7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaba5b5ccc50da131855aaf9c335a779c7">M_parser_read_buf_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *buf, <a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a> func)</td></tr>
<tr class="separator:gaba5b5ccc50da131855aaf9c335a779c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga168a369d88b72993cc87c4ce865915a5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga168a369d88b72993cc87c4ce865915a5">M_parser_read_buf_chr_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *buf, <a class="el" href="group__m__chr.html#ga24152bf5695c3990606a71947526af7e">M_chr_predicate_func</a> func)</td></tr>
<tr class="separator:ga168a369d88b72993cc87c4ce865915a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b588e85abde4af0a5e65fe2491f6f5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gab0b588e85abde4af0a5e65fe2491f6f5">M_parser_read_buf_mark</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *buf)</td></tr>
<tr class="separator:gab0b588e85abde4af0a5e65fe2491f6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8453d3f5345a1a5e36e5b0b023778dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gac8453d3f5345a1a5e36e5b0b023778dc">M_parser_read_parser</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len)</td></tr>
<tr class="separator:gac8453d3f5345a1a5e36e5b0b023778dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91f0b519b752eccdc0a952e61953fff8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga91f0b519b752eccdc0a952e61953fff8">M_parser_read_parser_until</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, const unsigned char *pat, size_t len, M_bool eat_pat)</td></tr>
<tr class="separator:ga91f0b519b752eccdc0a952e61953fff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga123cb0b91d056546ab9737933490176e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga123cb0b91d056546ab9737933490176e">M_parser_read_parser_charset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, unsigned const char *charset, size_t charset_len)</td></tr>
<tr class="separator:ga123cb0b91d056546ab9737933490176e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac11a976b2931694a40304279200d2cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaac11a976b2931694a40304279200d2cc">M_parser_read_parser_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a> func)</td></tr>
<tr class="separator:gaac11a976b2931694a40304279200d2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae16690c90e83c136a2252df4ce5a7b69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gae16690c90e83c136a2252df4ce5a7b69">M_parser_read_parser_chr_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a> func)</td></tr>
<tr class="separator:gae16690c90e83c136a2252df4ce5a7b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53670fe8b46c97cca6fb2b91165a9b1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga53670fe8b46c97cca6fb2b91165a9b1d">M_parser_read_parser_mark</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser)</td></tr>
<tr class="separator:ga53670fe8b46c97cca6fb2b91165a9b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92fee6f3045a04e33a5c075f09e72ba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__parser.html#ga6993008e1f0881f84431d5813f33d127">M_PARSER_FRAME_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga92fee6f3045a04e33a5c075f09e72ba3">M_parser_read_stxetxlrc_message</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, <a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> **out, M_uint32 lrc_frame_chars)</td></tr>
<tr class="separator:ga92fee6f3045a04e33a5c075f09e72ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadf16d5f9fafe29fecb3648f652909bc"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaadf16d5f9fafe29fecb3648f652909bc">M_parser_is_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len, <a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a> func)</td></tr>
<tr class="separator:gaadf16d5f9fafe29fecb3648f652909bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa88442d7f03374ae9a1e331a6a438dcd"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaa88442d7f03374ae9a1e331a6a438dcd">M_parser_is_chr_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len, <a class="el" href="group__m__chr.html#ga24152bf5695c3990606a71947526af7e">M_chr_predicate_func</a> func)</td></tr>
<tr class="separator:gaa88442d7f03374ae9a1e331a6a438dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee24382838045df85d9a2c5fabad273e"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaee24382838045df85d9a2c5fabad273e">M_parser_is_charset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len, const unsigned char *charset, size_t charset_len)</td></tr>
<tr class="separator:gaee24382838045df85d9a2c5fabad273e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefa200381fcfe8b6d90722b445ddfce8"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaefa200381fcfe8b6d90722b445ddfce8">M_parser_is_str_charset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len, const char *charset)</td></tr>
<tr class="separator:gaefa200381fcfe8b6d90722b445ddfce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6793576c9c5c8aca9f376f7e9a7a28a1"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga6793576c9c5c8aca9f376f7e9a7a28a1">M_parser_is_not_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len, <a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a> func)</td></tr>
<tr class="separator:ga6793576c9c5c8aca9f376f7e9a7a28a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c4ff475ade6a092401a72479a1d7238"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga4c4ff475ade6a092401a72479a1d7238">M_parser_is_not_chr_predicate</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len, <a class="el" href="group__m__chr.html#ga24152bf5695c3990606a71947526af7e">M_chr_predicate_func</a> func)</td></tr>
<tr class="separator:ga4c4ff475ade6a092401a72479a1d7238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc8435d6e2e41ec21c14e6965adeb580"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gabc8435d6e2e41ec21c14e6965adeb580">M_parser_is_not_charset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len, const unsigned char *charset, size_t charset_len)</td></tr>
<tr class="separator:gabc8435d6e2e41ec21c14e6965adeb580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab16f381ae01e5a47d36cb3b36c7ab3cc"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gab16f381ae01e5a47d36cb3b36c7ab3cc">M_parser_is_not_str_charset</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, size_t len, const char *charset)</td></tr>
<tr class="separator:gab16f381ae01e5a47d36cb3b36c7ab3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff3a3e053b6e66cdc20919360867ac57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#gaff3a3e053b6e66cdc20919360867ac57">M_parser_split</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser, unsigned char delim, size_t maxcnt, M_uint32 flags, size_t *num_output)</td></tr>
<tr class="separator:gaff3a3e053b6e66cdc20919360867ac57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f40799b9f60ee628d4b9aaa2523109e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__parser.html#ga2f40799b9f60ee628d4b9aaa2523109e">M_parser_split_free</a> (<a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> **parsers, size_t cnt)</td></tr>
<tr class="separator:ga2f40799b9f60ee628d4b9aaa2523109e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Buffer based data parser.</p>
<p>Efficient parser that prevents reading past the end of the data buffer. Has helpers for reading specific types from the buffer (auto conversion). Also supports line and column tracking. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga60164be64f8c962c795e5927642fc473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60164be64f8c962c795e5927642fc473">&#9670;&nbsp;</a></span>M_parser_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct M_parser <a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf02bf52755e0b9fc5d18dccd81ba55d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf02bf52755e0b9fc5d18dccd81ba55d0">&#9670;&nbsp;</a></span>M_parser_predicate_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_bool(* M_parser_predicate_func) (unsigned char c)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga5f283601804b657a199f6574996ccf87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f283601804b657a199f6574996ccf87">&#9670;&nbsp;</a></span>M_PARSER_FLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__m__parser.html#ga5f283601804b657a199f6574996ccf87">M_PARSER_FLAGS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags controlling behavior of the parser. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5f283601804b657a199f6574996ccf87a5879ad8c9fea3f4031268d7917b03933"></a>M_PARSER_FLAG_NONE&#160;</td><td class="fielddoc"><p>No Flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5f283601804b657a199f6574996ccf87a4dd69b089e5b923f02bf2c38afd32c11"></a>M_PARSER_FLAG_TRACKLINES&#160;</td><td class="fielddoc"><p>Track lines and columns. This should only be enabled if needed as it will cause an additional data scan. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga31929e2f622a249ba03d8ff374469951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31929e2f622a249ba03d8ff374469951">&#9670;&nbsp;</a></span>M_PARSER_WHITESPACE_FLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__m__parser.html#ga31929e2f622a249ba03d8ff374469951">M_PARSER_WHITESPACE_FLAGS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags controlling what constitutes whitespace. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga31929e2f622a249ba03d8ff374469951ad8df579debcff24e7681b598c4ad441f"></a>M_PARSER_WHITESPACE_NONE&#160;</td><td class="fielddoc"><p>Consumes all whitespace </p>
</td></tr>
<tr><td class="fieldname"><a id="gga31929e2f622a249ba03d8ff374469951a1971c85ac90d36664ce49fb7eebb500e"></a>M_PARSER_WHITESPACE_TO_NEWLINE&#160;</td><td class="fielddoc"><p>Only consume whitespace up to and including the next new line. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga31929e2f622a249ba03d8ff374469951a30bfcb0864636783c43a3c35015cf19e"></a>M_PARSER_WHITESPACE_SPACEONLY&#160;</td><td class="fielddoc"><p>Only consume space 0x20 characters. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf9512fcb78f39b6ca6a382641820bea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9512fcb78f39b6ca6a382641820bea9">&#9670;&nbsp;</a></span>M_PARSER_INTEGER_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__m__parser.html#gaf9512fcb78f39b6ca6a382641820bea9">M_PARSER_INTEGER_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Integer binary format. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf9512fcb78f39b6ca6a382641820bea9abe2371658d8efffa9c57046c0c081996"></a>M_PARSER_INTEGER_ASCII&#160;</td><td class="fielddoc"><p>Integer represented in ASCII form. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9512fcb78f39b6ca6a382641820bea9a5230fd44caeffcbbf0f7042a825ed7eb"></a>M_PARSER_INTEGER_BIGENDIAN&#160;</td><td class="fielddoc"><p>Integer represented in Big Endian form. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf9512fcb78f39b6ca6a382641820bea9aa5fad8025be1078f9100d56f2b7a1516"></a>M_PARSER_INTEGER_LITTLEENDIAN&#160;</td><td class="fielddoc"><p>Integer represented in Little Endian form. </p>
</td></tr>
</table>

</div>
</div>
<a id="gafa8162f3759d9033f13b4c209b63e46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa8162f3759d9033f13b4c209b63e46e">&#9670;&nbsp;</a></span>M_PARSER_SPLIT_FLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__m__parser.html#gafa8162f3759d9033f13b4c209b63e46e">M_PARSER_SPLIT_FLAGS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Splitting flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafa8162f3759d9033f13b4c209b63e46ea354d7c9d887a4da603f926c1d8a326c5"></a>M_PARSER_SPLIT_FLAG_NONE&#160;</td><td class="fielddoc"><p>No flags, standard behavior </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafa8162f3759d9033f13b4c209b63e46ea1d8b9ec4214637219b0299c4050d181c"></a>M_PARSER_SPLIT_FLAG_NODELIM_ERROR&#160;</td><td class="fielddoc"><p>Return an error if the specified delimiter is not found, otherwise all the data is put in a single parser object </p>
</td></tr>
</table>

</div>
</div>
<a id="ga3fbdc774c77f61b74f797598209b682c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fbdc774c77f61b74f797598209b682c">&#9670;&nbsp;</a></span>M_PARSER_FRAME_BYES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__m__parser.html#ga3fbdc774c77f61b74f797598209b682c">M_PARSER_FRAME_BYES</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Framing characters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3fbdc774c77f61b74f797598209b682cabeaf1fa32982e348935e8db5f0f930f3"></a>M_PARSER_FRAME_NONE&#160;</td><td class="fielddoc"><p>No framing characters. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3fbdc774c77f61b74f797598209b682caddc7c80678b6ff04ab9947b5182b1ca9"></a>M_PARSER_FRAME_STX&#160;</td><td class="fielddoc"><p>STX (0x02) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3fbdc774c77f61b74f797598209b682caf93ba74fbec931a58ad1f78964572720"></a>M_PARSER_FRAME_ETX&#160;</td><td class="fielddoc"><p>ETX (0x03) </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6993008e1f0881f84431d5813f33d127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6993008e1f0881f84431d5813f33d127">&#9670;&nbsp;</a></span>M_PARSER_FRAME_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__m__parser.html#ga6993008e1f0881f84431d5813f33d127">M_PARSER_FRAME_ERROR</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STX, ETX, LRC unwrapping responses. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6993008e1f0881f84431d5813f33d127a1163baeeb38554303ed45fed0edb15fc"></a>M_PARSER_FRAME_ERROR_SUCCESS&#160;</td><td class="fielddoc"><p>Success. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6993008e1f0881f84431d5813f33d127a2fad5328c562dcc45572828ef656cfd9"></a>M_PARSER_FRAME_ERROR_INVALID&#160;</td><td class="fielddoc"><p>Invalid input. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6993008e1f0881f84431d5813f33d127a4544399f853ded518a022b3f36a123c6"></a>M_PARSER_FRAME_ERROR_NO_STX&#160;</td><td class="fielddoc"><p>Data does not start with STX. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6993008e1f0881f84431d5813f33d127af99ee53c87f81cfd85a496a4b6b26e0a"></a>M_PARSER_FRAME_ERROR_NO_ETX&#160;</td><td class="fielddoc"><p>ETX not found. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6993008e1f0881f84431d5813f33d127a2d34642d05ef0dd48f6024645b4aa573"></a>M_PARSER_FRAME_ERROR_NO_LRC&#160;</td><td class="fielddoc"><p>Not enough data for LRC. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6993008e1f0881f84431d5813f33d127a701af53f85eb9dfd398ba8200b4d4059"></a>M_PARSER_FRAME_ERROR_LRC_CALC_FAILED&#160;</td><td class="fielddoc"><p>LRC calculation failed. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac2ea9787b8a0d3876e3f39256a40b41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2ea9787b8a0d3876e3f39256a40b41e">&#9670;&nbsp;</a></span>M_parser_create_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a>* M_parser_create_const </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint32&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a parser object using const data.</p>
<p>The object is initialized with constant data which cannot be appended to. Memory is not duplicated and therefore the memory for the buffer pointed to must exist for the life of the parser. The parser will not clean up the memory for the referenced object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Data to parse, must not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of data to be parsed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Any of the enum M_PARSER_FLAGS bitwise OR'd together.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Parser object, or NULL on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__parser.html#ga3cd7b444d6f5058b149bc4c7262d5cb7">M_parser_destroy</a> </dd></dl>

</div>
</div>
<a id="gaf8100f8e139f41315478133992cc8ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8100f8e139f41315478133992cc8ad1">&#9670;&nbsp;</a></span>M_parser_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a>* M_parser_create </td>
          <td>(</td>
          <td class="paramtype">M_uint32&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize an empty parser object.</p>
<p>Its initial state is empty and data must be appended to it before any data can be parsed.</p>
<p>IMPLEMENTATION NOTE: For efficiency, data which is parsed will be purged from memory when additional internal buffer space is required during an append operation. This is to reclaim space and reduce the number of allocations required when parsing stream-based data.</p>
<dl class="section return"><dt>Returns</dt><dd>Parser object, or NULL on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__parser.html#ga3cd7b444d6f5058b149bc4c7262d5cb7">M_parser_destroy</a> </dd></dl>

</div>
</div>
<a id="ga3cd7b444d6f5058b149bc4c7262d5cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cd7b444d6f5058b149bc4c7262d5cb7">&#9670;&nbsp;</a></span>M_parser_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_parser_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy the parser object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga391a35eb1787b282c73eb1021dc33c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga391a35eb1787b282c73eb1021dc33c2b">&#9670;&nbsp;</a></span>M_parser_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append data to a parser object.</p>
<p>The parser object must have been initialized with <a class="el" href="group__m__parser.html#gaf8100f8e139f41315478133992cc8ad1">M_parser_create()</a>. This will append the data to the internal buffer extending the available length of data to parse.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object, but not be a const object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to append. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of data to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE on misuse. </dd></dl>

</div>
</div>
<a id="gae7c70c0facff28d38d65caafbc326a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7c70c0facff28d38d65caafbc326a8f">&#9670;&nbsp;</a></span>M_parser_direct_write_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* M_parser_direct_write_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Begin a direct write operation. In general, this function should not be used, it is meant as an optimization to prevent double buffering when reading I/O. A writable buffer will be returned of at least the length requested, often it will be much larger. To end the direct write process, <a class="el" href="group__m__parser.html#ga14b91c32b4aae0787a6ad8110211a5c2">M_parser_direct_write_end()</a> must be called with the length actually written. It is not valid to call any other M_parser_*() functions between start and end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object, but not be a const object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Pass in the minimum requested buffer size, outputs the maximum writable buffer size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Writable buffer or NULL on failure </dd></dl>

</div>
</div>
<a id="ga14b91c32b4aae0787a6ad8110211a5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14b91c32b4aae0787a6ad8110211a5c2">&#9670;&nbsp;</a></span>M_parser_direct_write_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_parser_direct_write_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End a direct write operation. Please see <a class="el" href="group__m__parser.html#gae7c70c0facff28d38d65caafbc326a8f">M_parser_direct_write_start()</a> for more information. This terminates a direct write sequence regardless of if data was written or not (len = 0 is acceptable).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object, but not a const object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of data written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafeb4f3232d2d842889823bdf70338ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafeb4f3232d2d842889823bdf70338ac6">&#9670;&nbsp;</a></span>M_parser_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the length of data remaining in the buffer being parsed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>Parser object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of remaining data. </dd></dl>

</div>
</div>
<a id="ga4b5781577215858456bdce9155cf69c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b5781577215858456bdce9155cf69c5">&#9670;&nbsp;</a></span>M_parser_current_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_current_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the total number of bytes processed so far.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Parser object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of processed bytes. </dd></dl>

</div>
</div>
<a id="ga7870ed0eeccac0f7fb2e38e2ed972e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7870ed0eeccac0f7fb2e38e2ed972e6b">&#9670;&nbsp;</a></span>M_parser_current_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_current_line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the current line number.</p>
<p>Line numbers are determined based on how many \n's have been evaluated in the data stream. This can only be called if M_PARSER_FLAG_TRACKLINES was used during initialization of the parser.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>parser object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Line number starting at 1. </dd></dl>

</div>
</div>
<a id="ga1ce994229ccd3cb410de40073c92dc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ce994229ccd3cb410de40073c92dc55">&#9670;&nbsp;</a></span>M_parser_current_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_current_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the current column for the current line.</p>
<p>The column count resets each time a \n is passed. This can only be called if M_PARSER_FLAG_TRACKLINES was used during initialization of the parser.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Parser object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Column number starting at 1. </dd></dl>

</div>
</div>
<a id="ga51887c9bf388c83d48682a627790885e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51887c9bf388c83d48682a627790885e">&#9670;&nbsp;</a></span>M_parser_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare parser contents to provided buffer</p>
<p>Does not advance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_len</td><td>Length of data to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if match, M_FALSE otherwise </dd></dl>

</div>
</div>
<a id="gaa3ad407f9b0c397cea9aa7df6a3f339e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3ad407f9b0c397cea9aa7df6a3f339e">&#9670;&nbsp;</a></span>M_parser_compare_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_compare_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>casecmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare parser contents to provided string.</p>
<p>Does not advance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>String data to compare. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_len</td><td>Maximum length of data to compare, 0 for entire string. If 0 is specified, then also the entire parser buffer must be an exact match. If there are extra bytes after the match, this will not be considered an exact match. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">casecmp</td><td>Perform case-insensitive comparison?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if match, M_FALSE otherwise </dd></dl>

</div>
</div>
<a id="gad2f6bcc3999859f9bfabce4679697d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2f6bcc3999859f9bfabce4679697d30">&#9670;&nbsp;</a></span>M_parser_mark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_parser_mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks the current position for future reference in case additional data might need to be pulled from this marked point forward.</p>
<p>If a data position is marked, it will not be eligible to be destroyed/chopped until the marked position is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacdccdc6d15b58c8bf6fb4084e51da87c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdccdc6d15b58c8bf6fb4084e51da87c">&#9670;&nbsp;</a></span>M_parser_mark_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_parser_mark_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the current marked position, allowing it to be garbage collected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4b0cd4b491f39713f04bd48fd2703766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b0cd4b491f39713f04bd48fd2703766">&#9670;&nbsp;</a></span>M_parser_mark_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_mark_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtain the length of the marked position to the current position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>Parser object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length or 0 on error. </dd></dl>

</div>
</div>
<a id="gab56a859c33b45f16a1af4134a502fc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab56a859c33b45f16a1af4134a502fc6c">&#9670;&nbsp;</a></span>M_parser_mark_rewind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_mark_rewind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rewind data back to the marked position.</p>
<p>This will automaticaly clear the marked position so if the marked position is still needed, the caller must re-mark it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes rewinded or 0 on error. </dd></dl>

</div>
</div>
<a id="gadbcbd98570e7838c421b18b5a25f7b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbcbd98570e7838c421b18b5a25f7b66">&#9670;&nbsp;</a></span>M_parser_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset set the parser back to the beginning of the data.</p>
<p>This is only applicable to 'const' parsers, and will fail on dynamic parsers. If this scans back past a marked position, the mark will be automatically cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes regurgitated or 0 on error. </dd></dl>

</div>
</div>
<a id="gadaa08bacb6e55081f7444849b57ec47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaa08bacb6e55081f7444849b57ec47f">&#9670;&nbsp;</a></span>M_parser_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char* M_parser_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the internal pointer for the current position in the parse buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>Parser object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to data. </dd></dl>

</div>
</div>
<a id="gae435df00260fa4fc23d81b31b28d9d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae435df00260fa4fc23d81b31b28d9d9c">&#9670;&nbsp;</a></span>M_parser_peek_mark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char* M_parser_peek_mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the internal pointer for the marked position in the parse buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">len</td><td>Length of marked data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to data. </dd></dl>

</div>
</div>
<a id="gadcd6687b7e2cb0b7f56cc9f19d6a8673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcd6687b7e2cb0b7f56cc9f19d6a8673">&#9670;&nbsp;</a></span>M_parser_peek_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_peek_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a single byte from the current buffer without advancing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">byte</td><td>Outputs byte read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE on failure. </dd></dl>

</div>
</div>
<a id="gadac6c0aa8625b579f2389ea68241dd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadac6c0aa8625b579f2389ea68241dd69">&#9670;&nbsp;</a></span>M_parser_peek_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_peek_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read bytes (binary) from the current buffer and output in the user-provided buffer without advancing.</p>
<p>The data read will not be NULL terminated and the buffer provided must be at least as large as large as the requested data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of data to read. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf</td><td>Buffer to hold output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE if not enough bytes or other error. </dd></dl>

</div>
</div>
<a id="ga08f2013de7df0efcd660ac7f2cf38a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08f2013de7df0efcd660ac7f2cf38a22">&#9670;&nbsp;</a></span>M_parser_truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate the parse buffer at the position specified (relative to the current parse offset).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length to truncate to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE if not enough bytes exist in the data stream or other error. </dd></dl>

</div>
</div>
<a id="gabaf618c6d365e141cbe49e2d6f79cf8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaf618c6d365e141cbe49e2d6f79cf8a">&#9670;&nbsp;</a></span>M_parser_truncate_whitespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_truncate_whitespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint32&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate all available whitespace.</p>
<p>Searches backwards from end to start.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>A bitmap of enum M_PARSER_WHITESPACE_FLAGS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes consumed. </dd></dl>

</div>
</div>
<a id="ga16f62929ee6ed59fb1ca56888a81ed91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16f62929ee6ed59fb1ca56888a81ed91">&#9670;&nbsp;</a></span>M_parser_truncate_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_truncate_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>eat_pat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate all bytes until the specified sequence of bytes is encountered in the data stream.</p>
<p>Searches backwards from end to start.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pat</td><td>Sequence of bytes to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of pattern data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eat_pat</td><td>Should the sequence of bytes be consumed. Useful for ignoring data until end of comment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes consumed, or 0 if not found. </dd></dl>

</div>
</div>
<a id="ga6116926da6f01506e01ccf4c0ab79d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6116926da6f01506e01ccf4c0ab79d7d">&#9670;&nbsp;</a></span>M_parser_truncate_charset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_truncate_charset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>charset_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate all bytes matching the given charset.</p>
<p>Searches backwards from end to start.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Character set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset_len</td><td>Length of given character set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes consumed, or 0 if none/error. </dd></dl>

</div>
</div>
<a id="gaec5ac821bb893d26dc377513388d55d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec5ac821bb893d26dc377513388d55d5">&#9670;&nbsp;</a></span>M_parser_truncate_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_truncate_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate all bytes matching the given predicate function.</p>
<p>Searches backwards from end to start.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Predicate function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes consumed, or 0 if none/error. </dd></dl>

</div>
</div>
<a id="ga051d722c724be47a2c9913273a6a2d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga051d722c724be47a2c9913273a6a2d08">&#9670;&nbsp;</a></span>M_parser_truncate_chr_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_truncate_chr_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__chr.html#ga24152bf5695c3990606a71947526af7e">M_chr_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate all bytes matching the given chr predicate function.</p>
<p>Searches backwards from end to start.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Predicate function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes consumed, or 0 if none/error. </dd></dl>

</div>
</div>
<a id="gadbd862d0a0bbb2ac32253550789672aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbd862d0a0bbb2ac32253550789672aa">&#9670;&nbsp;</a></span>M_parser_truncate_str_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_truncate_str_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>eat_pat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate all bytes until the specified string is encountered in the data stream.</p>
<p>Searches backwards from end to start.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pat</td><td>String to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eat_pat</td><td>Should the sequence of bytes be consumed. Useful for ignoring data until end of comment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes consumed, or 0 if not found. </dd></dl>

</div>
</div>
<a id="gae44bc093c68c07ba655d5efc18d8e556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae44bc093c68c07ba655d5efc18d8e556">&#9670;&nbsp;</a></span>M_parser_truncate_str_charset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_truncate_str_charset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate all bytes matching the given NULL-terminated charset.</p>
<p>Searches backwards from end to start.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Character set, NULL-terminated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes consumed, or 0 if none/error. </dd></dl>

</div>
</div>
<a id="gaeda26cd977e7e60d89b178f6b40eca37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeda26cd977e7e60d89b178f6b40eca37">&#9670;&nbsp;</a></span>M_parser_consume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consume the given number of bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to consume.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE if not enough bytes. </dd></dl>

</div>
</div>
<a id="ga226c2a475fff950ee1e288d47ff4ab6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga226c2a475fff950ee1e288d47ff4ab6e">&#9670;&nbsp;</a></span>M_parser_consume_whitespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_consume_whitespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint32&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consume all available whitespace.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>A bitmap of enum M_PARSER_WHITESPACE_FLAGS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes consumed. </dd></dl>

</div>
</div>
<a id="gae09ef7f274b45bbe005bb7f0d96ae011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae09ef7f274b45bbe005bb7f0d96ae011">&#9670;&nbsp;</a></span>M_parser_consume_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_consume_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>eat_pat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consume all bytes until the specified sequence of bytes is encountered in the data stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pat</td><td>Sequence of bytes to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of pattern data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eat_pat</td><td>Should the sequence of bytes be consumed. Useful for ignoring data until end of comment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes consumed, or 0 if not found. </dd></dl>

</div>
</div>
<a id="ga94d17dbc917bc704c9fea3030e1f8b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94d17dbc917bc704c9fea3030e1f8b45">&#9670;&nbsp;</a></span>M_parser_consume_charset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_consume_charset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>charset_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consume all bytes matching the given charset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Character set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset_len</td><td>Length of given character set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes consumed, or 0 if none/error. </dd></dl>

</div>
</div>
<a id="ga4a0034a0a33bf61fe8e27757deaae37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a0034a0a33bf61fe8e27757deaae37c">&#9670;&nbsp;</a></span>M_parser_consume_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_consume_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consume all bytes matching the given predicate function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Predicate function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes consumed, or 0 if none/error. </dd></dl>

</div>
</div>
<a id="ga5cbbbcde287b18feba2cf8f4395aa799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cbbbcde287b18feba2cf8f4395aa799">&#9670;&nbsp;</a></span>M_parser_consume_chr_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_consume_chr_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__chr.html#ga24152bf5695c3990606a71947526af7e">M_chr_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consume all bytes matching the given chr predicate function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Predicate function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes consumed, or 0 if none/error. </dd></dl>

</div>
</div>
<a id="ga36b3403f266cf4effbb0393a64d87828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36b3403f266cf4effbb0393a64d87828">&#9670;&nbsp;</a></span>M_parser_consume_str_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_consume_str_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>eat_pat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consume all bytes until the specified string is encountered in the data stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pat</td><td>String to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eat_pat</td><td>Should the sequence of bytes be consumed. Useful for ignoring data until end of comment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes consumed, or 0 if not found. </dd></dl>

</div>
</div>
<a id="ga3d3c31e4bf731248fffc55274b968a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d3c31e4bf731248fffc55274b968a6e">&#9670;&nbsp;</a></span>M_parser_consume_str_charset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_consume_str_charset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consume all bytes matching the given NULL-terminated charset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Character set, NULL-terminated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes consumed, or 0 if none/error. </dd></dl>

</div>
</div>
<a id="ga64dd85cefe6dc965fde7532de8710957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64dd85cefe6dc965fde7532de8710957">&#9670;&nbsp;</a></span>M_parser_consume_not_charset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_consume_not_charset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>charset_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consume all bytes not matching the given charset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Character set, NULL-terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset_len</td><td>Length of given character set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes consumed, or 0 if none/error. </dd></dl>

</div>
</div>
<a id="gad6c7cf99a09fdad1ad8a6975d3dbd2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6c7cf99a09fdad1ad8a6975d3dbd2d0">&#9670;&nbsp;</a></span>M_parser_consume_str_not_charset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_consume_str_not_charset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consume all bytes not matching the given NULL-terminated charset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Character set, NULL-terminated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes consumed, or 0 if none/error. </dd></dl>

</div>
</div>
<a id="ga7b8b17b5e3e553ffdaba93a81dae5d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b8b17b5e3e553ffdaba93a81dae5d50">&#9670;&nbsp;</a></span>M_parser_consume_eol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_consume_eol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consume all bytes until and including the next end of line.</p>
<p>Useful for ignoring data until end of single-line comment. If there is no new line, will consume all remaining data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes consumed. </dd></dl>

</div>
</div>
<a id="gae9636268867f8c53568b78e9b11b9f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9636268867f8c53568b78e9b11b9f19">&#9670;&nbsp;</a></span>M_parser_read_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_read_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__m__parser.html#gaf9512fcb78f39b6ca6a382641820bea9">M_PARSER_INTEGER_TYPE</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_int64 *&#160;</td>
          <td class="paramname"><em>integer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a signed integer from the current buffer and advance.</p>
<p>For ASCII formatted integers:</p><ul>
<li>if len is not specified, it will read up until the first non-numeric character is encountered. At least one numeric must be encountered or it is considered an error.</li>
<li>if len is specified, the integer must be exactly that length (no shorter) or it is considered an error.</li>
<li>if base is specified as 0, will attempt to auto-detect the base.</li>
</ul>
<p>For BigEndian or Little Endian formatted integers:</p><ul>
<li>The len is mandatory, and base is ignored. Maximum len is 8.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>How integer is represented in the data stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of integer, or 0 to auto-determine for ASCII. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>Base represented in ASCII, or 0 to auto-determine (or non-ascii). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">integer</td><td>Integer storage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_FALSE on failure, M_TRUE on success. </dd></dl>

</div>
</div>
<a id="ga7ad9c749c8cddc5fca4b7b9cbcefdd01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ad9c749c8cddc5fca4b7b9cbcefdd01">&#9670;&nbsp;</a></span>M_parser_read_uint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_read_uint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__m__parser.html#gaf9512fcb78f39b6ca6a382641820bea9">M_PARSER_INTEGER_TYPE</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint64 *&#160;</td>
          <td class="paramname"><em>integer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read an unsigned integer from the current buffer and advance.</p>
<p>See <a class="el" href="group__m__parser.html#gae9636268867f8c53568b78e9b11b9f19">M_parser_read_int()</a> for details on usage as requirements are the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>How integer is represented in the data stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of integer, or 0 to auto-determine for ASCII. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>Base represented in ASCII, or 0 to auto-determine (or non-ascii). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">integer</td><td>Integer storage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_FALSE on failure, M_TRUE on success.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__parser.html#gae9636268867f8c53568b78e9b11b9f19">M_parser_read_int</a> </dd></dl>

</div>
</div>
<a id="ga5fbaa2939f187d897d21d9182f5b9b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fbaa2939f187d897d21d9182f5b9b23">&#9670;&nbsp;</a></span>M_parser_read_uint_bcd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_read_uint_bcd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint64 *&#160;</td>
          <td class="paramname"><em>integer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and unsigned Binary Coded Decimal integer from the current buffer and advance</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of integer in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">integer</td><td>Integer storage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_FALSE on failure, M_TRUE on success. </dd></dl>

</div>
</div>
<a id="gae0a9d5263972f4d6169f829cac1684ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0a9d5263972f4d6169f829cac1684ab">&#9670;&nbsp;</a></span>M_parser_read_decimal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__m__decimal.html#ga7c1d6ded689031ea022be05e0a3bcbd8">M_DECIMAL_RETVAL</a> M_parser_read_decimal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>truncate_fail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__decimal.html#structM__decimal__t">M_decimal_t</a> *&#160;</td>
          <td class="paramname"><em>decimal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a decimal number from current buffer and advance.</p>
<p>The number must be represented in base 10 and in ASCII form.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of decimal, or 0 to auto-determine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">truncate_fail</td><td>M_TRUE to treat a truncation as a failure and not increment the consumer. M_FALSE otherwise. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">decimal</td><td>Decimal storage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enum M_DECIMAL_RETVAL values. </dd></dl>

</div>
</div>
<a id="gaba7a40c4c5eb8e069f02d4692183560b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba7a40c4c5eb8e069f02d4692183560b">&#9670;&nbsp;</a></span>M_parser_read_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_read_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a single byte from the current buffer and advance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">byte</td><td>Outputs byte read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE on failure. </dd></dl>

</div>
</div>
<a id="ga33cfa027ef5dc9282fff60396e0477e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33cfa027ef5dc9282fff60396e0477e3">&#9670;&nbsp;</a></span>M_parser_read_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_read_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the exact number of bytes (binary) from the current buffer and output in the user-provided buffer and advance. If there are fewer than the requested bytes available, an error will be returned.</p>
<p>The data read will not be NULL terminated and the buffer provided must be at least as large as large as the requested data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of data to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to hold output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE if not enough bytes or other error. </dd></dl>

</div>
</div>
<a id="gadefa7b7229a1ad2e69508e531c8d6f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadefa7b7229a1ad2e69508e531c8d6f0b">&#9670;&nbsp;</a></span>M_parser_read_bytes_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_bytes_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read bytes (binary) from the current buffer and output in the user-provided buffer and advance.</p>
<p>The data read will not be NULL terminated and the buffer provided must be at least as large as large as the requested data. If the length of data specified is not available, it will return the number of bytes actually read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Requested length of data to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to hold output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>Length of buffer to hold output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read, or 0 on error or no bytes available. </dd></dl>

</div>
</div>
<a id="gafcd493e23587c2b4f441737b7d5c371b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcd493e23587c2b4f441737b7d5c371b">&#9670;&nbsp;</a></span>M_parser_read_bytes_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_bytes_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pat_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>eat_pat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read bytes (binary) until the specified sequence of bytes is encountered in the data stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to hold output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>Length of buffer to hold output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pat</td><td>Sequence of bytes to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pat_len</td><td>Length of pattern data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eat_pat</td><td>Should the sequence of bytes be consumed. Useful for ignoring data until end of comment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read, or 0 on error or no bytes available. </dd></dl>

</div>
</div>
<a id="ga653e75ca090e6a8c7e3dda5fb6604fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga653e75ca090e6a8c7e3dda5fb6604fd3">&#9670;&nbsp;</a></span>M_parser_read_bytes_charset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_bytes_charset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>charset_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read bytes (binary) from the current buffer as long as the bytes match the provided character set, output in the user-provided buffer and advance.</p>
<p>The data read will not be NULL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Array of characters that are allowed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset_len</td><td>Length of character set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to store result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>Size of result buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of data read, or 0 on error. </dd></dl>

</div>
</div>
<a id="gaeed5c08551e302f39eec049c988b4082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeed5c08551e302f39eec049c988b4082">&#9670;&nbsp;</a></span>M_parser_read_bytes_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_bytes_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read bytes (binary) from the current buffer as long as the bytes match the provided predicate, output in the user-provided buffer and advance.</p>
<p>The data read will not be NULL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Predicate function. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to store result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>Size of result buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of data read, or 0 on error. </dd></dl>

</div>
</div>
<a id="ga00c393187e7984c21c1a5f2a8c2e5219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00c393187e7984c21c1a5f2a8c2e5219">&#9670;&nbsp;</a></span>M_parser_read_bytes_chr_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_bytes_chr_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__chr.html#ga24152bf5695c3990606a71947526af7e">M_chr_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read bytes (binary) from the current buffer as long as the bytes match the provided chr predicate, output in the user-provided buffer and advance.</p>
<p>The data read will not be NULL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Predicate function. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to store result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>Size of result buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of data read, or 0 on error. </dd></dl>

</div>
</div>
<a id="gabb4c73209e80d9e2a0345c72b08ac34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb4c73209e80d9e2a0345c72b08ac34d">&#9670;&nbsp;</a></span>M_parser_read_bytes_mark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_bytes_mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from a marked position until the current parser position.</p>
<p>The marked position will be automatically cleared. Provided buffer must be at least <a class="el" href="group__m__parser.html#ga4b0cd4b491f39713f04bd48fd2703766">M_parser_mark_len()</a> bytes long.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to store result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>Size of result buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to buffer or 0 on error. </dd></dl>

</div>
</div>
<a id="ga95c6f1b66486d43585e8a2b9dedb49ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95c6f1b66486d43585e8a2b9dedb49ca">&#9670;&nbsp;</a></span>M_parser_read_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_read_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a string from the current buffer of the exact given length, output in the user-provided buffer and advance. If there are insufficient bytes a failure will be returned.</p>
<p>The length of the requested string must be at least one byte shorter than the buffer size to account for the null termination. If you do not already have a buffer, use <a class="el" href="group__m__parser.html#ga0c17e75e8d82879f94dc47209a293ca7">M_parser_read_strdup()</a> which will return a newly allocated buffer for you.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of string to read (must be at least one byte shorter than buf_len). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Output pointer to store result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>Length of output buffer (must be at least one byte greater than len).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, or M_FALSE if not enough bytes or other error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__parser.html#ga0c17e75e8d82879f94dc47209a293ca7">M_parser_read_strdup</a> </dd></dl>

</div>
</div>
<a id="gaf65f2c7e819c22d9513311be47a80926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf65f2c7e819c22d9513311be47a80926">&#9670;&nbsp;</a></span>M_parser_read_str_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_str_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a string from the current buffer, output in the user-provided buffer and advance.</p>
<p>The length of the requested string must be at least one byte shorter than the buffer size to account for the null termination. If you do not already have a buffer, use <a class="el" href="group__m__parser.html#ga0c17e75e8d82879f94dc47209a293ca7">M_parser_read_strdup()</a> which will return a newly allocated buffer for you.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Requested length of string to read (must be at least one byte shorter than buf_len). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Output pointer to store result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>Length of output buffer (must be at least one byte greater than len).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read, or 0 on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__parser.html#ga95c6f1b66486d43585e8a2b9dedb49ca">M_parser_read_str</a> </dd></dl>

</div>
</div>
<a id="ga6b97d270eb217b89c403c5e80e0fc381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b97d270eb217b89c403c5e80e0fc381">&#9670;&nbsp;</a></span>M_parser_read_str_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_str_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>eat_pat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data until the specified sequence of bytes is encountered in the data stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to hold output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>Length of buffer to hold output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pat</td><td>String to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eat_pat</td><td>Should the sequence of bytes be consumed. Useful for ignoring data until end of comment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read, or 0 on error or no bytes available. </dd></dl>

</div>
</div>
<a id="gaaf98ba19b8cdaddc55c486b49c123953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf98ba19b8cdaddc55c486b49c123953">&#9670;&nbsp;</a></span>M_parser_read_str_charset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_str_charset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from the buffer for as long as it matches one of the bytes in the given character set and advance.</p>
<p>Put the resulting bytes in the provided buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Array of characters that are allowed, NULL terminated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to store result. Will be NULL terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>Size of result buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of data read, or 0 on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__parser.html#gaadc81b291d5b29f2c237dafe8d771512">M_parser_read_strdup_charset</a> </dd></dl>

</div>
</div>
<a id="gab7f2a3af4348fd0ad0b16f48bdf35ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7f2a3af4348fd0ad0b16f48bdf35ae8">&#9670;&nbsp;</a></span>M_parser_read_str_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_str_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from the buffer for as long as it matches the given predicate function and advance.</p>
<p>Put the resulting bytes in the provided buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>predicate function. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to store result. Will be NULL terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>Size of result buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of data read, or 0 on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__parser.html#gadb1485431bd0d0b299fd6d5986a1b3bb">M_parser_read_strdup_predicate</a> </dd></dl>

</div>
</div>
<a id="ga8bf2ae228f89c06b4ddf311f34c2153c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bf2ae228f89c06b4ddf311f34c2153c">&#9670;&nbsp;</a></span>M_parser_read_str_chr_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_str_chr_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__chr.html#ga24152bf5695c3990606a71947526af7e">M_chr_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from the buffer for as long as it matches the given chr predicate function and advance.</p>
<p>Put the resulting bytes in the provided buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>predicate function. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to store result. Will be NULL terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>Size of result buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of data read, or 0 on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__parser.html#gadb1485431bd0d0b299fd6d5986a1b3bb">M_parser_read_strdup_predicate</a> </dd></dl>

</div>
</div>
<a id="gaf274d0a0cb831e8fd41fc66d166fad48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf274d0a0cb831e8fd41fc66d166fad48">&#9670;&nbsp;</a></span>M_parser_read_str_mark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_str_mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from a marked position until the current parser position.</p>
<p>The marked position will be automatically cleared. Provided buffer must be at least <a class="el" href="group__m__parser.html#ga4b0cd4b491f39713f04bd48fd2703766">M_parser_mark_len()</a> bytes plus the NULL terminator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to store result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_len</td><td>Size of result buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written to buffer or 0 on error. </dd></dl>

</div>
</div>
<a id="ga0c17e75e8d82879f94dc47209a293ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c17e75e8d82879f94dc47209a293ca7">&#9670;&nbsp;</a></span>M_parser_read_strdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* M_parser_read_strdup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a string for the given length from the current buffer, allocates an output buffer and advance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of string to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Buffer containing the string on success, or NULL on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__parser.html#ga95c6f1b66486d43585e8a2b9dedb49ca">M_parser_read_str</a> </dd></dl>

</div>
</div>
<a id="gaab8428cf93d6cdf48705518084bf9555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab8428cf93d6cdf48705518084bf9555">&#9670;&nbsp;</a></span>M_parser_read_strdup_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* M_parser_read_strdup_hex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read bytes (binary) from the parser, return as hex-encoded string and advance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object to read binary bytes from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of binary bytes to read from parser.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null-terminated hex string on success, NULL if not enough bytes or other error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__parser.html#ga99ff2b65e5f78f3d32883cbd4fc28be9">M_parser_read_buf_hex</a> </dd></dl>

</div>
</div>
<a id="ga73e0d3b9c2ada037c58264100a862183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73e0d3b9c2ada037c58264100a862183">&#9670;&nbsp;</a></span>M_parser_read_strdup_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* M_parser_read_strdup_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>eat_pat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data until the specified sequence of bytes is encountered in the data stream.</p>
<p>Put the resulting bytes in a newly allocated buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pat</td><td>Sequence of bytes to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eat_pat</td><td>Should the sequence of bytes be consumed. Useful for ignoring data until end of comment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read, or 0 on error or no bytes available. </dd></dl>

</div>
</div>
<a id="gaadc81b291d5b29f2c237dafe8d771512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadc81b291d5b29f2c237dafe8d771512">&#9670;&nbsp;</a></span>M_parser_read_strdup_charset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* M_parser_read_strdup_charset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from the buffer for as long as it matches one of the bytes in the given character set and advance.</p>
<p>Put the resulting bytes in a newly allocated buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Array of characters that are allowed, NULL terminated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL-terminated result buffer, or NULL on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__parser.html#gaaf98ba19b8cdaddc55c486b49c123953">M_parser_read_str_charset</a> </dd></dl>

</div>
</div>
<a id="gadb1485431bd0d0b299fd6d5986a1b3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb1485431bd0d0b299fd6d5986a1b3bb">&#9670;&nbsp;</a></span>M_parser_read_strdup_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* M_parser_read_strdup_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from the buffer for as long as it matches the given predicate function and advance.</p>
<p>Put the resulting bytes in a newly allocated buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Predicate function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL-terminated result buffer, or NULL on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__parser.html#gab7f2a3af4348fd0ad0b16f48bdf35ae8">M_parser_read_str_predicate</a> </dd></dl>

</div>
</div>
<a id="ga6b154a08db31ce892470aebdc61d0236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b154a08db31ce892470aebdc61d0236">&#9670;&nbsp;</a></span>M_parser_read_strdup_chr_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* M_parser_read_strdup_chr_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__chr.html#ga24152bf5695c3990606a71947526af7e">M_chr_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from the buffer for as long as it matches the given predicate function and advance.</p>
<p>Put the resulting bytes in a newly allocated buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>predicate function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL-terminated result buffer, or NULL on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__parser.html#gab7f2a3af4348fd0ad0b16f48bdf35ae8">M_parser_read_str_predicate</a> </dd></dl>

</div>
</div>
<a id="ga0d79542fe6a498f071bbcc8fcb081949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d79542fe6a498f071bbcc8fcb081949">&#9670;&nbsp;</a></span>M_parser_read_strdup_mark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* M_parser_read_strdup_mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from a marked position until the current parser position.</p>
<p>The marked position will be automatically cleared. An allocated buffer with the requested data will be returned, NULL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL-terminated result, or NULL on error. </dd></dl>

</div>
</div>
<a id="ga33730a63386c3519b3a5730cd196ad7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33730a63386c3519b3a5730cd196ad7e">&#9670;&nbsp;</a></span>M_parser_read_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_read_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the exact number of bytes (binary) from the current buffer and output in the user-provided buffer and advance.</p>
<p>If there are fewer than the requested bytes available, an error will be returned.</p>
<p>The data read will not be NULL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to hold output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of data to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE if not enough bytes or other error. </dd></dl>

</div>
</div>
<a id="ga99ff2b65e5f78f3d32883cbd4fc28be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99ff2b65e5f78f3d32883cbd4fc28be9">&#9670;&nbsp;</a></span>M_parser_read_buf_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_read_buf_hex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read bytes (binary) from the parser, write as hex-encoded string into the provided buffer, and advance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object to read binary bytes from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to hold hex-ascii output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of binary bytes to read from parser.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE if not enough bytes or other error. </dd></dl>

</div>
</div>
<a id="gad6bb840e9a466ff0ccf3d439b40c0aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6bb840e9a466ff0ccf3d439b40c0aa0">&#9670;&nbsp;</a></span>M_parser_read_buf_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_buf_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read bytes (binary) from the current buffer and output in the user-provided buffer and advance.</p>
<p>The data read will not be NULL terminated. If the length of data specified is not available, it will return the number of bytes actually read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to hold output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Requested length of data to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read, or 0 on error or no bytes available. </dd></dl>

</div>
</div>
<a id="ga049ba42f48dd6ca9147d47df0284704d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga049ba42f48dd6ca9147d47df0284704d">&#9670;&nbsp;</a></span>M_parser_read_buf_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_buf_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pat_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>eat_pat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read bytes (binary) until the specified sequence of bytes is encountered in the data stream.</p>
<p>The data read will not be NULL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to hold output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pat</td><td>Sequence of bytes to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pat_len</td><td>Length of pattern data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eat_pat</td><td>Should the sequence of bytes be consumed. Useful for ignoring data until end of comment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read, or 0 on error or no bytes available. </dd></dl>

</div>
</div>
<a id="gafadd538e27da591c2960731607fae06d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafadd538e27da591c2960731607fae06d">&#9670;&nbsp;</a></span>M_parser_read_buf_charset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_buf_charset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>charset_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read bytes (binary) from the current buffer as long as the bytes match the provided character set, output in the user-provided buffer and advance.</p>
<p>The data read will not be NULL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to store result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Array of characters that are allowed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset_len</td><td>Length of character set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of data read, or 0 on error. </dd></dl>

</div>
</div>
<a id="ga55820b0eb422fe9c6715e6fe3a7c2cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55820b0eb422fe9c6715e6fe3a7c2cd1">&#9670;&nbsp;</a></span>M_parser_read_buf_not_charset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_buf_not_charset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>charset_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read bytes (binary) from the current buffer as long as the bytes do not match the provided character set, output in the user-provided buffer and advance.</p>
<p>The data read will not be NULL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to store result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Array of characters that are allowed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset_len</td><td>Length of character set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of data read, or 0 on error. </dd></dl>

</div>
</div>
<a id="gaba5b5ccc50da131855aaf9c335a779c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba5b5ccc50da131855aaf9c335a779c7">&#9670;&nbsp;</a></span>M_parser_read_buf_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_buf_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read bytes (binary) from the current buffer as long as the bytes match the provided predicate, output in the user-provided buffer and advance.</p>
<p>The data read will not be NULL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to store result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Predicate function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of data read, or 0 on error. </dd></dl>

</div>
</div>
<a id="ga168a369d88b72993cc87c4ce865915a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga168a369d88b72993cc87c4ce865915a5">&#9670;&nbsp;</a></span>M_parser_read_buf_chr_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_buf_chr_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__chr.html#ga24152bf5695c3990606a71947526af7e">M_chr_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read bytes (binary) from the current buffer as long as the bytes match the provided chr predicate, output in the user-provided buffer and advance.</p>
<p>The data read will not be NULL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to store result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Predicate function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of data read, or 0 on error. </dd></dl>

</div>
</div>
<a id="gab0b588e85abde4af0a5e65fe2491f6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0b588e85abde4af0a5e65fe2491f6f5">&#9670;&nbsp;</a></span>M_parser_read_buf_mark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_parser_read_buf_mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from a marked position until the current parser position.</p>
<p>The marked position will be automatically cleared.</p>
<p>The data read will not be NULL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to store result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to buffer or 0 on error. </dd></dl>

</div>
</div>
<a id="gac8453d3f5345a1a5e36e5b0b023778dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8453d3f5345a1a5e36e5b0b023778dc">&#9670;&nbsp;</a></span>M_parser_read_parser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a>* M_parser_read_parser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create new parser from the current position for the given length from the current buffer, allocates a parser and advance. All data is copied into a new memory segment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parser. </dd></dl>

</div>
</div>
<a id="ga91f0b519b752eccdc0a952e61953fff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91f0b519b752eccdc0a952e61953fff8">&#9670;&nbsp;</a></span>M_parser_read_parser_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a>* M_parser_read_parser_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>eat_pat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from the buffer until the specified sequence of bytes is encountered in the data stream. All data is copied into a new memory segment.</p>
<p>Put the resulting bytes in a newly allocated parser.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pat</td><td>Sequence of bytes to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of pattern data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eat_pat</td><td>Should the sequence of bytes be consumed. Useful for ignoring data until end of comment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parser. </dd></dl>

</div>
</div>
<a id="ga123cb0b91d056546ab9737933490176e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga123cb0b91d056546ab9737933490176e">&#9670;&nbsp;</a></span>M_parser_read_parser_charset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a>* M_parser_read_parser_charset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned const char *&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>charset_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from the buffer for as long as it matches one of the bytes in the given character set and advance. All data is copied into a new memory segment.</p>
<p>Put the resulting bytes in a newly allocated parser.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Array of characters that are allowed, NULL terminated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset_len</td><td>Number of characters in the set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parser. </dd></dl>

</div>
</div>
<a id="gaac11a976b2931694a40304279200d2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac11a976b2931694a40304279200d2cc">&#9670;&nbsp;</a></span>M_parser_read_parser_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a>* M_parser_read_parser_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create new parser from the buffer for as long as it matches the given predicate function and advance. All data is copied into a new memory segment.</p>
<p>Put the resulting bytes in a newly allocated parser.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Predicate function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parser. </dd></dl>

</div>
</div>
<a id="gae16690c90e83c136a2252df4ce5a7b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae16690c90e83c136a2252df4ce5a7b69">&#9670;&nbsp;</a></span>M_parser_read_parser_chr_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a>* M_parser_read_parser_chr_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create new parser from the buffer for as long as it matches the given predicate function and advance. All data is copied into a new memory segment.</p>
<p>Put the resulting bytes in a newly allocated parser.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Predicate function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parser. </dd></dl>

</div>
</div>
<a id="ga53670fe8b46c97cca6fb2b91165a9b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53670fe8b46c97cca6fb2b91165a9b1d">&#9670;&nbsp;</a></span>M_parser_read_parser_mark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a>* M_parser_read_parser_mark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create new parser from a marked position until the current parser position, allocates a parser and advance. All data is copied into a new memory segment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parser. </dd></dl>

</div>
</div>
<a id="ga92fee6f3045a04e33a5c075f09e72ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92fee6f3045a04e33a5c075f09e72ba3">&#9670;&nbsp;</a></span>M_parser_read_stxetxlrc_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__parser.html#ga6993008e1f0881f84431d5813f33d127">M_PARSER_FRAME_ERROR</a> M_parser_read_stxetxlrc_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint32&#160;</td>
          <td class="paramname"><em>lrc_frame_chars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read an STX, ETX, LRC wrapped message.</p>
<p>The first character in the parser must be an STX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Parser object with result message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lrc_frame_chars</td><td>Framing characters that should be included in LRC calculation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result. On success and LRC calculation failure the message will be returned in the output parser. Otherwise the output parser's contents are undefined.</dd></dl>
<p>Results M_PARSER_FRAME_ERROR_NO_STX, M_PARSER_FRAME_ERROR_NO_ETX, and M_PARSER_FRAME_ERROR_NO_LRC will not advance the parser. </p>

</div>
</div>
<a id="gaadf16d5f9fafe29fecb3648f652909bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadf16d5f9fafe29fecb3648f652909bc">&#9670;&nbsp;</a></span>M_parser_is_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_is_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validate the parser matches the given predicate function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length to validate. If larger than the parser length the parser length is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Predicate function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if matching. Otherwise M_FALSE; </dd></dl>

</div>
</div>
<a id="gaa88442d7f03374ae9a1e331a6a438dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa88442d7f03374ae9a1e331a6a438dcd">&#9670;&nbsp;</a></span>M_parser_is_chr_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_is_chr_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__chr.html#ga24152bf5695c3990606a71947526af7e">M_chr_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validate the parser matches the given chr predicate function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length to validate. If larger than the parser length the parser length is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Char predicate function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if matching. Otherwise M_FALSE; </dd></dl>

</div>
</div>
<a id="gaee24382838045df85d9a2c5fabad273e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee24382838045df85d9a2c5fabad273e">&#9670;&nbsp;</a></span>M_parser_is_charset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_is_charset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>charset_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validate the parser matches the given character set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length to validate. If larger than the parser length the parser length is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Character set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset_len</td><td>Length of given character set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if matching. Otherwise M_FALSE; </dd></dl>

</div>
</div>
<a id="gaefa200381fcfe8b6d90722b445ddfce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefa200381fcfe8b6d90722b445ddfce8">&#9670;&nbsp;</a></span>M_parser_is_str_charset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_is_str_charset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validate the parser matches the given NULL-terminated charset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length to validate. If larger than the parser length the parser length is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Character set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if matching. Otherwise M_FALSE; </dd></dl>

</div>
</div>
<a id="ga6793576c9c5c8aca9f376f7e9a7a28a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6793576c9c5c8aca9f376f7e9a7a28a1">&#9670;&nbsp;</a></span>M_parser_is_not_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_is_not_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#gaf02bf52755e0b9fc5d18dccd81ba55d0">M_parser_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validate the parser does not match the given predicate function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length to validate. If larger than the parser length the parser length is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Predicate function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if not matching. Otherwise M_FALSE; </dd></dl>

</div>
</div>
<a id="ga4c4ff475ade6a092401a72479a1d7238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c4ff475ade6a092401a72479a1d7238">&#9670;&nbsp;</a></span>M_parser_is_not_chr_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_is_not_chr_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__chr.html#ga24152bf5695c3990606a71947526af7e">M_chr_predicate_func</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validate the parser does not match the given chr predicate function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length to validate. If larger than the parser length the parser length is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Char predicate function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if not matching. Otherwise M_FALSE; </dd></dl>

</div>
</div>
<a id="gabc8435d6e2e41ec21c14e6965adeb580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc8435d6e2e41ec21c14e6965adeb580">&#9670;&nbsp;</a></span>M_parser_is_not_charset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_is_not_charset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>charset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>charset_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validate the parser does not match the given character set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length to validate. If larger than the parser length the parser length is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Character set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset_len</td><td>Length of given character set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if not matching. Otherwise M_FALSE; </dd></dl>

</div>
</div>
<a id="gab16f381ae01e5a47d36cb3b36c7ab3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab16f381ae01e5a47d36cb3b36c7ab3cc">&#9670;&nbsp;</a></span>M_parser_is_not_str_charset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_parser_is_not_str_charset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validate the parser does not match the given NULL-terminated charset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parser</td><td>Parser object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length to validate. If larger than the parser length the parser length is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">charset</td><td>Character set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if not matching. Otherwise M_FALSE; </dd></dl>

</div>
</div>
<a id="gaff3a3e053b6e66cdc20919360867ac57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff3a3e053b6e66cdc20919360867ac57">&#9670;&nbsp;</a></span>M_parser_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a>** M_parser_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint32&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>num_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split the data in the parser object by the delimiter specified into additional parser objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parser</td><td>Parser </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delim</td><td>The delimiter to split on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxcnt</td><td>Maximum number of objects to create, remaining data will be part of the last object. 0 if no maximum. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>M_PARSER_SPLIT_FLAGS flags controlling behavior of parser </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">num_output</td><td>The number of parser objects output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of parser objects or NULL on failure </dd></dl>

</div>
</div>
<a id="ga2f40799b9f60ee628d4b9aaa2523109e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f40799b9f60ee628d4b9aaa2523109e">&#9670;&nbsp;</a></span>M_parser_split_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_parser_split_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> **&#160;</td>
          <td class="paramname"><em>parsers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free child parser objects returned from M_parser_split </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parsers</td><td>Array of parser objects </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>Count of objects as returned from M_parser_split </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Feb 20 2018 12:46:12 for Mstdlib-1.0.0 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
