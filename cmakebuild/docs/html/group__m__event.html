<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mstdlib-1.0.0: Event Subsystem</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mstdlib-1.0.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__m__event.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Event Subsystem<div class="ingroups"><a class="el" href="group__m__eventio.html">Event Based I/O Subsystem</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga66b039653a61c8702310d03e6ba69802"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group__m__event.html#ga5d54358d8088f050bcdb141c6c0b21e7">M_event_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga66b039653a61c8702310d03e6ba69802">M_event_type_t</a></td></tr>
<tr class="separator:ga66b039653a61c8702310d03e6ba69802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5af8e493dd11c5603689843f9b6ed2bc"><td class="memItemLeft" align="right" valign="top">typedef struct M_event_trigger&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga5af8e493dd11c5603689843f9b6ed2bc">M_event_trigger_t</a></td></tr>
<tr class="separator:ga5af8e493dd11c5603689843f9b6ed2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7cc7058deaf2fd06e4a4733d16c9b52"><td class="memItemLeft" align="right" valign="top">typedef struct M_event_timer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a></td></tr>
<tr class="separator:gaf7cc7058deaf2fd06e4a4733d16c9b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga747f0301bfcc6db3b51eaf07e2582350"><td class="memItemLeft" align="right" valign="top">typedef struct M_event&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a></td></tr>
<tr class="separator:ga747f0301bfcc6db3b51eaf07e2582350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga454e48a58bf322de6666c6d9e65c3b51"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga454e48a58bf322de6666c6d9e65c3b51">M_event_callback_t</a>) (<a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *event, <a class="el" href="group__m__event.html#ga66b039653a61c8702310d03e6ba69802">M_event_type_t</a> type, <a class="el" href="group__m__io.html#ga845c131d8520206a2a7a9219d1bd1932">M_io_t</a> *io, void *cb_arg)</td></tr>
<tr class="separator:ga454e48a58bf322de6666c6d9e65c3b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d789310a18f48034c1eb6c42193fbd"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group__m__event.html#ga4466239df0e524aa31e71acb924e54d5">M_event_timer_modes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga09d789310a18f48034c1eb6c42193fbd">M_event_timer_mode_t</a></td></tr>
<tr class="separator:ga09d789310a18f48034c1eb6c42193fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5323b0595d8268420f03023a3bbc55a"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group__m__event.html#gae0d1f0926d83227c5e7dddfbedf7e8ef">M_event_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#gaf5323b0595d8268420f03023a3bbc55a">M_event_status_t</a></td></tr>
<tr class="separator:gaf5323b0595d8268420f03023a3bbc55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d43d0bb0301ed7809ffddbfe6ca8b2"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group__m__event.html#ga3d93964ec33daa93f69ee7205f341e9f">M_event_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga06d43d0bb0301ed7809ffddbfe6ca8b2">M_event_err_t</a></td></tr>
<tr class="separator:ga06d43d0bb0301ed7809ffddbfe6ca8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5d54358d8088f050bcdb141c6c0b21e7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga5d54358d8088f050bcdb141c6c0b21e7">M_event_type</a> { <br />
&#160;&#160;<a class="el" href="group__m__event.html#gga5d54358d8088f050bcdb141c6c0b21e7ab0fc60e031020cb3f36b70c4932d67f2">M_EVENT_TYPE_CONNECTED</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__m__event.html#gga5d54358d8088f050bcdb141c6c0b21e7a571c000a93b3c198364a32e5e145f2d0">M_EVENT_TYPE_ACCEPT</a>, 
<br />
&#160;&#160;<a class="el" href="group__m__event.html#gga5d54358d8088f050bcdb141c6c0b21e7a8d2cf32ca08773c695e988635ebfd426">M_EVENT_TYPE_READ</a>, 
<br />
&#160;&#160;<a class="el" href="group__m__event.html#gga5d54358d8088f050bcdb141c6c0b21e7a6cead05362ca89b2cc7353bf6b4c2c6e">M_EVENT_TYPE_DISCONNECTED</a>, 
<br />
&#160;&#160;<a class="el" href="group__m__event.html#gga5d54358d8088f050bcdb141c6c0b21e7adce269f93799cdca69ac20235895d0ac">M_EVENT_TYPE_ERROR</a>, 
<br />
&#160;&#160;<a class="el" href="group__m__event.html#gga5d54358d8088f050bcdb141c6c0b21e7a1713e94c1e0750f168d255f580fd4ad9">M_EVENT_TYPE_WRITE</a>, 
<br />
&#160;&#160;<a class="el" href="group__m__event.html#gga5d54358d8088f050bcdb141c6c0b21e7a89a67d4e5f2bdcadc1ffa3ba0473a6cf">M_EVENT_TYPE_OTHER</a>
<br />
 }</td></tr>
<tr class="separator:ga5d54358d8088f050bcdb141c6c0b21e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72bc04891ff7b6142b7672a207ae74b1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga72bc04891ff7b6142b7672a207ae74b1">M_EVENT_FLAGS</a> { <br />
&#160;&#160;<a class="el" href="group__m__event.html#gga72bc04891ff7b6142b7672a207ae74b1ac7efcb61cf28fa27d4a0a3daf68aaecf">M_EVENT_FLAG_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__m__event.html#gga72bc04891ff7b6142b7672a207ae74b1a66ea43f6ded6e7175f1bebc4eb5528a1">M_EVENT_FLAG_NOWAKE</a> = 1 &lt;&lt; 0, 
<br />
&#160;&#160;<a class="el" href="group__m__event.html#gga72bc04891ff7b6142b7672a207ae74b1a528ef8c95e55e761a36e28f7af58818d">M_EVENT_FLAG_EXITONEMPTY</a> = 1 &lt;&lt; 1, 
<br />
&#160;&#160;<a class="el" href="group__m__event.html#gga72bc04891ff7b6142b7672a207ae74b1aec67bef19d068700f0372808c69a5490">M_EVENT_FLAG_EXITONEMPTY_NOTIMERS</a> = 1 &lt;&lt; 2
<br />
 }</td></tr>
<tr class="separator:ga72bc04891ff7b6142b7672a207ae74b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4466239df0e524aa31e71acb924e54d5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga4466239df0e524aa31e71acb924e54d5">M_event_timer_modes</a> { <br />
&#160;&#160;<a class="el" href="group__m__event.html#gga4466239df0e524aa31e71acb924e54d5a46cf8f8103ddaa1a7976f6fef6683a29">M_EVENT_TIMER_MODE_RELATIVE</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group__m__event.html#gga4466239df0e524aa31e71acb924e54d5a2cf9eb5d4bc66b0c162e045e325800c9">M_EVENT_TIMER_MODE_MONOTONIC</a> = 2
<br />
 }</td></tr>
<tr class="separator:ga4466239df0e524aa31e71acb924e54d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0d1f0926d83227c5e7dddfbedf7e8ef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#gae0d1f0926d83227c5e7dddfbedf7e8ef">M_event_status</a> { <br />
&#160;&#160;<a class="el" href="group__m__event.html#ggae0d1f0926d83227c5e7dddfbedf7e8efa6cd3686551b311cf43bf0a47a3bb85eb">M_EVENT_STATUS_RUNNING</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__m__event.html#ggae0d1f0926d83227c5e7dddfbedf7e8efa564ace6880d50d94423384f8c22322ce">M_EVENT_STATUS_PAUSED</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group__m__event.html#ggae0d1f0926d83227c5e7dddfbedf7e8efa24c8749f6b408df5bd4470b593c9bd1c">M_EVENT_STATUS_RETURN</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__m__event.html#ggae0d1f0926d83227c5e7dddfbedf7e8efa5d3560019b6aa99d030fe0c79bd08987">M_EVENT_STATUS_DONE</a> = 3
<br />
 }</td></tr>
<tr class="separator:gae0d1f0926d83227c5e7dddfbedf7e8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d93964ec33daa93f69ee7205f341e9f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga3d93964ec33daa93f69ee7205f341e9f">M_event_err</a> { <br />
&#160;&#160;<a class="el" href="group__m__event.html#gga3d93964ec33daa93f69ee7205f341e9faf606120c776d8a403a717c1823f0238d">M_EVENT_ERR_DONE</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group__m__event.html#gga3d93964ec33daa93f69ee7205f341e9fa14835b933f79dfbd3a995b525be8b958">M_EVENT_ERR_TIMEOUT</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__m__event.html#gga3d93964ec33daa93f69ee7205f341e9fa1c4d39058b1dd163a7cece59b8ddfe5c">M_EVENT_ERR_RETURN</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__m__event.html#gga3d93964ec33daa93f69ee7205f341e9fa9a6a30e82fb587d63245bc318d68af70">M_EVENT_ERR_MISUSE</a> = 4
<br />
 }</td></tr>
<tr class="separator:ga3d93964ec33daa93f69ee7205f341e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae169dca80125767d87fe196f32ea8d74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#gae169dca80125767d87fe196f32ea8d74">M_event_create</a> (M_uint32 flags)</td></tr>
<tr class="separator:gae169dca80125767d87fe196f32ea8d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6be59e7ccf75016c997b4919c9a709da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga6be59e7ccf75016c997b4919c9a709da">M_event_pool_create</a> (size_t max_threads)</td></tr>
<tr class="separator:ga6be59e7ccf75016c997b4919c9a709da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9187e4d2237e25973975e200b4d52ff7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga9187e4d2237e25973975e200b4d52ff7">M_event_get_pool</a> (<a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *event)</td></tr>
<tr class="separator:ga9187e4d2237e25973975e200b4d52ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga603f06976101b21e00517deb529f86bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga603f06976101b21e00517deb529f86bb">M_event_destroy</a> (<a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *event)</td></tr>
<tr class="separator:ga603f06976101b21e00517deb529f86bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga755cf00991529e324be3f9f49a5d5476"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga755cf00991529e324be3f9f49a5d5476">M_event_add</a> (<a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *event, <a class="el" href="group__m__io.html#ga845c131d8520206a2a7a9219d1bd1932">M_io_t</a> *io, <a class="el" href="group__m__event.html#ga454e48a58bf322de6666c6d9e65c3b51">M_event_callback_t</a> callback, void *cb_data)</td></tr>
<tr class="separator:ga755cf00991529e324be3f9f49a5d5476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf02fc9c3f66ffe794be24e0957507e7"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#gabf02fc9c3f66ffe794be24e0957507e7">M_event_edit_io_cb</a> (<a class="el" href="group__m__io.html#ga845c131d8520206a2a7a9219d1bd1932">M_io_t</a> *io, <a class="el" href="group__m__event.html#ga454e48a58bf322de6666c6d9e65c3b51">M_event_callback_t</a> callback, void *cb_data)</td></tr>
<tr class="separator:gabf02fc9c3f66ffe794be24e0957507e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c06f42d9f80ad3632538c077ed844d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga9c06f42d9f80ad3632538c077ed844d9">M_event_remove</a> (<a class="el" href="group__m__io.html#ga845c131d8520206a2a7a9219d1bd1932">M_io_t</a> *io)</td></tr>
<tr class="separator:ga9c06f42d9f80ad3632538c077ed844d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41874454cc5c17e8842de0153632bdef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__event.html#ga5af8e493dd11c5603689843f9b6ed2bc">M_event_trigger_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga41874454cc5c17e8842de0153632bdef">M_event_trigger_add</a> (<a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *event, <a class="el" href="group__m__event.html#ga454e48a58bf322de6666c6d9e65c3b51">M_event_callback_t</a> callback, void *cb_data)</td></tr>
<tr class="separator:ga41874454cc5c17e8842de0153632bdef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aa2de8f897a4ae1be1553f1128eafa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga5aa2de8f897a4ae1be1553f1128eafa7">M_event_trigger_remove</a> (<a class="el" href="group__m__event.html#ga5af8e493dd11c5603689843f9b6ed2bc">M_event_trigger_t</a> *trigger)</td></tr>
<tr class="separator:ga5aa2de8f897a4ae1be1553f1128eafa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcaab58b8fcd4253cd2bfe924563e13b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#gafcaab58b8fcd4253cd2bfe924563e13b">M_event_trigger_signal</a> (<a class="el" href="group__m__event.html#ga5af8e493dd11c5603689843f9b6ed2bc">M_event_trigger_t</a> *trigger)</td></tr>
<tr class="separator:gafcaab58b8fcd4253cd2bfe924563e13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fb88400e7101b24886e55e0e24d495b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga3fb88400e7101b24886e55e0e24d495b">M_event_timer_add</a> (<a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *event, <a class="el" href="group__m__event.html#ga454e48a58bf322de6666c6d9e65c3b51">M_event_callback_t</a> callback, void *cb_data)</td></tr>
<tr class="separator:ga3fb88400e7101b24886e55e0e24d495b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2809669810c4005a6750c4dfe21bf8a5"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga2809669810c4005a6750c4dfe21bf8a5">M_event_timer_start</a> (<a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *timer, M_uint64 interval_ms)</td></tr>
<tr class="separator:ga2809669810c4005a6750c4dfe21bf8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cc2ffa4f595f828e84a0a42eb3bbabb"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga7cc2ffa4f595f828e84a0a42eb3bbabb">M_event_timer_stop</a> (<a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *timer)</td></tr>
<tr class="separator:ga7cc2ffa4f595f828e84a0a42eb3bbabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb4b2120cb1d4e18fe872e41f67d505"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#gafdb4b2120cb1d4e18fe872e41f67d505">M_event_timer_reset</a> (<a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *timer, M_uint64 interval_ms)</td></tr>
<tr class="separator:gafdb4b2120cb1d4e18fe872e41f67d505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0bdd95d42641e30f805d2ef9a8b0708"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#gac0bdd95d42641e30f805d2ef9a8b0708">M_event_timer_set_starttv</a> (<a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *timer, <a class="el" href="group__m__time.html#structM__timeval__t">M_timeval_t</a> *start_tv)</td></tr>
<tr class="separator:gac0bdd95d42641e30f805d2ef9a8b0708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa2ce45f12e462c6047fe490e022f61"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#gaafa2ce45f12e462c6047fe490e022f61">M_event_timer_set_endtv</a> (<a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *timer, <a class="el" href="group__m__time.html#structM__timeval__t">M_timeval_t</a> *end_tv)</td></tr>
<tr class="separator:gaafa2ce45f12e462c6047fe490e022f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b30cfa49281b4f1a8852581d7a88e22"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga9b30cfa49281b4f1a8852581d7a88e22">M_event_timer_set_firecount</a> (<a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *timer, size_t cnt)</td></tr>
<tr class="separator:ga9b30cfa49281b4f1a8852581d7a88e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16adfacf818564d4b8e242b3caeb345c"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga16adfacf818564d4b8e242b3caeb345c">M_event_timer_set_autoremove</a> (<a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *timer, M_bool enabled)</td></tr>
<tr class="separator:ga16adfacf818564d4b8e242b3caeb345c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7461b01a5cd6e6471e8c96df6dbb96a"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#gaa7461b01a5cd6e6471e8c96df6dbb96a">M_event_timer_set_mode</a> (<a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *timer, <a class="el" href="group__m__event.html#ga09d789310a18f48034c1eb6c42193fbd">M_event_timer_mode_t</a> mode)</td></tr>
<tr class="separator:gaa7461b01a5cd6e6471e8c96df6dbb96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga804fd582353c5c71a984141921a9bd6b"><td class="memItemLeft" align="right" valign="top">M_uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga804fd582353c5c71a984141921a9bd6b">M_event_timer_get_remaining_ms</a> (<a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *timer)</td></tr>
<tr class="separator:ga804fd582353c5c71a984141921a9bd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdfd1c19b7c99ee9d8411b87beeb5a4f"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#gabdfd1c19b7c99ee9d8411b87beeb5a4f">M_event_timer_get_status</a> (<a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *timer)</td></tr>
<tr class="separator:gabdfd1c19b7c99ee9d8411b87beeb5a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf6eeab8c12ebe666cf38557e57b105f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#gabf6eeab8c12ebe666cf38557e57b105f">M_event_timer_oneshot</a> (<a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *event, M_uint64 interval_ms, M_bool autoremove, <a class="el" href="group__m__event.html#ga454e48a58bf322de6666c6d9e65c3b51">M_event_callback_t</a> callback, void *cb_data)</td></tr>
<tr class="separator:gabf6eeab8c12ebe666cf38557e57b105f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d217b7fc4c1310975855ccc2b894e9"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga45d217b7fc4c1310975855ccc2b894e9">M_event_timer_remove</a> (<a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *timer)</td></tr>
<tr class="separator:ga45d217b7fc4c1310975855ccc2b894e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae710da0d90387a5c4b71e8ae3bba1e0f"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#gae710da0d90387a5c4b71e8ae3bba1e0f">M_event_queue_task</a> (<a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *event, <a class="el" href="group__m__event.html#ga454e48a58bf322de6666c6d9e65c3b51">M_event_callback_t</a> callback, void *cb_data)</td></tr>
<tr class="separator:gae710da0d90387a5c4b71e8ae3bba1e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e0ea9055833a684aee9587252ed5fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__event.html#ga06d43d0bb0301ed7809ffddbfe6ca8b2">M_event_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#gab5e0ea9055833a684aee9587252ed5fd">M_event_loop</a> (<a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *event, M_uint64 timeout_ms)</td></tr>
<tr class="separator:gab5e0ea9055833a684aee9587252ed5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91277642f8c76eb816003d2cea649897"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga91277642f8c76eb816003d2cea649897">M_event_done</a> (<a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *event)</td></tr>
<tr class="separator:ga91277642f8c76eb816003d2cea649897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41a54262e3c0c742e6672ad860006da0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga41a54262e3c0c742e6672ad860006da0">M_event_return</a> (<a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *event)</td></tr>
<tr class="separator:ga41a54262e3c0c742e6672ad860006da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fb286ac5ca7c7fedc1aa26fd4f640b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga8fb286ac5ca7c7fedc1aa26fd4f640b4">M_event_done_with_disconnect</a> (<a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *event, M_uint64 timeout_ms)</td></tr>
<tr class="separator:ga8fb286ac5ca7c7fedc1aa26fd4f640b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3831d7b04aedd127e271f384393f475f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__event.html#gaf5323b0595d8268420f03023a3bbc55a">M_event_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga3831d7b04aedd127e271f384393f475f">M_event_get_status</a> (<a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *event)</td></tr>
<tr class="separator:ga3831d7b04aedd127e271f384393f475f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa335b517a777ba416483f687b18830c5"><td class="memItemLeft" align="right" valign="top">M_uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#gaa335b517a777ba416483f687b18830c5">M_event_process_time_ms</a> (<a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *event)</td></tr>
<tr class="separator:gaa335b517a777ba416483f687b18830c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f313f5d9599f6aed4a29e82a13e576b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__event.html#ga9f313f5d9599f6aed4a29e82a13e576b">M_event_num_objects</a> (<a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *event)</td></tr>
<tr class="separator:ga9f313f5d9599f6aed4a29e82a13e576b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Cross platform event based processing. A platform specific backend will be used as the underlying event system but all events will be exposed though this interface. No platform specific knowledge is needed.</p>
<p>Developers used to working with macOS event loop style of programming can use this event system to use that paradigm on other platforms. In this scenario most events would be triggered as OTHER. Some sort of tracking would be necessary to determine why an event was triggered if the same callback is used for multiple situations.</p>
<p>The event system is thread safe allowing io objects and times can be added to and moved between different event loops running on different threads. Triggers can be triggered from different threads. Destruction of an io object from a different thread will be queued in the event loop it's running on.</p>
<p>Note: the CONNECTED event will be triggered when a io object is added to an event loop using <a class="el" href="group__m__event.html#ga755cf00991529e324be3f9f49a5d5476">M_event_add()</a>.</p>
<p>Example application that demonstrates read/write events, timers, and queued tasks.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;mstdlib/mstdlib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;mstdlib/mstdlib_io.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">    <a class="code" href="group__m__buf.html#ga6c543ecf0004fc310faa23c6ed8b267f">M_buf_t</a>    *buf;</div><div class="line">    <a class="code" href="group__m__parser.html#ga60164be64f8c962c795e5927642fc473">M_parser_t</a> *parser;</div><div class="line">    <a class="code" href="group__m__io.html#ga845c131d8520206a2a7a9219d1bd1932">M_io_t</a>     *io; <span class="comment">// Necessary for the queued task and timer to have the correct io object.</span></div><div class="line">} ldata_t;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> add_queued_data(<a class="code" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *el, <a class="code" href="group__m__event.html#ga66b039653a61c8702310d03e6ba69802">M_event_type_t</a> etype, <a class="code" href="group__m__io.html#ga845c131d8520206a2a7a9219d1bd1932">M_io_t</a> *io, <span class="keywordtype">void</span> *thunk)</div><div class="line">{</div><div class="line">    ldata_t *ldata = thunk;</div><div class="line"></div><div class="line">    (void)el;</div><div class="line">    (void)etype;</div><div class="line"></div><div class="line">    <a class="code" href="group__m__buf.html#gad226a7199f864ff6a630dc7f16508c30">M_buf_add_str</a>(ldata-&gt;buf, <span class="stringliteral">&quot;STARTING\n&quot;</span>);</div><div class="line">    <a class="code" href="group__m__io.html#ga957eba52f32304ab07e06b516c04922a">M_io_write_from_buf</a>(ldata-&gt;io, ldata-&gt;buf);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> add_data(<a class="code" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *el, <a class="code" href="group__m__event.html#ga66b039653a61c8702310d03e6ba69802">M_event_type_t</a> etype, <a class="code" href="group__m__io.html#ga845c131d8520206a2a7a9219d1bd1932">M_io_t</a> *io, <span class="keywordtype">void</span> *thunk)</div><div class="line">{</div><div class="line">    ldata_t    *ldata = thunk;</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span>  i     = 1;</div><div class="line"></div><div class="line">    (void)el;</div><div class="line">    (void)etype;</div><div class="line"></div><div class="line">    <a class="code" href="group__m__buf.html#gad226a7199f864ff6a630dc7f16508c30">M_buf_add_str</a>(ldata-&gt;buf, <span class="stringliteral">&quot;TEST &quot;</span>);</div><div class="line">    <a class="code" href="group__m__buf.html#ga62225b9704fbef7ba338549382438bea">M_buf_add_int</a>(ldata-&gt;buf, i++);</div><div class="line">    <a class="code" href="group__m__buf.html#ga10fa5a66cbcb57830f0711050c363d70">M_buf_add_byte</a>(ldata-&gt;buf, <span class="charliteral">&#39;\n&#39;</span>);</div><div class="line">    <a class="code" href="group__m__io.html#ga957eba52f32304ab07e06b516c04922a">M_io_write_from_buf</a>(ldata-&gt;io, ldata-&gt;buf);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> stop(<a class="code" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *el, <a class="code" href="group__m__event.html#ga66b039653a61c8702310d03e6ba69802">M_event_type_t</a> etype, <a class="code" href="group__m__io.html#ga845c131d8520206a2a7a9219d1bd1932">M_io_t</a> *io, <span class="keywordtype">void</span> *thunk)</div><div class="line">{</div><div class="line">    (void)etype;</div><div class="line">    (void)io;</div><div class="line">    (void)thunk;</div><div class="line"></div><div class="line">    <a class="code" href="group__m__event.html#ga8fb286ac5ca7c7fedc1aa26fd4f640b4">M_event_done_with_disconnect</a>(el, 1000);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> run_cb(<a class="code" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *el, <a class="code" href="group__m__event.html#ga66b039653a61c8702310d03e6ba69802">M_event_type_t</a> etype, <a class="code" href="group__m__io.html#ga845c131d8520206a2a7a9219d1bd1932">M_io_t</a> *io, <span class="keywordtype">void</span> *thunk)</div><div class="line">{</div><div class="line">    ldata_t *ldata = thunk;</div><div class="line">    <span class="keywordtype">char</span>    *out;</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (etype) {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__m__event.html#gga5d54358d8088f050bcdb141c6c0b21e7ab0fc60e031020cb3f36b70c4932d67f2">M_EVENT_TYPE_CONNECTED</a>:</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__m__event.html#gga5d54358d8088f050bcdb141c6c0b21e7a8d2cf32ca08773c695e988635ebfd426">M_EVENT_TYPE_READ</a>:</div><div class="line">            <a class="code" href="group__m__io.html#ga0fb4e2775a964a263f7ec0fa50be4023">M_io_read_into_parser</a>(io, ldata-&gt;parser);</div><div class="line">            out = <a class="code" href="group__m__parser.html#ga0c17e75e8d82879f94dc47209a293ca7">M_parser_read_strdup</a>(ldata-&gt;parser, <a class="code" href="group__m__parser.html#gafeb4f3232d2d842889823bdf70338ac6">M_parser_len</a>(ldata-&gt;parser));</div><div class="line">            <a class="code" href="group__m__fmt.html#gae54b252ea2bcf34b09ef1fa0f134ffa8">M_printf</a>(<span class="stringliteral">&quot;%s&quot;</span>, out);</div><div class="line">            <a class="code" href="group__m__mem.html#gac4b3c1d73d6efe2542f5e729b58a271d">M_free</a>(out);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__m__event.html#gga5d54358d8088f050bcdb141c6c0b21e7a1713e94c1e0750f168d255f580fd4ad9">M_EVENT_TYPE_WRITE</a>:</div><div class="line">            <span class="comment">// Write any data pending in the buffer.</span></div><div class="line">            <a class="code" href="group__m__io.html#ga957eba52f32304ab07e06b516c04922a">M_io_write_from_buf</a>(io, ldata-&gt;buf);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__m__event.html#gga5d54358d8088f050bcdb141c6c0b21e7a6cead05362ca89b2cc7353bf6b4c2c6e">M_EVENT_TYPE_DISCONNECTED</a>:</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__m__event.html#gga5d54358d8088f050bcdb141c6c0b21e7a571c000a93b3c198364a32e5e145f2d0">M_EVENT_TYPE_ACCEPT</a>:</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__m__event.html#gga5d54358d8088f050bcdb141c6c0b21e7adce269f93799cdca69ac20235895d0ac">M_EVENT_TYPE_ERROR</a>:</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group__m__event.html#gga5d54358d8088f050bcdb141c6c0b21e7a89a67d4e5f2bdcadc1ffa3ba0473a6cf">M_EVENT_TYPE_OTHER</a>:</div><div class="line">            <a class="code" href="group__m__event.html#ga91277642f8c76eb816003d2cea649897">M_event_done</a>(el);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv)</div><div class="line">{</div><div class="line">    <a class="code" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a>       *el;</div><div class="line">    <a class="code" href="group__m__io.html#ga845c131d8520206a2a7a9219d1bd1932">M_io_t</a>          *io;</div><div class="line">    <a class="code" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *timer;</div><div class="line">    ldata_t          ldata;</div><div class="line"></div><div class="line">    el = <a class="code" href="group__m__event.html#gae169dca80125767d87fe196f32ea8d74">M_event_create</a>(<a class="code" href="group__m__event.html#gga72bc04891ff7b6142b7672a207ae74b1ac7efcb61cf28fa27d4a0a3daf68aaecf">M_EVENT_FLAG_NONE</a>);</div><div class="line"></div><div class="line">    <a class="code" href="group__m__io__loopback.html#ga42bda9717fa7e73eafde26d5ebebb935">M_io_loopback_create</a>(&amp;io);</div><div class="line">    ldata.buf    = <a class="code" href="group__m__buf.html#ga2031dcfdfa76f5feb5a59c8e7ac155d0">M_buf_create</a>();</div><div class="line">    ldata.parser = <a class="code" href="group__m__parser.html#gaf8100f8e139f41315478133992cc8ad1">M_parser_create</a>(<a class="code" href="group__m__parser.html#gga5f283601804b657a199f6574996ccf87a5879ad8c9fea3f4031268d7917b03933">M_PARSER_FLAG_NONE</a>);</div><div class="line">    ldata.io     = io;</div><div class="line"></div><div class="line">    <a class="code" href="group__m__event.html#ga755cf00991529e324be3f9f49a5d5476">M_event_add</a>(el, io, run_cb, &amp;ldata);</div><div class="line">    <a class="code" href="group__m__event.html#gae710da0d90387a5c4b71e8ae3bba1e0f">M_event_queue_task</a>(el, add_queued_data, &amp;ldata);</div><div class="line"></div><div class="line">    timer = <a class="code" href="group__m__event.html#ga3fb88400e7101b24886e55e0e24d495b">M_event_timer_add</a>(el, add_data, &amp;ldata);</div><div class="line">    <a class="code" href="group__m__event.html#ga2809669810c4005a6750c4dfe21bf8a5">M_event_timer_start</a>(timer, 500);</div><div class="line">    timer = <a class="code" href="group__m__event.html#ga3fb88400e7101b24886e55e0e24d495b">M_event_timer_add</a>(el, stop, NULL);</div><div class="line">    <a class="code" href="group__m__event.html#ga2809669810c4005a6750c4dfe21bf8a5">M_event_timer_start</a>(timer, 5000);</div><div class="line"></div><div class="line">    <a class="code" href="group__m__event.html#gab5e0ea9055833a684aee9587252ed5fd">M_event_loop</a>(el, M_TIMEOUT_INF);</div><div class="line"></div><div class="line">    <a class="code" href="group__m__io.html#ga1532f13c1f01fc1521b68a0f1d61c864">M_io_destroy</a>(io);</div><div class="line">    <a class="code" href="group__m__event.html#ga603f06976101b21e00517deb529f86bb">M_event_destroy</a>(el);</div><div class="line">    <a class="code" href="group__m__buf.html#gad51baebd5e46ee8231e78b926ccb198e">M_buf_cancel</a>(ldata.buf);</div><div class="line">    <a class="code" href="group__m__parser.html#ga3cd7b444d6f5058b149bc4c7262d5cb7">M_parser_destroy</a>(ldata.parser);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <h2 class="groupheader">Typedef Documentation</h2>
<a id="ga66b039653a61c8702310d03e6ba69802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66b039653a61c8702310d03e6ba69802">&#9670;&nbsp;</a></span>M_event_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group__m__event.html#ga5d54358d8088f050bcdb141c6c0b21e7">M_event_type</a> <a class="el" href="group__m__event.html#ga66b039653a61c8702310d03e6ba69802">M_event_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Events that can be generated. </p>

</div>
</div>
<a id="ga5af8e493dd11c5603689843f9b6ed2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5af8e493dd11c5603689843f9b6ed2bc">&#9670;&nbsp;</a></span>M_event_trigger_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct M_event_trigger <a class="el" href="group__m__event.html#ga5af8e493dd11c5603689843f9b6ed2bc">M_event_trigger_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle for an event trigger </p>

</div>
</div>
<a id="gaf7cc7058deaf2fd06e4a4733d16c9b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7cc7058deaf2fd06e4a4733d16c9b52">&#9670;&nbsp;</a></span>M_event_timer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct M_event_timer <a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle for an event timer </p>

</div>
</div>
<a id="ga747f0301bfcc6db3b51eaf07e2582350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga747f0301bfcc6db3b51eaf07e2582350">&#9670;&nbsp;</a></span>M_event_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct M_event <a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga454e48a58bf322de6666c6d9e65c3b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga454e48a58bf322de6666c6d9e65c3b51">&#9670;&nbsp;</a></span>M_event_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* M_event_callback_t) (<a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *event, <a class="el" href="group__m__event.html#ga66b039653a61c8702310d03e6ba69802">M_event_type_t</a> type, <a class="el" href="group__m__io.html#ga845c131d8520206a2a7a9219d1bd1932">M_io_t</a> *io, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Definition for a function callback that is called every time an event is triggered by the event subsystem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Internal event object, this is an event-thread specific object which could be the member of a pool. This object may be used to add new events to the same event thread, or <a class="el" href="group__m__event.html#ga9187e4d2237e25973975e200b4d52ff7">M_event_get_pool()</a> can be used to retrieve the master pool handle for distributing events across threads. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The type of event that has been triggered, see M_event_type_t. Always M_EVENT_TYPE_OTHER for trigger, timer, and queued tasks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io</td><td>Pointer to the M_io_t object associated with the event, or NULL for trigger, timer, and queued tasks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_arg</td><td>User-specified callback argument registered when the object was added to the event handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09d789310a18f48034c1eb6c42193fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09d789310a18f48034c1eb6c42193fbd">&#9670;&nbsp;</a></span>M_event_timer_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group__m__event.html#ga4466239df0e524aa31e71acb924e54d5">M_event_timer_modes</a> <a class="el" href="group__m__event.html#ga09d789310a18f48034c1eb6c42193fbd">M_event_timer_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timer modes of operation </p>

</div>
</div>
<a id="gaf5323b0595d8268420f03023a3bbc55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5323b0595d8268420f03023a3bbc55a">&#9670;&nbsp;</a></span>M_event_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group__m__event.html#gae0d1f0926d83227c5e7dddfbedf7e8ef">M_event_status</a> <a class="el" href="group__m__event.html#gaf5323b0595d8268420f03023a3bbc55a">M_event_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible event status codes for an event loop or pool </p>

</div>
</div>
<a id="ga06d43d0bb0301ed7809ffddbfe6ca8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06d43d0bb0301ed7809ffddbfe6ca8b2">&#9670;&nbsp;</a></span>M_event_err_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group__m__event.html#ga3d93964ec33daa93f69ee7205f341e9f">M_event_err</a> <a class="el" href="group__m__event.html#ga06d43d0bb0301ed7809ffddbfe6ca8b2">M_event_err_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible return codes for <a class="el" href="group__m__event.html#gab5e0ea9055833a684aee9587252ed5fd">M_event_loop()</a> </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga5d54358d8088f050bcdb141c6c0b21e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d54358d8088f050bcdb141c6c0b21e7">&#9670;&nbsp;</a></span>M_event_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__m__event.html#ga5d54358d8088f050bcdb141c6c0b21e7">M_event_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Events that can be generated.</p>
<p>Events are enumerated in priority of delivery order </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5d54358d8088f050bcdb141c6c0b21e7ab0fc60e031020cb3f36b70c4932d67f2"></a>M_EVENT_TYPE_CONNECTED&#160;</td><td class="fielddoc"><p>The connection has been completed </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5d54358d8088f050bcdb141c6c0b21e7a571c000a93b3c198364a32e5e145f2d0"></a>M_EVENT_TYPE_ACCEPT&#160;</td><td class="fielddoc"><p>A new incoming connection is ready to be accepted </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5d54358d8088f050bcdb141c6c0b21e7a8d2cf32ca08773c695e988635ebfd426"></a>M_EVENT_TYPE_READ&#160;</td><td class="fielddoc"><p>There is available data to be read </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5d54358d8088f050bcdb141c6c0b21e7a6cead05362ca89b2cc7353bf6b4c2c6e"></a>M_EVENT_TYPE_DISCONNECTED&#160;</td><td class="fielddoc"><p>The connection has been successfully disconnected. This is only triggered after a disconnect request, Otherwise most failures are determined by a Read event followed by a read failure. The connection object should be closed after this. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5d54358d8088f050bcdb141c6c0b21e7adce269f93799cdca69ac20235895d0ac"></a>M_EVENT_TYPE_ERROR&#160;</td><td class="fielddoc"><p>An error occurred. Most likely during connection establishment by a higher-level protocol. The connection object should be closed after this. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5d54358d8088f050bcdb141c6c0b21e7a1713e94c1e0750f168d255f580fd4ad9"></a>M_EVENT_TYPE_WRITE&#160;</td><td class="fielddoc"><p>There is room available in the write buffer </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5d54358d8088f050bcdb141c6c0b21e7a89a67d4e5f2bdcadc1ffa3ba0473a6cf"></a>M_EVENT_TYPE_OTHER&#160;</td><td class="fielddoc"><p>Some other event occurred, such as a triggered or timer-based event </p>
</td></tr>
</table>

</div>
</div>
<a id="ga72bc04891ff7b6142b7672a207ae74b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72bc04891ff7b6142b7672a207ae74b1">&#9670;&nbsp;</a></span>M_EVENT_FLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__m__event.html#ga72bc04891ff7b6142b7672a207ae74b1">M_EVENT_FLAGS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible list of flags that can be used when initializing an event loop </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga72bc04891ff7b6142b7672a207ae74b1ac7efcb61cf28fa27d4a0a3daf68aaecf"></a>M_EVENT_FLAG_NONE&#160;</td><td class="fielddoc"><p>No specialized flags </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bc04891ff7b6142b7672a207ae74b1a66ea43f6ded6e7175f1bebc4eb5528a1"></a>M_EVENT_FLAG_NOWAKE&#160;</td><td class="fielddoc"><p>We will never need to wake the event loop from another thread </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bc04891ff7b6142b7672a207ae74b1a528ef8c95e55e761a36e28f7af58818d"></a>M_EVENT_FLAG_EXITONEMPTY&#160;</td><td class="fielddoc"><p>Exit the event loop when there are no registered events </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72bc04891ff7b6142b7672a207ae74b1aec67bef19d068700f0372808c69a5490"></a>M_EVENT_FLAG_EXITONEMPTY_NOTIMERS&#160;</td><td class="fielddoc"><p>When combined with M_EVENT_FLAG_EXITONEMPTY, will ignore timers </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4466239df0e524aa31e71acb924e54d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4466239df0e524aa31e71acb924e54d5">&#9670;&nbsp;</a></span>M_event_timer_modes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__m__event.html#ga4466239df0e524aa31e71acb924e54d5">M_event_timer_modes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timer modes of operation </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4466239df0e524aa31e71acb924e54d5a46cf8f8103ddaa1a7976f6fef6683a29"></a>M_EVENT_TIMER_MODE_RELATIVE&#160;</td><td class="fielddoc"><p>The interval will be added on to the end of the last actual run time </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4466239df0e524aa31e71acb924e54d5a2cf9eb5d4bc66b0c162e045e325800c9"></a>M_EVENT_TIMER_MODE_MONOTONIC&#160;</td><td class="fielddoc"><p>The interval will be added on to the last scheduled run time, even if that time has already passed. This means you could have events that run closer together than the specified interval if it is trying to "catch up" due to a long running event handler. In general this is more useful for needing an event to run as close to a certain interval as possible without skewing the interval between events by the amount of time it takes to handle event callbacks. </p>
</td></tr>
</table>

</div>
</div>
<a id="gae0d1f0926d83227c5e7dddfbedf7e8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0d1f0926d83227c5e7dddfbedf7e8ef">&#9670;&nbsp;</a></span>M_event_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__m__event.html#gae0d1f0926d83227c5e7dddfbedf7e8ef">M_event_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible event status codes for an event loop or pool </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae0d1f0926d83227c5e7dddfbedf7e8efa6cd3686551b311cf43bf0a47a3bb85eb"></a>M_EVENT_STATUS_RUNNING&#160;</td><td class="fielddoc"><p>The event loop is current running and processing events </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae0d1f0926d83227c5e7dddfbedf7e8efa564ace6880d50d94423384f8c22322ce"></a>M_EVENT_STATUS_PAUSED&#160;</td><td class="fielddoc"><p>The event loop is not running due to not being started or a timeout occurring </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae0d1f0926d83227c5e7dddfbedf7e8efa24c8749f6b408df5bd4470b593c9bd1c"></a>M_EVENT_STATUS_RETURN&#160;</td><td class="fielddoc"><p>The event loop was explicitly told to return using <a class="el" href="group__m__event.html#ga41a54262e3c0c742e6672ad860006da0">M_event_return()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae0d1f0926d83227c5e7dddfbedf7e8efa5d3560019b6aa99d030fe0c79bd08987"></a>M_EVENT_STATUS_DONE&#160;</td><td class="fielddoc"><p>The event loop either exited due to <a class="el" href="group__m__event.html#ga91277642f8c76eb816003d2cea649897">M_event_done()</a> or there were no objects remaining as the event loop was initialized with M_EVENT_FLAG_EXITONEMPTY </p>
</td></tr>
</table>

</div>
</div>
<a id="ga3d93964ec33daa93f69ee7205f341e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d93964ec33daa93f69ee7205f341e9f">&#9670;&nbsp;</a></span>M_event_err</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__m__event.html#ga3d93964ec33daa93f69ee7205f341e9f">M_event_err</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible return codes for <a class="el" href="group__m__event.html#gab5e0ea9055833a684aee9587252ed5fd">M_event_loop()</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3d93964ec33daa93f69ee7205f341e9faf606120c776d8a403a717c1823f0238d"></a>M_EVENT_ERR_DONE&#160;</td><td class="fielddoc"><p>The event loop either exited due to <a class="el" href="group__m__event.html#ga91277642f8c76eb816003d2cea649897">M_event_done()</a> or <a class="el" href="group__m__event.html#ga8fb286ac5ca7c7fedc1aa26fd4f640b4">M_event_done_with_disconnect()</a> or there were no objects remaining as the event loop was initialized with M_EVENT_FLAG_EXITONEMPTY </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3d93964ec33daa93f69ee7205f341e9fa14835b933f79dfbd3a995b525be8b958"></a>M_EVENT_ERR_TIMEOUT&#160;</td><td class="fielddoc"><p>The timeout specified in <a class="el" href="group__m__event.html#gab5e0ea9055833a684aee9587252ed5fd">M_event_loop()</a> has expired </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3d93964ec33daa93f69ee7205f341e9fa1c4d39058b1dd163a7cece59b8ddfe5c"></a>M_EVENT_ERR_RETURN&#160;</td><td class="fielddoc"><p><a class="el" href="group__m__event.html#ga41a54262e3c0c742e6672ad860006da0">M_event_return()</a> was explicitly called </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3d93964ec33daa93f69ee7205f341e9fa9a6a30e82fb587d63245bc318d68af70"></a>M_EVENT_ERR_MISUSE&#160;</td><td class="fielddoc"><p>Misuse, e.g. NULL event handle </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae169dca80125767d87fe196f32ea8d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae169dca80125767d87fe196f32ea8d74">&#9670;&nbsp;</a></span>M_event_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a>* M_event_create </td>
          <td>(</td>
          <td class="paramtype">M_uint32&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a base event loop object.</p>
<p>An event loop is typically run in the main process thread and will block until process termination. IO and timer objects are enqueued into the event loop and dispatched within the event loop. Event loops are more efficient and scalable than using a thread per tracked io object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>One or more enum M_EVENT_FLAGS</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Initialized event loop object. </dd></dl>

</div>
</div>
<a id="ga6be59e7ccf75016c997b4919c9a709da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6be59e7ccf75016c997b4919c9a709da">&#9670;&nbsp;</a></span>M_event_pool_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a>* M_event_pool_create </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a pool of M_event_t objects bound to a master pool handle to distribute load of event handling across multiple threads.</p>
<p>One thread per CPU core will be created for handling events, up to the maximum specified during creationg of the pool. When an object is added to the event pool handle, an internal search is performed, and the least-loaded thread will receive the new object.</p>
<p>Objects bound to the same internal event object will always execute in the same thread which may be desirable for co-joined objects (otherwise additional locking may be required since multiple events could fire from different threads for some shared resource). Typically this co-joined objects will be created based on events that have been fired, so the M_event_t object returned from the M_event_callback_t callback should be used to ensure they stay co-joined.</p>
<p>For non co-joined objects, always ensure the event handle used is the pool by calling <a class="el" href="group__m__event.html#ga9187e4d2237e25973975e200b4d52ff7">M_event_get_pool()</a> otherwise load will not be distributed at all.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_threads</td><td>Artificial limitation on the maximum number of threads, the actual number of threads will be the lesser of this value and the number of cpu cores in the system. Use 0 for this value to simply use the number of cpu cores.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Initialized event pool, or in the case only a single thread would be used, a normal event object. </dd></dl>

</div>
</div>
<a id="ga9187e4d2237e25973975e200b4d52ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9187e4d2237e25973975e200b4d52ff7">&#9670;&nbsp;</a></span>M_event_get_pool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a>* M_event_get_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the distributed pool handle for balancing the load across an event pool, or self if not part of a pool.</p>
<p>This should be called to get the event handle during <a class="el" href="group__m__event.html#ga755cf00991529e324be3f9f49a5d5476">M_event_add()</a>, <a class="el" href="group__m__event.html#ga41874454cc5c17e8842de0153632bdef">M_event_trigger_add()</a>, <a class="el" href="group__m__event.html#ga3fb88400e7101b24886e55e0e24d495b">M_event_timer_add()</a>, <a class="el" href="group__m__event.html#gabf6eeab8c12ebe666cf38557e57b105f">M_event_timer_oneshot()</a>, or <a class="el" href="group__m__event.html#gae710da0d90387a5c4b71e8ae3bba1e0f">M_event_queue_task()</a> as by default tasks will otherwise not be distributed if using the event handle returned by the M_event_callback_t. In some cases it is desirable to ensure co-joined objects run within the same event thread and therefore desirable to enqueue multiple tasks for an internal event loop handle rather than the distributed pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to event handle either returned by <a class="el" href="group__m__event.html#gae169dca80125767d87fe196f32ea8d74">M_event_create()</a>, <a class="el" href="group__m__event.html#ga6be59e7ccf75016c997b4919c9a709da">M_event_pool_create()</a>, or from an M_event_callback_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to event pool, or self if not part of a pool (or if a pool object already passed in). </dd></dl>

</div>
</div>
<a id="ga603f06976101b21e00517deb529f86bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga603f06976101b21e00517deb529f86bb">&#9670;&nbsp;</a></span>M_event_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_event_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy the event loop or pool object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to event handle either returned by <a class="el" href="group__m__event.html#gae169dca80125767d87fe196f32ea8d74">M_event_create()</a>, <a class="el" href="group__m__event.html#ga6be59e7ccf75016c997b4919c9a709da">M_event_pool_create()</a>, or from an M_event_callback_t. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga755cf00991529e324be3f9f49a5d5476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga755cf00991529e324be3f9f49a5d5476">&#9670;&nbsp;</a></span>M_event_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_event_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__io.html#ga845c131d8520206a2a7a9219d1bd1932">M_io_t</a> *&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga454e48a58bf322de6666c6d9e65c3b51">M_event_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an io object to the event loop handle with a registered callback to deliver events to.</p>
<p>Adding handles to an event handle is threadsafe and can be executed either within an event callback or from a separate thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Event handle to add the event to. If desirable to ensure this io object is distributed across a pool, it is recommended to pass the return value of <a class="el" href="group__m__event.html#ga9187e4d2237e25973975e200b4d52ff7">M_event_get_pool()</a> rather than the event handle returned by an M_event_callback_t callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io</td><td>IO object to bind to the event handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Callback to be called when events occur. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Optional. User-defined callback data that will be passed to the user-defined callback. Use NULL if no data is necessary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, or M_FALSE on failure (e.g. misuse, or io handle already bound to an event). </dd></dl>

</div>
</div>
<a id="gabf02fc9c3f66ffe794be24e0957507e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf02fc9c3f66ffe794be24e0957507e7">&#9670;&nbsp;</a></span>M_event_edit_io_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_event_edit_io_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__io.html#ga845c131d8520206a2a7a9219d1bd1932">M_io_t</a> *&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga454e48a58bf322de6666c6d9e65c3b51">M_event_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Edit the callback associated with an io object in the event subsystem.</p>
<p>Editing allows a user to re-purpose an io object while processing events without needing to remove and re-add the object which may cause a loss of events.</p>
<dl class="section note"><dt>Note</dt><dd>This will NOT cause a connected event to be triggered like <a class="el" href="group__m__event.html#ga755cf00991529e324be3f9f49a5d5476">M_event_add()</a> does when you first add an io object to an event loop for already-established connections.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">io</td><td>IO object to modify the callback for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Callback to set. NULL will set it to no callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Data passed to callback function. NULL will remove the cb_data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_FALSE on error, such as if the IO object is not currently attached to an event loop. </dd></dl>

</div>
</div>
<a id="ga9c06f42d9f80ad3632538c077ed844d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c06f42d9f80ad3632538c077ed844d9">&#9670;&nbsp;</a></span>M_event_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_event_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__io.html#ga845c131d8520206a2a7a9219d1bd1932">M_io_t</a> *&#160;</td>
          <td class="paramname"><em>io</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an io object from its associated event handle.</p>
<p>Removing handles is threadsafe and can be executed either within an event callback or from a separate thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">io</td><td>IO object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga41874454cc5c17e8842de0153632bdef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41874454cc5c17e8842de0153632bdef">&#9670;&nbsp;</a></span>M_event_trigger_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__event.html#ga5af8e493dd11c5603689843f9b6ed2bc">M_event_trigger_t</a>* M_event_trigger_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga454e48a58bf322de6666c6d9e65c3b51">M_event_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a user-callable trigger which will call the pre-registered callback. Useful for cross-thread completion or status update notifications. Triggering events is threadsafe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Event handle to add the event to. If desirable to ensure this io object is distributed across a pool, it is recommended to pass the return value of <a class="el" href="group__m__event.html#ga9187e4d2237e25973975e200b4d52ff7">M_event_get_pool()</a> rather than the event handle returned by an M_event_callback_t callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Callback to be called when the trigger is called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Optional. User-defined callback data that will be passed to the user-defined callback. Use NULL if no data is necessary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to trigger to be used to execute callback, or NULL on failure </dd></dl>

</div>
</div>
<a id="ga5aa2de8f897a4ae1be1553f1128eafa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5aa2de8f897a4ae1be1553f1128eafa7">&#9670;&nbsp;</a></span>M_event_trigger_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_event_trigger_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga5af8e493dd11c5603689843f9b6ed2bc">M_event_trigger_t</a> *&#160;</td>
          <td class="paramname"><em>trigger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the user-callable trigger, once removed, the trigger is no longer valid and cannot be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trigger</td><td>Trigger returned from <a class="el" href="group__m__event.html#ga41874454cc5c17e8842de0153632bdef">M_event_trigger_add()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafcaab58b8fcd4253cd2bfe924563e13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcaab58b8fcd4253cd2bfe924563e13b">&#9670;&nbsp;</a></span>M_event_trigger_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_event_trigger_signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga5af8e493dd11c5603689843f9b6ed2bc">M_event_trigger_t</a> *&#160;</td>
          <td class="paramname"><em>trigger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signal the registered callback associated with the trigger to be called. This is threadsafe and may be called cross thread. If multiple signals are delivered before the callback is called, the duplicate signals will be silently discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trigger</td><td>Trigger returned from <a class="el" href="group__m__event.html#ga41874454cc5c17e8842de0153632bdef">M_event_trigger_add()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3fb88400e7101b24886e55e0e24d495b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fb88400e7101b24886e55e0e24d495b">&#9670;&nbsp;</a></span>M_event_timer_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a>* M_event_timer_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga454e48a58bf322de6666c6d9e65c3b51">M_event_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a timer object to the event loop specified that will call the user-supplied callback when the timer expires. The timer is created in a stopped state and must be started before it will fire.</p>
<p>If the timer is associated with another object (e.g. co-joined) then the same event handle as the other object should be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Event handle to add the timer to. If the event handle is a pool object, it will automatically distribute to an event thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>User-specified callback to call when the timer expires </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Optional. User-specified data supplied to user-specified callback when executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timer handle on success, NULL on failure. </dd></dl>

</div>
</div>
<a id="ga2809669810c4005a6750c4dfe21bf8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2809669810c4005a6750c4dfe21bf8a5">&#9670;&nbsp;</a></span>M_event_timer_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_event_timer_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint64&#160;</td>
          <td class="paramname"><em>interval_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts the specified timer with timeout specified. When the timeout expires, the callback associated with the timer will be executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>Timer handle returned by <a class="el" href="group__m__event.html#ga3fb88400e7101b24886e55e0e24d495b">M_event_timer_add()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interval_ms</td><td>Time in milliseconds before the timer will expire. May only be 0 if the configured "firecount" is 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE on failure (such as timer already running or invalid use). </dd></dl>

</div>
</div>
<a id="ga7cc2ffa4f595f828e84a0a42eb3bbabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cc2ffa4f595f828e84a0a42eb3bbabb">&#9670;&nbsp;</a></span>M_event_timer_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_event_timer_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops the specified timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>Timer handle returned by <a class="el" href="group__m__event.html#ga3fb88400e7101b24886e55e0e24d495b">M_event_timer_add()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE if timer not running </dd></dl>

</div>
</div>
<a id="gafdb4b2120cb1d4e18fe872e41f67d505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdb4b2120cb1d4e18fe872e41f67d505">&#9670;&nbsp;</a></span>M_event_timer_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_event_timer_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint64&#160;</td>
          <td class="paramname"><em>interval_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restart the timer.</p>
<p>If the timer is already stopped, will simply start it again. If the timer has "autoremove" configured, the removal will be skipped on stop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>Timer handle returned by <a class="el" href="group__m__event.html#ga3fb88400e7101b24886e55e0e24d495b">M_event_timer_add()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interval_ms</td><td>Time in milliseconds before the timer will expire. If specified as 0, will use the same interval_ms as the original <a class="el" href="group__m__event.html#ga2809669810c4005a6750c4dfe21bf8a5">M_event_timer_start()</a> call (NOTE: this is different behavior than the value of 0 for <a class="el" href="group__m__event.html#ga2809669810c4005a6750c4dfe21bf8a5">M_event_timer_start()</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE on failure. </dd></dl>

</div>
</div>
<a id="gac0bdd95d42641e30f805d2ef9a8b0708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0bdd95d42641e30f805d2ef9a8b0708">&#9670;&nbsp;</a></span>M_event_timer_set_starttv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_event_timer_set_starttv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__time.html#structM__timeval__t">M_timeval_t</a> *&#160;</td>
          <td class="paramname"><em>start_tv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set absolute time for first event to be fired.</p>
<p>This will not take effect until the next call to <a class="el" href="group__m__event.html#ga2809669810c4005a6750c4dfe21bf8a5">M_event_timer_start()</a> or <a class="el" href="group__m__event.html#gafdb4b2120cb1d4e18fe872e41f67d505">M_event_timer_reset()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>Timer handle returned by <a class="el" href="group__m__event.html#ga3fb88400e7101b24886e55e0e24d495b">M_event_timer_add()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_tv</td><td>Absolute time of first event to be fired, or NULL to clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE on failure </dd></dl>

</div>
</div>
<a id="gaafa2ce45f12e462c6047fe490e022f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafa2ce45f12e462c6047fe490e022f61">&#9670;&nbsp;</a></span>M_event_timer_set_endtv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_event_timer_set_endtv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__time.html#structM__timeval__t">M_timeval_t</a> *&#160;</td>
          <td class="paramname"><em>end_tv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set absolute time for when the timer will automatically stop</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>Timer handle returned by <a class="el" href="group__m__event.html#ga3fb88400e7101b24886e55e0e24d495b">M_event_timer_add()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_tv</td><td>Absolute time of when to stop the timer, or NULL to clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE on failure </dd></dl>

</div>
</div>
<a id="ga9b30cfa49281b4f1a8852581d7a88e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b30cfa49281b4f1a8852581d7a88e22">&#9670;&nbsp;</a></span>M_event_timer_set_firecount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_event_timer_set_firecount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the maximum number of times the timer should fire. Default is unlimited.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>Timer handle returned by <a class="el" href="group__m__event.html#ga3fb88400e7101b24886e55e0e24d495b">M_event_timer_add()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>Maximum number of times timer should fire. Use 0 for unlimited.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE on failure </dd></dl>

</div>
</div>
<a id="ga16adfacf818564d4b8e242b3caeb345c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16adfacf818564d4b8e242b3caeb345c">&#9670;&nbsp;</a></span>M_event_timer_set_autoremove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_event_timer_set_autoremove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the timer to automatically remove itself and free all used memory when the timer enters the stopped state. This will happen when exceeding the fire count, exceeding the configured end_tv or explicitly calling <a class="el" href="group__m__event.html#ga7cc2ffa4f595f828e84a0a42eb3bbabb">M_event_timer_stop()</a>.</p>
<p>NOTE: Be careful not to attempt to use the timer handle once it has been autoremoved as it will result in access to uninitialized memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>Timer handle returned by <a class="el" href="group__m__event.html#ga3fb88400e7101b24886e55e0e24d495b">M_event_timer_add()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enabled</td><td>M_TRUE to enable autoremove, M_FALSE to disable autoremove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE on failure. </dd></dl>

</div>
</div>
<a id="gaa7461b01a5cd6e6471e8c96df6dbb96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7461b01a5cd6e6471e8c96df6dbb96a">&#9670;&nbsp;</a></span>M_event_timer_set_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_event_timer_set_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga09d789310a18f48034c1eb6c42193fbd">M_event_timer_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the timer mode of operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>Timer handle returned by <a class="el" href="group__m__event.html#ga3fb88400e7101b24886e55e0e24d495b">M_event_timer_add()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Defaults to M_EVENT_TIMER_MODE_RELATIVE if not specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE on failure. </dd></dl>

</div>
</div>
<a id="ga804fd582353c5c71a984141921a9bd6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga804fd582353c5c71a984141921a9bd6b">&#9670;&nbsp;</a></span>M_event_timer_get_remaining_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_uint64 M_event_timer_get_remaining_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve number of milliseconds remaining on timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>Timer handle returned by <a class="el" href="group__m__event.html#ga3fb88400e7101b24886e55e0e24d495b">M_event_timer_add()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of milliseconds remaining on timer, or 0 if stopped. </dd></dl>

</div>
</div>
<a id="gabdfd1c19b7c99ee9d8411b87beeb5a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdfd1c19b7c99ee9d8411b87beeb5a4f">&#9670;&nbsp;</a></span>M_event_timer_get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_event_timer_get_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves if the timer is active(started) or not.</p>
<p>NOTE: Do not use with auto-destroy timers as the timer handle may not be valid if you don't already know the status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>Timer handle returned by <a class="el" href="group__m__event.html#ga3fb88400e7101b24886e55e0e24d495b">M_event_timer_add()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if timer is started, M_FALSE if timer is stopped. </dd></dl>

</div>
</div>
<a id="gabf6eeab8c12ebe666cf38557e57b105f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf6eeab8c12ebe666cf38557e57b105f">&#9670;&nbsp;</a></span>M_event_timer_oneshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a>* M_event_timer_oneshot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint64&#160;</td>
          <td class="paramname"><em>interval_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_bool&#160;</td>
          <td class="paramname"><em>autoremove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga454e48a58bf322de6666c6d9e65c3b51">M_event_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a single-event timer.</p>
<p>This is a convenience function equivalent to: M_event_timer_add(event, callback, cbdata) + M_event_timer_set_firecount(timer, 1) + M_event_timer_set_autoremove(timer, autoremove) + M_event_timer_start(timer, interval_ms)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Event handle to add the timer to. If the event handle is a pool object, it will automatically distribute to an event thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interval_ms</td><td>Time in milliseconds before the timer will expire. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autoremove</td><td>Whether the timer should automatically remove itself when it fires. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>User-specified callback to call when the timer expires </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Optional. User-specified data supplied to user-specified callback when executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timer handle on success, NULL on failure. </dd></dl>

</div>
</div>
<a id="ga45d217b7fc4c1310975855ccc2b894e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45d217b7fc4c1310975855ccc2b894e9">&#9670;&nbsp;</a></span>M_event_timer_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_event_timer_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#gaf7cc7058deaf2fd06e4a4733d16c9b52">M_event_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the timer and free all memory used by the timer.</p>
<p>If the timer isn't already stopped, this will prevent the timer from firing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>Timer handle returned by <a class="el" href="group__m__event.html#ga3fb88400e7101b24886e55e0e24d495b">M_event_timer_add()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE on failure. </dd></dl>

</div>
</div>
<a id="gae710da0d90387a5c4b71e8ae3bba1e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae710da0d90387a5c4b71e8ae3bba1e0f">&#9670;&nbsp;</a></span>M_event_queue_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_event_queue_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga454e48a58bf322de6666c6d9e65c3b51">M_event_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queue a task to run in the same thread as the event loop.</p>
<p>This is threadsafe to call, and convenient when wanting to avoid additional locks when operating on an object in the event loop.</p>
<p>This is currently implemented as a oneshot timer set for 0ms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Event handle to add task to. Does not make sense to hand an event pool object since the purpose is to choose the event loop to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>User-specified callback to call </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Optional. User-specified data supplied to user-specified callback when executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE on failure. </dd></dl>

</div>
</div>
<a id="gab5e0ea9055833a684aee9587252ed5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5e0ea9055833a684aee9587252ed5fd">&#9670;&nbsp;</a></span>M_event_loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__event.html#ga06d43d0bb0301ed7809ffddbfe6ca8b2">M_event_err_t</a> M_event_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint64&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the event loop to start processing events.</p>
<p>Events will not be delivered unless the event loop is running. If the event handle is a pool, will spawn threads for each member of the pool except one which will run and block the thread executing this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Initialized event handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Time in milliseconds to wait for events. Use M_TIMEOUT_INF to wait until an explicit exit condition has been met, which is the recommended way to run the event loop.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the M_event_err_t conditions. </dd></dl>

</div>
</div>
<a id="ga91277642f8c76eb816003d2cea649897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91277642f8c76eb816003d2cea649897">&#9670;&nbsp;</a></span>M_event_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_event_done </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exit the event loop immediately.</p>
<p>This is safe to call from a thread other than the event loop. Will set the M_EVENT_ERR_DONE return code for the event loop.</p>
<p>This will exit all threads for event pools as well, and if an event child handle is passed instead of the pool handle, it will automatically escalate to the pool handle.</p>
<p>This does not clean up the resources for the event loop and it is safe to re-execute the same event loop handle once it has returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Initialized event handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga41a54262e3c0c742e6672ad860006da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41a54262e3c0c742e6672ad860006da0">&#9670;&nbsp;</a></span>M_event_return()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_event_return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exit the event loop immediately.</p>
<p>This is safe to call from a thread other than the event loop. Will set the M_EVENT_ERR_RETURN return code for the event loop, this is the only way this call differs from <a class="el" href="group__m__event.html#ga91277642f8c76eb816003d2cea649897">M_event_done()</a>.</p>
<p>This will exit all threads for event pools as well, and if an event child handle is passed instead of the pool handle, it will automatically escalate to the pool handle.</p>
<p>This does not clean up the resources for the event loop and it is safe to re-execute the same event loop handle once it has returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Initialized event handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8fb286ac5ca7c7fedc1aa26fd4f640b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fb286ac5ca7c7fedc1aa26fd4f640b4">&#9670;&nbsp;</a></span>M_event_done_with_disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_event_done_with_disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint64&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signal all IO objects in the event loop to start their disconnect sequence and exit the event loop when all are closed, or the specified timeout has elapsed.</p>
<p>This is safe to call from a thread other than the event loop. Will set the M_EVENT_ERR_DONE return code for the event loop. The only difference between this and <a class="el" href="group__m__event.html#ga91277642f8c76eb816003d2cea649897">M_event_done()</a> is it attempts to close the IO objects gracefully, some users may want to use this for program termination.</p>
<p>This will exit all threads for event pools as well, and if an event child handle is passed instead of the pool handle, it will automatically escalate to the pool handle.</p>
<p>This does not clean up the resources for the event loop and it is safe to re-execute the same event loop handle once it has returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Initialized event handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Number of milliseconds to wait on IO handles to close before giving up. This should be set to some reasonable number to accommodate for proper disconnect sequences. A good starting point may be 5s (5000ms). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3831d7b04aedd127e271f384393f475f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3831d7b04aedd127e271f384393f475f">&#9670;&nbsp;</a></span>M_event_get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__event.html#gaf5323b0595d8268420f03023a3bbc55a">M_event_status_t</a> M_event_get_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current running status of the event loop.</p>
<p>If an event child handle is passed instead of the pool handle, it will automatically escalate to the pool handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Initialized event handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>one of M_event_status_t results. </dd></dl>

</div>
</div>
<a id="gaa335b517a777ba416483f687b18830c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa335b517a777ba416483f687b18830c5">&#9670;&nbsp;</a></span>M_event_process_time_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_uint64 M_event_process_time_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the number of milliseconds spent processing events, roughly equivalent to actual CPU time, not including idle time waiting on events to come in.</p>
<p>Will return results for the actual handle passed. If the handle is a child of an event pool, it will only return the child's processing time. If all processing time is desired, use <a class="el" href="group__m__event.html#ga9187e4d2237e25973975e200b4d52ff7">M_event_get_pool()</a> to get the pool handle before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Initialized event handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>milliseconds spent processing events. </dd></dl>

</div>
</div>
<a id="ga9f313f5d9599f6aed4a29e82a13e576b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f313f5d9599f6aed4a29e82a13e576b">&#9670;&nbsp;</a></span>M_event_num_objects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_event_num_objects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__event.html#ga747f0301bfcc6db3b51eaf07e2582350">M_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the number of M_io_t objects plus the number of M_event_timer_t objects associated with an event handle</p>
<p>Will return results for the actual handle passed. If the handle is a child of an event pool, it will only return the child's processing time. If all processing time is desired, use <a class="el" href="group__m__event.html#ga9187e4d2237e25973975e200b4d52ff7">M_event_get_pool()</a> to get the pool handle before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Initialized event handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of objects. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Feb 20 2018 12:46:13 for Mstdlib-1.0.0 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
