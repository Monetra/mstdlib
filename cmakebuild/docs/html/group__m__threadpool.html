<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mstdlib-1.0.0: Thread Pool</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mstdlib-1.0.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__m__threadpool.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Thread Pool<div class="ingroups"><a class="el" href="group__m__thread.html">Threading Support</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga591e1b82137fdb49fb995364e599db83"><td class="memItemLeft" align="right" valign="top">typedef struct M_threadpool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__threadpool.html#ga591e1b82137fdb49fb995364e599db83">M_threadpool_t</a></td></tr>
<tr class="separator:ga591e1b82137fdb49fb995364e599db83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e1cd3d78d5740b959b4684e560a4cc5"><td class="memItemLeft" align="right" valign="top">typedef struct M_threadpool_parent&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__threadpool.html#ga4e1cd3d78d5740b959b4684e560a4cc5">M_threadpool_parent_t</a></td></tr>
<tr class="separator:ga4e1cd3d78d5740b959b4684e560a4cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga466a0ca11ded0b7097c1af8ad3144e5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__threadpool.html#ga591e1b82137fdb49fb995364e599db83">M_threadpool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__threadpool.html#ga466a0ca11ded0b7097c1af8ad3144e5b">M_threadpool_create</a> (size_t min_threads, size_t max_threads, M_uint64 idle_time_ms, size_t queue_max_size)</td></tr>
<tr class="separator:ga466a0ca11ded0b7097c1af8ad3144e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada6d97c444562cbe6cc37e78652755ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__threadpool.html#gada6d97c444562cbe6cc37e78652755ff">M_threadpool_destroy</a> (<a class="el" href="group__m__threadpool.html#ga591e1b82137fdb49fb995364e599db83">M_threadpool_t</a> *pool)</td></tr>
<tr class="separator:gada6d97c444562cbe6cc37e78652755ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bfadc97aca23406a2c137a60005a189"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__m__threadpool.html#ga4e1cd3d78d5740b959b4684e560a4cc5">M_threadpool_parent_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__threadpool.html#ga4bfadc97aca23406a2c137a60005a189">M_threadpool_parent_create</a> (<a class="el" href="group__m__threadpool.html#ga591e1b82137fdb49fb995364e599db83">M_threadpool_t</a> *pool)</td></tr>
<tr class="separator:ga4bfadc97aca23406a2c137a60005a189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45eb17d7f036032fb44c32e144f3e8f6"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__threadpool.html#ga45eb17d7f036032fb44c32e144f3e8f6">M_threadpool_parent_destroy</a> (<a class="el" href="group__m__threadpool.html#ga4e1cd3d78d5740b959b4684e560a4cc5">M_threadpool_parent_t</a> *parent)</td></tr>
<tr class="separator:ga45eb17d7f036032fb44c32e144f3e8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0468dfae4c5c82d3fdaef7c5c7734ce3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__threadpool.html#ga0468dfae4c5c82d3fdaef7c5c7734ce3">M_threadpool_dispatch</a> (<a class="el" href="group__m__threadpool.html#ga4e1cd3d78d5740b959b4684e560a4cc5">M_threadpool_parent_t</a> *parent, void(*task)(void *), void **task_args, size_t num_tasks)</td></tr>
<tr class="separator:ga0468dfae4c5c82d3fdaef7c5c7734ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9f6594acaa1233e809eb93c8700f13c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__threadpool.html#gaa9f6594acaa1233e809eb93c8700f13c">M_threadpool_available_slots</a> (const <a class="el" href="group__m__threadpool.html#ga591e1b82137fdb49fb995364e599db83">M_threadpool_t</a> *pool)</td></tr>
<tr class="separator:gaa9f6594acaa1233e809eb93c8700f13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41028a733fdb790ec220c014bbebd428"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__threadpool.html#ga41028a733fdb790ec220c014bbebd428">M_threadpool_wait_available_thread</a> (<a class="el" href="group__m__threadpool.html#ga4e1cd3d78d5740b959b4684e560a4cc5">M_threadpool_parent_t</a> *parent)</td></tr>
<tr class="separator:ga41028a733fdb790ec220c014bbebd428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2d71bce2c7268c2e7d8b9e66a1df688"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__threadpool.html#gac2d71bce2c7268c2e7d8b9e66a1df688">M_threadpool_num_threads</a> (const <a class="el" href="group__m__threadpool.html#ga591e1b82137fdb49fb995364e599db83">M_threadpool_t</a> *pool)</td></tr>
<tr class="separator:gac2d71bce2c7268c2e7d8b9e66a1df688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf95269f543784664301110b07a597d09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__threadpool.html#gaf95269f543784664301110b07a597d09">M_threadpool_parent_wait</a> (<a class="el" href="group__m__threadpool.html#ga4e1cd3d78d5740b959b4684e560a4cc5">M_threadpool_parent_t</a> *parent)</td></tr>
<tr class="separator:gaf95269f543784664301110b07a597d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Implementation of a thread pool for having a limited the number of threads available to workers. Threads in the pool will only be destroyed when the pool is destroyed. A maximum number of threads will be created by the pool. Workers are assigned to parents which can be used to logically separate workers by tasks.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> M_uint32 count = 0;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> pool_task(<span class="keywordtype">void</span> *arg)</div><div class="line">{</div><div class="line">    (void)arg;</div><div class="line">    <a class="code" href="group__m__atomic.html#ga50bc1b16ed20625fd76b0c433f0c0469">M_atomic_inc_u32</a>(&amp;count);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">    <a class="code" href="group__m__threadpool.html#ga591e1b82137fdb49fb995364e599db83">M_threadpool_t</a>        *pool;</div><div class="line">    <a class="code" href="group__m__threadpool.html#ga4e1cd3d78d5740b959b4684e560a4cc5">M_threadpool_parent_t</a> *parent;</div><div class="line">    <span class="keywordtype">char</span>                   args[32];</div><div class="line"></div><div class="line">    <a class="code" href="group__m__mem.html#ga12f125e84df307ef19f5d418b734202c">M_mem_set</a>(args, 0, <span class="keyword">sizeof</span>(args));</div><div class="line"></div><div class="line">    pool   = <a class="code" href="group__m__threadpool.html#ga466a0ca11ded0b7097c1af8ad3144e5b">M_threadpool_create</a>(16, 16, 0, SIZE_MAX);</div><div class="line">    parent = <a class="code" href="group__m__threadpool.html#ga4bfadc97aca23406a2c137a60005a189">M_threadpool_parent_create</a>(pool);</div><div class="line"></div><div class="line">    <a class="code" href="group__m__threadpool.html#ga0468dfae4c5c82d3fdaef7c5c7734ce3">M_threadpool_dispatch</a>(parent, pool_task, (<span class="keywordtype">void</span> **)&amp;args, <span class="keyword">sizeof</span>(args));</div><div class="line">    <a class="code" href="group__m__threadpool.html#gaf95269f543784664301110b07a597d09">M_threadpool_parent_wait</a>(parent);</div><div class="line">    </div><div class="line">    <a class="code" href="group__m__threadpool.html#ga45eb17d7f036032fb44c32e144f3e8f6">M_threadpool_parent_destroy</a>(parent);</div><div class="line">    <a class="code" href="group__m__threadpool.html#gada6d97c444562cbe6cc37e78652755ff">M_threadpool_destroy</a>(pool);</div><div class="line"></div><div class="line">    <a class="code" href="group__m__fmt.html#gae54b252ea2bcf34b09ef1fa0f134ffa8">M_printf</a>(<span class="stringliteral">&quot;count=&#39;%u&#39;\n&quot;</span>, count);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">} </div></div><!-- fragment --> <h2 class="groupheader">Typedef Documentation</h2>
<a id="ga591e1b82137fdb49fb995364e599db83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga591e1b82137fdb49fb995364e599db83">&#9670;&nbsp;</a></span>M_threadpool_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct M_threadpool <a class="el" href="group__m__threadpool.html#ga591e1b82137fdb49fb995364e599db83">M_threadpool_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4e1cd3d78d5740b959b4684e560a4cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e1cd3d78d5740b959b4684e560a4cc5">&#9670;&nbsp;</a></span>M_threadpool_parent_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct M_threadpool_parent <a class="el" href="group__m__threadpool.html#ga4e1cd3d78d5740b959b4684e560a4cc5">M_threadpool_parent_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga466a0ca11ded0b7097c1af8ad3144e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga466a0ca11ded0b7097c1af8ad3144e5b">&#9670;&nbsp;</a></span>M_threadpool_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__threadpool.html#ga591e1b82137fdb49fb995364e599db83">M_threadpool_t</a>* M_threadpool_create </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint64&#160;</td>
          <td class="paramname"><em>idle_time_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>queue_max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a new threadpool and spawns the minimum number of threads requested.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min_threads</td><td>Minimum number of threads to spawn, 0 to not pre-spawn any. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_threads</td><td>Maximum number of threads to spawn, any number above the min_threads number will be spawned on demand, and idle threads will be shutdown after the specified idle time. Must be greater than 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idle_time_ms</td><td>Number of milliseconds a thread can be idle for before it is destroyed when the total thread count is above min_threads. If min_threads and max_threads are the same value, this parameter is ignored. Use M_UINT64_MAX to never terminate an idle thread, or use 0 to never allow idle threads. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue_max_size</td><td>If 0, will calculate a desirable queue size based on the maximum thread count. Otherwise, must be at least the size of the thread pool. It often makes sense to have the queue larger than the threadpool size to prevent the threads from sleeping. When inserting into the queue, if there are no available slots the <a class="el" href="group__m__threadpool.html#ga0468dfae4c5c82d3fdaef7c5c7734ce3">M_threadpool_dispatch()</a> function will block. If blocking is not desirable, use SIZE_MAX to allow an unbounded number of queue slots.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>initialized threadpool or NULL on failure </dd></dl>

</div>
</div>
<a id="gada6d97c444562cbe6cc37e78652755ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada6d97c444562cbe6cc37e78652755ff">&#9670;&nbsp;</a></span>M_threadpool_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_threadpool_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__threadpool.html#ga591e1b82137fdb49fb995364e599db83">M_threadpool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shuts down the thread pool, waits for all threads to exit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>initialized threadpool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4bfadc97aca23406a2c137a60005a189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bfadc97aca23406a2c137a60005a189">&#9670;&nbsp;</a></span>M_threadpool_parent_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__m__threadpool.html#ga4e1cd3d78d5740b959b4684e560a4cc5">M_threadpool_parent_t</a>* M_threadpool_parent_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__threadpool.html#ga591e1b82137fdb49fb995364e599db83">M_threadpool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new parent/user/consumer of the threadpool.</p>
<p>This is the handle used to insert tasks and wait for task completion specific to the consumer.</p>
<p>It is safe to share this handle across multiple threads if convenient as long as it is guaranteed to not be destroyed until all consumers are done using it. If sharing across multiple threads, it probably would mean you would not be using <a class="el" href="group__m__threadpool.html#gaf95269f543784664301110b07a597d09">M_threadpool_parent_wait()</a> from multiple threads simultaneously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Initialized thread pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>initialized parent/user/consumer handle. </dd></dl>

</div>
</div>
<a id="ga45eb17d7f036032fb44c32e144f3e8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45eb17d7f036032fb44c32e144f3e8f6">&#9670;&nbsp;</a></span>M_threadpool_parent_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_threadpool_parent_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__threadpool.html#ga4e1cd3d78d5740b959b4684e560a4cc5">M_threadpool_parent_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the parent handle.</p>
<p>There must be no oustanding tasks prior to calling this. Call <a class="el" href="group__m__threadpool.html#gaf95269f543784664301110b07a597d09">M_threadpool_parent_wait()</a> first if unsure to wait on all tasks to complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Initialized parent handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_FALSE if there are tasks remaining, M_TRUE if successfully cleaned up. </dd></dl>

</div>
</div>
<a id="ga0468dfae4c5c82d3fdaef7c5c7734ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0468dfae4c5c82d3fdaef7c5c7734ce3">&#9670;&nbsp;</a></span>M_threadpool_dispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_threadpool_dispatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__threadpool.html#ga4e1cd3d78d5740b959b4684e560a4cc5">M_threadpool_parent_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>task_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dispatch a task or set of tasks to the threadpool.</p>
<p>Requires a callback function to do the processing and an argument that is passed to the function. There is no way to retrieve a return value from the task, so the argument passed to the task should hold a result parameter if it is necessary to know the completion status. Multiple tasks may be queued simultaneously.</p>
<p>This may take a while to complete if there are no queue slots available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parent</td><td>Initialized parent handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>Task callback. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">task_args</td><td>Argument array to pass to each task (one per task). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_tasks</td><td>total number of tasks being enqueued. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa9f6594acaa1233e809eb93c8700f13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9f6594acaa1233e809eb93c8700f13c">&#9670;&nbsp;</a></span>M_threadpool_available_slots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_threadpool_available_slots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__m__threadpool.html#ga591e1b82137fdb49fb995364e599db83">M_threadpool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count the number of queue slots available to be enqueued for a threadpool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>initialized threadpool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga41028a733fdb790ec220c014bbebd428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41028a733fdb790ec220c014bbebd428">&#9670;&nbsp;</a></span>M_threadpool_wait_available_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_threadpool_wait_available_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__threadpool.html#ga4e1cd3d78d5740b959b4684e560a4cc5">M_threadpool_parent_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for a thread to become available for processing tasks.</p>
<p>This explicitly waits for a THREAD and NOT an available queue slot which there could be available slots. This is meant as an optimization in some instances where you want to ensure you enqueue some things together, especially if you're trying to manage SQL locks for tasks being performed. Typically though, this function would never be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Initialized parent handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac2d71bce2c7268c2e7d8b9e66a1df688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2d71bce2c7268c2e7d8b9e66a1df688">&#9670;&nbsp;</a></span>M_threadpool_num_threads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_threadpool_num_threads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__m__threadpool.html#ga591e1b82137fdb49fb995364e599db83">M_threadpool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current count of the number of threads in the thread pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>Initialized pool handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of threads </dd></dl>

</div>
</div>
<a id="gaf95269f543784664301110b07a597d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf95269f543784664301110b07a597d09">&#9670;&nbsp;</a></span>M_threadpool_parent_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_threadpool_parent_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__threadpool.html#ga4e1cd3d78d5740b959b4684e560a4cc5">M_threadpool_parent_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for all queued tasks to complete then return.</p>
<p>This is a blocking function with no return value. It is not recommended to call this from mulitiple threads simultaneously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>the initialized parent/user/consumer handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Feb 20 2018 12:46:13 for Mstdlib-1.0.0 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
