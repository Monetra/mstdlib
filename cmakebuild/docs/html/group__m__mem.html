<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mstdlib-1.0.0: Memory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mstdlib-1.0.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__m__mem.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Memory<div class="ingroups"><a class="el" href="group__mstdlib__base.html">Base</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga24101a8e6170e3a987550f169d1472f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga24101a8e6170e3a987550f169d1472f8">M_mem_str</a>(haystack,  haystack_len,  needle)&#160;&#160;&#160;<a class="el" href="group__m__mem.html#gadbd0a455897f5844298509ab2fb6b26c">M_mem_mem</a>(haystack,haystack_len,needle,<a class="el" href="group__m__str__check.html#gabebfa875d1ada2b43f52b9344b0844d0">M_str_len</a>(needle) )</td></tr>
<tr class="separator:ga24101a8e6170e3a987550f169d1472f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99fafb67dd5410f9b3a6deca0e8586e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga99fafb67dd5410f9b3a6deca0e8586e6">M_mem_strpos</a>(haystack,  haystack_len,  needle,  idx)&#160;&#160;&#160;<a class="el" href="group__m__mem.html#gaa54ac58d400979385777369c161a92fb">M_mem_mempos</a>(haystack,haystack_len,needle,<a class="el" href="group__m__str__check.html#gabebfa875d1ada2b43f52b9344b0844d0">M_str_len</a>(needle) ,idx)</td></tr>
<tr class="separator:ga99fafb67dd5410f9b3a6deca0e8586e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf095e6a5335edab1accd3a9dd15e7295"><td class="memItemLeft" align="right" valign="top">typedef M_bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#gaf095e6a5335edab1accd3a9dd15e7295">M_malloc_error_cb</a>) (void)</td></tr>
<tr class="separator:gaf095e6a5335edab1accd3a9dd15e7295"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf4b3922bed6ae588687f68cfca54a81d"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#gaf4b3922bed6ae588687f68cfca54a81d">M_malloc_register_errorcb</a> (<a class="el" href="group__m__mem.html#gaf095e6a5335edab1accd3a9dd15e7295">M_malloc_error_cb</a> cb)</td></tr>
<tr class="separator:gaf4b3922bed6ae588687f68cfca54a81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0592a2af948ccf908e9c7deeb8c140e1"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga0592a2af948ccf908e9c7deeb8c140e1">M_malloc_deregister_errorcb</a> (<a class="el" href="group__m__mem.html#gaf095e6a5335edab1accd3a9dd15e7295">M_malloc_error_cb</a> cb)</td></tr>
<tr class="separator:ga0592a2af948ccf908e9c7deeb8c140e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfd0e14508daeb82eb1c9097da6573bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#gacfd0e14508daeb82eb1c9097da6573bc">M_malloc_clear_errorcb</a> (void)</td></tr>
<tr class="separator:gacfd0e14508daeb82eb1c9097da6573bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga630c33353895d6ecb3a060e7d82de153"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga630c33353895d6ecb3a060e7d82de153">M_malloc</a> (size_t size) M_ALLOC_SIZE(1) M_WARN_UNUSED_RESULT M_MALLOC</td></tr>
<tr class="separator:ga630c33353895d6ecb3a060e7d82de153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9473a8ef59f5c85d37b3d35f461a82f1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga9473a8ef59f5c85d37b3d35f461a82f1">M_malloc_zero</a> (size_t size) M_ALLOC_SIZE(1) M_WARN_UNUSED_RESULT M_MALLOC</td></tr>
<tr class="separator:ga9473a8ef59f5c85d37b3d35f461a82f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4b3c1d73d6efe2542f5e729b58a271d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#gac4b3c1d73d6efe2542f5e729b58a271d">M_free</a> (void *ptr) M_FREE(1)</td></tr>
<tr class="separator:gac4b3c1d73d6efe2542f5e729b58a271d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga508f28cb39b38e7abe77870e9ebe1d5c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga508f28cb39b38e7abe77870e9ebe1d5c">M_realloc</a> (void *ptr, size_t size) M_ALLOC_SIZE(2) M_WARN_UNUSED_RESULT</td></tr>
<tr class="separator:ga508f28cb39b38e7abe77870e9ebe1d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60edff6fa56d47f3d87f8dfe4da27f8f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga60edff6fa56d47f3d87f8dfe4da27f8f">M_realloc_zero</a> (void *ptr, size_t size) M_ALLOC_SIZE(2) M_WARN_UNUSED_RESULT</td></tr>
<tr class="separator:ga60edff6fa56d47f3d87f8dfe4da27f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf4d3a27d93dd8b10ce405f9ed26f78f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#gacf4d3a27d93dd8b10ce405f9ed26f78f">M_memdup</a> (const void *src, size_t size) M_ALLOC_SIZE(2) M_WARN_UNUSED_RESULT M_MALLOC</td></tr>
<tr class="separator:gacf4d3a27d93dd8b10ce405f9ed26f78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga128a100f9252845e07cf83d90175b165"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga128a100f9252845e07cf83d90175b165">M_memdup_max</a> (const void *src, size_t size, size_t min_alloc_size) M_ALLOC_SIZE(2) M_WARN_UNUSED_RESULT M_MALLOC</td></tr>
<tr class="separator:ga128a100f9252845e07cf83d90175b165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12f125e84df307ef19f5d418b734202c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga12f125e84df307ef19f5d418b734202c">M_mem_set</a> (void *s, int c, size_t n)</td></tr>
<tr class="separator:ga12f125e84df307ef19f5d418b734202c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3f4ea473f3ca4bbc27f584cb13e08f1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#gad3f4ea473f3ca4bbc27f584cb13e08f1">M_mem_move</a> (void *dst, const void *src, size_t size)</td></tr>
<tr class="separator:gad3f4ea473f3ca4bbc27f584cb13e08f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81b9bd497064d6d9b75239014669d231"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga81b9bd497064d6d9b75239014669d231">M_mem_copy</a> (void *dst, const void *src, size_t size)</td></tr>
<tr class="separator:ga81b9bd497064d6d9b75239014669d231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9062ab80ddb9acb799ce5adeca0c44e6"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga9062ab80ddb9acb799ce5adeca0c44e6">M_mem_eq</a> (const void *m1, const void *m2, size_t size)</td></tr>
<tr class="separator:ga9062ab80ddb9acb799ce5adeca0c44e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a800ea6a534a0cc7c5d21951401502"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga11a800ea6a534a0cc7c5d21951401502">M_mem_cmpsort</a> (const void *m1, size_t size1, const void *m2, size_t size2) M_WARN_UNUSED_RESULT</td></tr>
<tr class="separator:ga11a800ea6a534a0cc7c5d21951401502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28a693c14e182dbf122ccdd062588062"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga28a693c14e182dbf122ccdd062588062">M_mem_chr</a> (const void *s, M_uint8 b, size_t n) M_WARN_UNUSED_RESULT</td></tr>
<tr class="separator:ga28a693c14e182dbf122ccdd062588062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19335a606e4f50b52e9b7a47bd836f7a"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga19335a606e4f50b52e9b7a47bd836f7a">M_mem_contains</a> (const void *haystack, size_t haystack_len, const void *needle, size_t needle_len) M_WARN_UNUSED_RESULT</td></tr>
<tr class="separator:ga19335a606e4f50b52e9b7a47bd836f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd0a455897f5844298509ab2fb6b26c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#gadbd0a455897f5844298509ab2fb6b26c">M_mem_mem</a> (const void *haystack, size_t haystack_len, const void *needle, size_t needle_len) M_WARN_UNUSED_RESULT</td></tr>
<tr class="separator:gadbd0a455897f5844298509ab2fb6b26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga093cdece4ecd385dcac6cddff35e216d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga093cdece4ecd385dcac6cddff35e216d">M_mem_rmem</a> (const void *haystack, size_t haystack_len, const void *needle, size_t needle_len) M_WARN_UNUSED_RESULT</td></tr>
<tr class="separator:ga093cdece4ecd385dcac6cddff35e216d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66c1e2ed92d892c908ced791416beed2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga66c1e2ed92d892c908ced791416beed2">M_mem_str</a> (const void *haystack, size_t haystack_len, const char *needle) M_WARN_UNUSED_RESULT</td></tr>
<tr class="separator:ga66c1e2ed92d892c908ced791416beed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa54ac58d400979385777369c161a92fb"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#gaa54ac58d400979385777369c161a92fb">M_mem_mempos</a> (const void *haystack, size_t haystack_len, const void *needle, size_t needle_len, size_t *idx) M_WARN_UNUSED_RESULT</td></tr>
<tr class="separator:gaa54ac58d400979385777369c161a92fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dbc87988f4345efccbb3eee092bc17b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga6dbc87988f4345efccbb3eee092bc17b">M_mem_count</a> (const void *s, size_t s_len, M_uint8 b) M_WARN_UNUSED_RESULT</td></tr>
<tr class="separator:ga6dbc87988f4345efccbb3eee092bc17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a11dc1aa0bc31f10a1289043464f966"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga8a11dc1aa0bc31f10a1289043464f966">M_mem_calc_lrc</a> (const void *s, size_t s_len)</td></tr>
<tr class="separator:ga8a11dc1aa0bc31f10a1289043464f966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4c5a89a3aaac19e65287111895c213"><td class="memItemLeft" align="right" valign="top">M_uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga3c4c5a89a3aaac19e65287111895c213">M_mem_calc_crc8_ccitt</a> (const void *s, size_t s_len)</td></tr>
<tr class="separator:ga3c4c5a89a3aaac19e65287111895c213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d13486661a48da9e476aac1eaf70ea0"><td class="memItemLeft" align="right" valign="top">M_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__m__mem.html#ga7d13486661a48da9e476aac1eaf70ea0">M_mem_swap_bytes</a> (M_uint8 *s, size_t s_len, size_t idx1, size_t idx2)</td></tr>
<tr class="separator:ga7d13486661a48da9e476aac1eaf70ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Memory manipulation.</p>
<h1>Hardening </h1>
<p>To aid in hardening M_malloc wraps the system malloc and stores the length of allocated memory. M_free uses this length and zeros the memory before calling the system free. The length is prepended to the memory segment and the pointer to the memory after the size is returned. The size is then read by M_free so the full allocated memory segment can be zeroed.</p>
<p>Zeroing memory is performed to combat memory scan attacks. It's not possible to know what data in memory is sensitive so all data is considered sensitive. Zeroing limits the amount of time data such as credit card numbers or encryption keys are available. This way data is available only as long as needed.</p>
<p>M_malloc and M_free are not replacements for the system provided malloc and free functions. They work on top of the system functions. This is so a hardened system malloc will not have it's functionality disrupted. Further, a replacement malloc implementation (such as jemalloc) can still be used.</p>
<p>Some system mallocs already zero memory but many do not. Mstdlib's M_malloc brings this to systems that do not implement this security feature. This is a case where security trumps performance.</p>
<p>Memory allocated using M_malloc must never be passed directly to the system free due to the length offset prefix, the caller would not be passing the base of the block and therefore cause undefined behavior (probably a segfault).</p>
<p>Memory allocated by malloc (not M_malloc) should never be passed to M_free. This will result in undefined behavior (probably a segfault) as well.</p>
<p>All mstdlib functions that allocate memory use mstdlib's M_malloc. Thus any memory that needs to be freed using free that is returned by an mstdlib function must be passed to M_free.</p>
<h1>Hardening that doesn't work </h1>
<p>There are a few "hardening" features that are available on Linux and other Unix platforms that were evaluated. These were determined to not be usable.</p>
<h2>mlock </h2>
<p>mlock prevents a memory segment from being written to on disk swap space.</p>
<p>The issue with mlock is limits set by the OS. RLIMIT_MEMLOCK (ulimit -l) limits the amount of memory that can be locked. munlock must be used (before or after, testing showed it didn't matter) to reduce the locked memory amount. munmap should implicitly unlock the memory as well but in testing a simple free did not cause the memory to be unlocked.</p>
<p>munlock is not enough to avoid hitting the limit. In simple / small applications or test cases, it would function fine. However, a larger application which uses more memory will fail. Once the lock limit is reached an out of memory error will be returned.</p>
<p>On Ubuntu 14.04.2 the default RLIMIT_MEMLOCK is 64K. On some versions of Debian is was found to be 32K. This limit will quickly be reached by a non-trivial application.</p>
<p>Configuring the system to have a larger limit or making the limit unlimited may not alleviate this issue. For example, FreeBSD allows mlock use to be restricted to the user-user only.</p>
<p>Further, Requiring system configuration to use a general purpose library is unacceptable. Especially when the configuration is non-obvious. Also if mlock is limited to super-user only then mstdlib would be unusable as user level application.</p>
<h2>madvise with MADV_DONTDUMP </h2>
<p>This is used to prevent marked memory from being in a core dump.</p>
<p>On Linux madvise requires the memory to be page-aligned. If the memory is not page-aligned madvise will return a failure with errno EINVAL. Page-alignment can easily cause the application to run out of address space.</p>
<p>For example you could use an allocation like: </p><pre class="fragment">void *ptr;
posix_memalign(&amp;ptr, sysconf(_SC_PAGESIZE), size);
</pre><p>Getting the page size on the command line (which is the size of _SC_PAGESIZE): </p><pre class="fragment">$ getconf PAGESIZE
4096
</pre><p>In this (and many) cases we have a 4096 byte boundary. Meaning the address of the allocated data must be the address of a page boundary. There is 4K between each boundary. A large amount of data can be allocated there but if a small amount of data is allocated then there is a large amount of unusable space due to the next allocation needing to also be on a 4K boundary.</p>
<p>Take the following allocations:</p>
<ol type="1">
<li>8 bytes page-aligned.</li>
<li>4 bytes page-aligned.</li>
</ol>
<p>Assuming One and Two are allocated next to each other. One allocates 8 bytes. Two will be aligned to the 4K boundary after One. A total of 8K of memory is reserved due to this. Only 12 bytes are actually needed but 8K is reserved. Since memory is now aligned in 4K blocks the total available memory space is greatly reduced. Not the amount of memory but the amount of allocations.</p>
<p>On a 32bit system only ~2GB of memory is available to a process. With 4K page-alignment allocations the amount usable memory is greatly reduced. This might be okay on a 64 bit system but will still be wasteful.</p>
<p>Also since Linux, since 3.18, has made madvise optional which severely limits its use.</p>
<h2>Conclusion </h2>
<p>Neither mlock nor madvise can be used on every malloc. It may be okay to use this selectively but in a general purpose library there is no way to truly know what is sensitive. For example M_list_str and M_hash_dict duplicate the strings they are given. There is no way for them to know that a particular string needs to be securely allocated.</p>
<h1>Additional External Security </h1>
<p>One option to add additional security is to create an encrypting wrapper around a list or hashtable:</p><ul>
<li>Use a different key for each hashtable.</li>
<li>Limit the life of a hashtable in order to rotate the key often.</li>
<li>Insert, wrapper will take the key and value. Encrypt them and store them in the hashtable.</li>
<li>Get, wrapper will take the key, encrypt it. Use that to look up the value. Decrypt the value. Return the value.</li>
</ul>
<p>This option further limits the amount of time sensitive data is stored in the clear in memory because the value in the hashtable is encrypted. The plain text data is only exposed as long as it is being actively used. This will further protect against memory scrapers.</p>
<p>It also, reduces the concern of swap and core dumps because the data is stored encrypted. Granted the key as well as the encrypted value could be stored on disk. However, it will still be difficult to determine what data is the key, and what set of data the key belongs to. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga24101a8e6170e3a987550f169d1472f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24101a8e6170e3a987550f169d1472f8">&#9670;&nbsp;</a></span>M_mem_str</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M_mem_str</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">haystack, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">haystack_len, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">needle&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__m__mem.html#gadbd0a455897f5844298509ab2fb6b26c">M_mem_mem</a>(haystack,haystack_len,needle,<a class="el" href="group__m__str__check.html#gabebfa875d1ada2b43f52b9344b0844d0">M_str_len</a>(needle) )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga99fafb67dd5410f9b3a6deca0e8586e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99fafb67dd5410f9b3a6deca0e8586e6">&#9670;&nbsp;</a></span>M_mem_strpos</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M_mem_strpos</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">haystack, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">haystack_len, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">needle, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">idx&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__m__mem.html#gaa54ac58d400979385777369c161a92fb">M_mem_mempos</a>(haystack,haystack_len,needle,<a class="el" href="group__m__str__check.html#gabebfa875d1ada2b43f52b9344b0844d0">M_str_len</a>(needle) ,idx)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaf095e6a5335edab1accd3a9dd15e7295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf095e6a5335edab1accd3a9dd15e7295">&#9670;&nbsp;</a></span>M_malloc_error_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef M_bool(* M_malloc_error_cb) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Error callback for handling malloc failure.</p>
<p>Can return M_TRUE to retry malloc. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf4b3922bed6ae588687f68cfca54a81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4b3922bed6ae588687f68cfca54a81d">&#9670;&nbsp;</a></span>M_malloc_register_errorcb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_malloc_register_errorcb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__mem.html#gaf095e6a5335edab1accd3a9dd15e7295">M_malloc_error_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a callback to be called when <a class="el" href="group__m__mem.html#ga630c33353895d6ecb3a060e7d82de153">M_malloc()</a>/M_realloc() returns a failure.</p>
<p>Up to 12 callbacks can be registered. They will be called from newest to oldest. If a callback returns M_TRUE callback processing will stop and malloc will be retried. If malloc fails again the callbacks processing will resume. Each callback will be run until either one returns success or all have returned failure.</p>
<p>Typically this will be used for external error reporting, or (more) graceful shutdown scenarios.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback to be called. This should not ever try to allocate memory as it will most likely fail.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success, M_FALSE on failure. The only failure reason currently is if the maximum number of registered callbacks has been reached. </dd></dl>

</div>
</div>
<a id="ga0592a2af948ccf908e9c7deeb8c140e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0592a2af948ccf908e9c7deeb8c140e1">&#9670;&nbsp;</a></span>M_malloc_deregister_errorcb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_malloc_deregister_errorcb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__m__mem.html#gaf095e6a5335edab1accd3a9dd15e7295">M_malloc_error_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deregister an allocation error callback</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>The callback to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if the callback was removed otherwise M_FALSE. M_FALSE means the callback is not currently registered. </dd></dl>

</div>
</div>
<a id="gacfd0e14508daeb82eb1c9097da6573bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfd0e14508daeb82eb1c9097da6573bc">&#9670;&nbsp;</a></span>M_malloc_clear_errorcb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_malloc_clear_errorcb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all user registered callbacks. The default abort callback is not cleared. </p>

</div>
</div>
<a id="ga630c33353895d6ecb3a060e7d82de153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga630c33353895d6ecb3a060e7d82de153">&#9670;&nbsp;</a></span>M_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* M_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate size bytes and returns pointer to allocated memory.</p>
<p>Retains information about the size of the allocation and must be released using <a class="el" href="group__m__mem.html#gac4b3c1d73d6efe2542f5e729b58a271d">M_free()</a>.</p>
<p>On failure registered error callbacks will be called and malloc will be repleted if any error callback return M_TRUE indicating malloc should be retried. If no callbacks return retry the application will abort. The callbacks will be run in reverse order they were registered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes of memory to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly allocated memory or NULL if the requested memory is unavailable. Memory must be released using <a class="el" href="group__m__mem.html#gac4b3c1d73d6efe2542f5e729b58a271d">M_free()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__mem.html#gac4b3c1d73d6efe2542f5e729b58a271d">M_free</a> </dd></dl>

</div>
</div>
<a id="ga9473a8ef59f5c85d37b3d35f461a82f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9473a8ef59f5c85d37b3d35f461a82f1">&#9670;&nbsp;</a></span>M_malloc_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* M_malloc_zero </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate size bytes and returns pointer to allocated memory and fills the memory with 0's.</p>
<p>Retains information about the size of the allocation and must be released using <a class="el" href="group__m__mem.html#gac4b3c1d73d6efe2542f5e729b58a271d">M_free()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes of memory to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly allocated memory or NULL if the requested memory is unavailable. Memory must be released using <a class="el" href="group__m__mem.html#gac4b3c1d73d6efe2542f5e729b58a271d">M_free()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__mem.html#gac4b3c1d73d6efe2542f5e729b58a271d">M_free</a> </dd></dl>

</div>
</div>
<a id="gac4b3c1d73d6efe2542f5e729b58a271d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4b3c1d73d6efe2542f5e729b58a271d">&#9670;&nbsp;</a></span>M_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void M_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release allocated memory.</p>
<p>Like libc free, but works with memory allocated by M_malloc class of functions to free allocated memory. Before being released, each byte of ptr is first set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>A pointer to a memory location to release returned by M_malloc like functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__mem.html#ga630c33353895d6ecb3a060e7d82de153">M_malloc</a> </dd>
<dd>
<a class="el" href="group__m__mem.html#ga9473a8ef59f5c85d37b3d35f461a82f1">M_malloc_zero</a> </dd>
<dd>
<a class="el" href="group__m__mem.html#ga508f28cb39b38e7abe77870e9ebe1d5c">M_realloc</a> </dd>
<dd>
<a class="el" href="group__m__mem.html#gacf4d3a27d93dd8b10ce405f9ed26f78f">M_memdup</a> </dd>
<dd>
<a class="el" href="group__m__mem.html#ga128a100f9252845e07cf83d90175b165">M_memdup_max</a> </dd></dl>

</div>
</div>
<a id="ga508f28cb39b38e7abe77870e9ebe1d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga508f28cb39b38e7abe77870e9ebe1d5c">&#9670;&nbsp;</a></span>M_realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* M_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resize an allocated memory block.</p>
<p>Like libc realloc, but works with memory allocated by M_malloc like functions. If ptr is unable to be resized, before being released, each byte of ptr is first set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>A pointer to a memory location to release/resize returned by M_malloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes of memory to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly allocated memory or NULL if the requested memory is zero in size or unavailable. Memory must be released using <a class="el" href="group__m__mem.html#gac4b3c1d73d6efe2542f5e729b58a271d">M_free()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__mem.html#gac4b3c1d73d6efe2542f5e729b58a271d">M_free</a> </dd></dl>

</div>
</div>
<a id="ga60edff6fa56d47f3d87f8dfe4da27f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60edff6fa56d47f3d87f8dfe4da27f8f">&#9670;&nbsp;</a></span>M_realloc_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* M_realloc_zero </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resize an allocated memory block and fill any extended allocated memory with 0's.</p>
<p>Like libc realloc, but works with memory allocated by M_malloc like functions. If ptr is unable to be resized, before being released, each byte of ptr is first set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>A pointer to a memory location to release/resize returned by M_malloc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes of memory to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly allocated memory or NULL if the requested memory is zero in size or unavailable. Memory must be released using <a class="el" href="group__m__mem.html#gac4b3c1d73d6efe2542f5e729b58a271d">M_free()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__mem.html#gac4b3c1d73d6efe2542f5e729b58a271d">M_free</a> </dd></dl>

</div>
</div>
<a id="gacf4d3a27d93dd8b10ce405f9ed26f78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf4d3a27d93dd8b10ce405f9ed26f78f">&#9670;&nbsp;</a></span>M_memdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* M_memdup </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate and copy size bytes from src to the newly allocated space.</p>
<p>src should be at least size memory area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Memory area to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes of memory to allocate and copy from src.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly allocated memory or NULL if the requested memory is unavailable. Memory must be released with <a class="el" href="group__m__mem.html#gac4b3c1d73d6efe2542f5e729b58a271d">M_free()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__mem.html#gac4b3c1d73d6efe2542f5e729b58a271d">M_free</a> </dd></dl>

</div>
</div>
<a id="ga128a100f9252845e07cf83d90175b165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga128a100f9252845e07cf83d90175b165">&#9670;&nbsp;</a></span>M_memdup_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* M_memdup_max </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_alloc_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate at minimum min_alloc_size bytes, but copy no more than size bytes from ptr to the newly allocated space.</p>
<p>If size is larger than min_alloc_size, then size bytes will be allocated. src should be at least size memory area or NULL is returned.</p>
<p>This function behaves like M_malloc(size) when called M_memdup_max(NULL,0,size).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Memory area to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes of memory to allocate and copy from src. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_alloc_size</td><td>The minimum size of the returned allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly allocated memory or NULL if the requested memory is unavailable or if src is NULL but has positive * size. Memory must be released with <a class="el" href="group__m__mem.html#gac4b3c1d73d6efe2542f5e729b58a271d">M_free()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__m__mem.html#gac4b3c1d73d6efe2542f5e729b58a271d">M_free</a> </dd></dl>

</div>
</div>
<a id="ga12f125e84df307ef19f5d418b734202c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12f125e84df307ef19f5d418b734202c">&#9670;&nbsp;</a></span>M_mem_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* M_mem_set </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>The memory to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The value to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The length of the memory segement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to s. </dd></dl>

</div>
</div>
<a id="gad3f4ea473f3ca4bbc27f584cb13e08f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3f4ea473f3ca4bbc27f584cb13e08f1">&#9670;&nbsp;</a></span>M_mem_move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* M_mem_move </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy memory area.</p>
<p>This function behaves like memcpy, but handles NULL gracefully.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dst</td><td>Memory location to copy to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Memory location to copy from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to dst. </dd></dl>

</div>
</div>
<a id="ga81b9bd497064d6d9b75239014669d231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81b9bd497064d6d9b75239014669d231">&#9670;&nbsp;</a></span>M_mem_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* M_mem_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy memory area.</p>
<p>This function behaves like memcpy, but handles NULL gracefully.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dst</td><td>Memory location to copy to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Memory location to copy from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to dst. </dd></dl>

</div>
</div>
<a id="ga9062ab80ddb9acb799ce5adeca0c44e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9062ab80ddb9acb799ce5adeca0c44e6">&#9670;&nbsp;</a></span>M_mem_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_mem_eq </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare memory segments.</p>
<p>This is done in a constant-time manner to prevent against timing related attacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m1</td><td>Memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m2</td><td>Memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Length of memory to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if equal, M_FALSE if not. </dd></dl>

</div>
</div>
<a id="ga11a800ea6a534a0cc7c5d21951401502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11a800ea6a534a0cc7c5d21951401502">&#9670;&nbsp;</a></span>M_mem_cmpsort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int M_mem_cmpsort </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A wrapper around memcmp that is NULL safe.</p>
<p>NOTE: this is not a constant-time comparison and thus should ONLY be used for sorting such as within qsort()!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m1</td><td>Memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size1</td><td>Size of m1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m2</td><td>Memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size2</td><td>Size of m2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer less than, equal to, or greater than zero if m1 is less than, equal, or greater than m2 respectively </dd></dl>

</div>
</div>
<a id="ga28a693c14e182dbf122ccdd062588062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28a693c14e182dbf122ccdd062588062">&#9670;&nbsp;</a></span>M_mem_chr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* M_mem_chr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint8&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find first occurrence of b in s.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The memory area to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The byte to search the memory area for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The size of the memory area to search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first occurence of b in s or NULL if not found or s is NULL or is 0. </dd></dl>

</div>
</div>
<a id="ga19335a606e4f50b52e9b7a47bd836f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19335a606e4f50b52e9b7a47bd836f7a">&#9670;&nbsp;</a></span>M_mem_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_mem_contains </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>haystack_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>needle_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if needle exists in haystack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack</td><td>Memory to search in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack_len</td><td>The size in bytes of haystack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">needle</td><td>Memory to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">needle_len</td><td>The size in bytes of needle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if needle exists in haystack or needle_len is 0, M_FALSE otherwise. </dd></dl>

</div>
</div>
<a id="gadbd0a455897f5844298509ab2fb6b26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbd0a455897f5844298509ab2fb6b26c">&#9670;&nbsp;</a></span>M_mem_mem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* M_mem_mem </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>haystack_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>needle_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find first occurring bytes needle of length needle_len in haystack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack</td><td>Memory to search in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack_len</td><td>The size in bytes of haystack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">needle</td><td>Memory to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">needle_len</td><td>The size in bytes of needle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to first occurrence of needle in haystack or NULL if not found or haystack is NULL or haystack_len is 0. </dd></dl>

</div>
</div>
<a id="ga093cdece4ecd385dcac6cddff35e216d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga093cdece4ecd385dcac6cddff35e216d">&#9670;&nbsp;</a></span>M_mem_rmem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* M_mem_rmem </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>haystack_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>needle_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find last occurring bytes needle of length needle_len in haystack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack</td><td>Memory to search in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack_len</td><td>The size in bytes of haystack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">needle</td><td>Memory to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">needle_len</td><td>The size in bytes of needle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to last occurrence of needle in haystack or NULL if not found or haystack is NULL or haystack_len is 0. </dd></dl>

</div>
</div>
<a id="ga66c1e2ed92d892c908ced791416beed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66c1e2ed92d892c908ced791416beed2">&#9670;&nbsp;</a></span>M_mem_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* M_mem_str </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>haystack_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find first occurring string needle in haystack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack</td><td>Memory to search in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack_len</td><td>The size in bytes of haystack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">needle</td><td>Memory to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to first occurrence of needle in haystack or NULL if not found or haystack is NULL. </dd></dl>

</div>
</div>
<a id="gaa54ac58d400979385777369c161a92fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa54ac58d400979385777369c161a92fb">&#9670;&nbsp;</a></span>M_mem_mempos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_mem_mempos </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>haystack_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>needle_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find index of first occurring bytes needle of length needle_len in haystack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack</td><td>Memory to search in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack_len</td><td>The size in bytes of haystack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">needle</td><td>Memory to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">needle_len</td><td>The size in bytes of needle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">idx</td><td>The index of first occurrence of needle in haystack. Optional, pass NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE if found, M_FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ga6dbc87988f4345efccbb3eee092bc17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dbc87988f4345efccbb3eee092bc17b">&#9670;&nbsp;</a></span>M_mem_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t M_mem_count </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M_uint8&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count the number of occurrences of byte b in memory area s of length s_len</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Pointer to the memory area to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s_len</td><td>The size of the memory area s. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The byte value to count occurrences of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a11dc1aa0bc31f10a1289043464f966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a11dc1aa0bc31f10a1289043464f966">&#9670;&nbsp;</a></span>M_mem_calc_lrc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char M_mem_calc_lrc </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate an LRC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Pointer to the memory area to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s_len</td><td>The size of the memory area s.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LRC </dd></dl>

</div>
</div>
<a id="ga3c4c5a89a3aaac19e65287111895c213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c4c5a89a3aaac19e65287111895c213">&#9670;&nbsp;</a></span>M_mem_calc_crc8_ccitt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_uint8 M_mem_calc_crc8_ccitt </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate a CRC (CRC-8/CCITT).</p>
<p>This is an 8-bit cyclic redundancy check (CRC), using the CCITT standard polynomial: <code>x^8 + x^2 + x + 1</code>. It's calculated using an initial value of zero.</p>
<p>Implementation is based on public-domain code that can be found here: <a href="https://www.3dbrew.org/wiki/CRC-8-CCITT">https://www.3dbrew.org/wiki/CRC-8-CCITT</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Pointer to data to perform check on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s_len</td><td>Size of memory area s. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CRC value. </dd></dl>

</div>
</div>
<a id="ga7d13486661a48da9e476aac1eaf70ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d13486661a48da9e476aac1eaf70ea0">&#9670;&nbsp;</a></span>M_mem_swap_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">M_bool M_mem_swap_bytes </td>
          <td>(</td>
          <td class="paramtype">M_uint8 *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap byes between positions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">s</td><td>Buffer with data to swap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s_len</td><td>size of s. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx1</td><td>Index to swap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx2</td><td>Index to swap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M_TRUE on success. Otherwise M_FALSE. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Feb 20 2018 12:46:12 for Mstdlib-1.0.0 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
