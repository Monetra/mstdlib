.TH "m_str_convert" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_str_convert
.SH SYNOPSIS
.br
.PP
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_str_int_retval_t\fP { \fBM_STR_INT_SUCCESS\fP = 0, \fBM_STR_INT_OVERFLOW\fP = 1, \fBM_STR_INT_INVALID\fP = 2 }"
.br
.ti -1c
.RI "enum \fBM_str_hexdump_flags\fP { \fBM_STR_HEXDUMP_NONE\fP = 0, \fBM_STR_HEXDUMP_DECLEN\fP = 1 << 0, \fBM_STR_HEXDUMP_NOASCII\fP = 1 << 1, \fBM_STR_HEXDUMP_HEADER\fP = 1 << 2, \fBM_STR_HEXDUMP_NOLEN\fP = 1 << 3, \fBM_STR_HEXDUMP_CRLF\fP = 1 << 4, \fBM_STR_HEXDUMP_UPPER\fP = 1 << 5, \fBM_STR_HEXDUMP_NOSECTS\fP = 1 << 6 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "long \fBM_atofi100\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_int64 \fBM_atofi_prec\fP (const char *s, int impliedDecimals) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_int64 \fBM_str_to_int64\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_uint64 \fBM_str_to_uint64\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "\fBM_str_int_retval_t\fP \fBM_str_to_int64_ex\fP (const char *s, size_t len, unsigned char base, M_int64 *val, const char **endptr)"
.br
.ti -1c
.RI "\fBM_str_int_retval_t\fP \fBM_str_to_uint64_ex\fP (const char *s, size_t len, unsigned char base, M_uint64 *val, const char **endptr)"
.br
.ti -1c
.RI "\fBM_str_int_retval_t\fP \fBM_str_to_int32_ex\fP (const char *s, size_t len, unsigned char base, M_int32 *val, const char **endptr)"
.br
.ti -1c
.RI "\fBM_str_int_retval_t\fP \fBM_str_to_uint32_ex\fP (const char *s, size_t len, unsigned char base, M_uint32 *val, const char **endptr)"
.br
.ti -1c
.RI "M_int32 \fBM_str_to_int32\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_uint32 \fBM_str_to_uint32\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "char * \fBM_str_dot_money_out\fP (const char *amount)"
.br
.ti -1c
.RI "char * \fBM_str_hexdump\fP (int flags, size_t bytes_per_line, const char *line_prefix, const unsigned char *data, size_t data_len)"
.br
.in -1c
.SH "Detailed Description"
.PP 
String Conversion 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_str_int_retval_t\fP"
Possible return codes for integer conversion primitives 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_STR_INT_SUCCESS \fP\fP
Successful conversion 
.TP
\fB\fIM_STR_INT_OVERFLOW \fP\fP
Overflow 
.TP
\fB\fIM_STR_INT_INVALID \fP\fP
Invalid Characters 
.SS "enum \fBM_str_hexdump_flags\fP"
Hex dump flags 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_STR_HEXDUMP_NONE \fP\fP
Defaults 
.TP
\fB\fIM_STR_HEXDUMP_DECLEN \fP\fP
Default is length in hex (address) format, print in decimal format instead 
.TP
\fB\fIM_STR_HEXDUMP_NOASCII \fP\fP
Disable dumping of ASCII representation trailing the hexdump 
.TP
\fB\fIM_STR_HEXDUMP_HEADER \fP\fP
Add a header above each column of output 
.TP
\fB\fIM_STR_HEXDUMP_NOLEN \fP\fP
Omit the length indicator 
.TP
\fB\fIM_STR_HEXDUMP_CRLF \fP\fP
Use CRLF newlines (DOS style) 
.TP
\fB\fIM_STR_HEXDUMP_UPPER \fP\fP
Output hex digits as uppercase 
.TP
\fB\fIM_STR_HEXDUMP_NOSECTS \fP\fP
Do not put additional emphasis on 8-byte segments 
.SH "Function Documentation"
.PP 
.SS "long M_atofi100 (const char * s)"
Convert a string representing money (a fractional decimal amount) to an integer number of cents\&. Fractional amounts are rounded to the nearest cent\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP String containing a floating point (2 decimal places) money representation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Long integer, rounded if there are floating point errors, with amount of cents\&. 
.RE
.PP

.SS "M_int64 M_atofi_prec (const char * s, int impliedDecimals)"
Convert a floating point number into a 64bit integer using arbitrary precision as defined by impliedDecimals\&.
.PP
For instance, if impliedDecimals is 5, and 12\&.34 is passed, the resulting value would be 1234000\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP string to convert to decimal 
.br
\fIimpliedDecimals\fP Number of implied decimals resulting output should have
.RE
.PP
\fBReturns:\fP
.RS 4
64bit integer representing number from s with implied decimals\&. 
.RE
.PP

.SS "M_int64 M_str_to_int64 (const char * s)"
Interpret a string as an ascii numeric\&. String may begin with whitespace which will be ignored, then an optional + or - sign\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Determined integer\&. On failure will return 0 which cannot be differentiated from a legitimate 0\&. 
.RE
.PP

.SS "M_uint64 M_str_to_uint64 (const char * s)"
Interpret a string as an ascii numeric\&. String may begin with whitespace which will be ignored, then an optional + or - sign\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Determined integer\&. On failure will return 0 which cannot be differentiated from a legitimate 0\&. 
.RE
.PP

.SS "\fBM_str_int_retval_t\fP M_str_to_int64_ex (const char * s, size_t len, unsigned char base, M_int64 * val, const char ** endptr)"
Interpret a string as an ascii numeric\&. String may begin with whitespace which will be ignored, then an optional + or - sign\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fIlen\fP Maximum length of given string to parse\&. 
.br
\fIbase\fP Valid range 2 - 36\&. 0 to autodetect based on input (0x = hex, 0 = octal, anything else is decimal)\&. 
.br
\fIval\fP Integer to store result\&. 
.br
\fIendptr\fP Pointer to store the end of the parsed string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
One of M_str_int_retval_t return codes\&. 
.RE
.PP

.SS "\fBM_str_int_retval_t\fP M_str_to_uint64_ex (const char * s, size_t len, unsigned char base, M_uint64 * val, const char ** endptr)"
Interpret a string as an ascii numeric\&. String may begin with whitespace which will be ignored, then an optional + or - sign\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fIlen\fP Maximum length of given string to parse\&. 
.br
\fIbase\fP Valid range 2 - 36\&. 0 to autodetect based on input (0x = hex, 0 = octal, anything else is decimal)\&. 
.br
\fIval\fP Integer to store result\&. 
.br
\fIendptr\fP Pointer to store the end of the parsed string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
One of M_str_int_retval_t return codes\&. 
.RE
.PP

.SS "\fBM_str_int_retval_t\fP M_str_to_int32_ex (const char * s, size_t len, unsigned char base, M_int32 * val, const char ** endptr)"
Interpret a string as an ascii numeric\&. String may begin with whitespace which will be ignored, then an optional + or - sign\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fIlen\fP Maximum length of given string to parse\&. 
.br
\fIbase\fP Valid range 2 - 36\&. 0 to autodetect based on input (0x = hex, 0 = octal, anything else is decimal)\&. 
.br
\fIval\fP Integer to store result\&. 
.br
\fIendptr\fP Pointer to store the end of the parsed string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
One of M_str_int_retval_t return codes\&. 
.RE
.PP

.SS "\fBM_str_int_retval_t\fP M_str_to_uint32_ex (const char * s, size_t len, unsigned char base, M_uint32 * val, const char ** endptr)"
Interpret a string as an ascii numeric\&. String may begin with whitespace which will be ignored, then an optional + or - sign\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fIlen\fP Maximum length of given string to parse\&. 
.br
\fIbase\fP Valid range 2 - 36\&. 0 to autodetect based on input (0x = hex, 0 = octal, anything else is decimal)\&. 
.br
\fIval\fP Integer to store result 
.br
\fIendptr\fP Pointer to store the end of the parsed string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
One of M_str_int_retval_t return codes\&. 
.RE
.PP

.SS "M_int32 M_str_to_int32 (const char * s)"
Interpret a string as an ascii numeric\&. String may begin with whitespace which will be ignored, then an optional + or - sign\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
determined integer\&. On failure will return 0 which cannot be differentiated from a legitimate 0\&. 
.RE
.PP

.SS "M_uint32 M_str_to_uint32 (const char * s)"
Interpret a string as an ascii numeric\&. String may begin with whitespace which will be ignored, then an optional + or - sign\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
determined integer\&. On failure will return 0 which cannot be differentiated from a legitimate 0\&. 
.RE
.PP

.SS "char* M_str_dot_money_out (const char * amount)"
Verify and convert the amount so it always has 2 decimal digits\&.
.PP
Example: 1 for $1 and turns it into 1\&.00\&. 1\&.1 for $1\&.10 and turns it into 1\&.10\&.
.PP
\fBParameters:\fP
.RS 4
\fIamount\fP Amount to verify/convert\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Amount with decimal and two decimal digits\&. Or NULL on error\&. 
.RE
.PP

.SS "char* M_str_hexdump (int flags, size_t bytes_per_line, const char * line_prefix, const unsigned char * data, size_t data_len)"
Generate a hex dump format of binary data meant to be human-readable, or imported via various hex-dump conversion tools such as Text2pcap\&. 
.PP
\fBParameters:\fP
.RS 4
\fIflags\fP one or more enum M_str_hexdump_flags 
.br
\fIbytes_per_line\fP Number of bytes represented per line\&. If zero is used, defaults to 16 
.br
\fIline_prefix\fP Prefix each line of the hex dump with the given data\&. 
.br
\fIdata\fP Binary data to be dumped 
.br
\fIdata_len\fP length of binary data to be dumped 
.RE
.PP
\fBReturns:\fP
.RS 4
Allocated string representing the hex dump\&. Must be \fBM_free()\fP'd by the caller\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
