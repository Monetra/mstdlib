.TH "m_threadpool" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_threadpool
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct M_threadpool \fBM_threadpool_t\fP"
.br
.ti -1c
.RI "typedef struct M_threadpool_parent \fBM_threadpool_parent_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_threadpool_t\fP * \fBM_threadpool_create\fP (size_t min_threads, size_t max_threads, M_uint64 idle_time_ms, size_t queue_max_size)"
.br
.ti -1c
.RI "void \fBM_threadpool_destroy\fP (\fBM_threadpool_t\fP *pool)"
.br
.ti -1c
.RI "\fBM_threadpool_parent_t\fP * \fBM_threadpool_parent_create\fP (\fBM_threadpool_t\fP *pool)"
.br
.ti -1c
.RI "M_bool \fBM_threadpool_parent_destroy\fP (\fBM_threadpool_parent_t\fP *parent)"
.br
.ti -1c
.RI "void \fBM_threadpool_dispatch\fP (\fBM_threadpool_parent_t\fP *parent, void(*task)(void *), void **task_args, size_t num_tasks)"
.br
.ti -1c
.RI "size_t \fBM_threadpool_available_slots\fP (const \fBM_threadpool_t\fP *pool)"
.br
.ti -1c
.RI "void \fBM_threadpool_wait_available_thread\fP (\fBM_threadpool_parent_t\fP *parent)"
.br
.ti -1c
.RI "size_t \fBM_threadpool_num_threads\fP (const \fBM_threadpool_t\fP *pool)"
.br
.ti -1c
.RI "void \fBM_threadpool_parent_wait\fP (\fBM_threadpool_parent_t\fP *parent)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Implementation of a thread pool for having a limited the number of threads available to workers\&. Threads in the pool will only be destroyed when the pool is destroyed\&. A maximum number of threads will be created by the pool\&. Workers are assigned to parents which can be used to logically separate workers by tasks\&.
.PP
Example:
.PP
.PP
.nf
static M_uint32 count = 0;

static void pool_task(void *arg)
{
    (void)arg;
    M_atomic_inc_u32(&count);
}

int main(int argc, char **argv)
{
    M_threadpool_t        *pool;
    M_threadpool_parent_t *parent;
    char                   args[32];

    M_mem_set(args, 0, sizeof(args));

    pool   = M_threadpool_create(16, 16, 0, SIZE_MAX);
    parent = M_threadpool_parent_create(pool);

    M_threadpool_dispatch(parent, pool_task, (void **)&args, sizeof(args));
    M_threadpool_parent_wait(parent);
    
    M_threadpool_parent_destroy(parent);
    M_threadpool_destroy(pool);

    M_printf("count='%u'\n", count);

    return 0;
} 
.fi
.PP
 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct M_threadpool \fBM_threadpool_t\fP"

.SS "typedef struct M_threadpool_parent \fBM_threadpool_parent_t\fP"

.SH "Function Documentation"
.PP 
.SS "\fBM_threadpool_t\fP* M_threadpool_create (size_t min_threads, size_t max_threads, M_uint64 idle_time_ms, size_t queue_max_size)"
Initializes a new threadpool and spawns the minimum number of threads requested\&.
.PP
\fBParameters:\fP
.RS 4
\fImin_threads\fP Minimum number of threads to spawn, 0 to not pre-spawn any\&. 
.br
\fImax_threads\fP Maximum number of threads to spawn, any number above the min_threads number will be spawned on demand, and idle threads will be shutdown after the specified idle time\&. Must be greater than 0\&. 
.br
\fIidle_time_ms\fP Number of milliseconds a thread can be idle for before it is destroyed when the total thread count is above min_threads\&. If min_threads and max_threads are the same value, this parameter is ignored\&. Use M_UINT64_MAX to never terminate an idle thread, or use 0 to never allow idle threads\&. 
.br
\fIqueue_max_size\fP If 0, will calculate a desirable queue size based on the maximum thread count\&. Otherwise, must be at least the size of the thread pool\&. It often makes sense to have the queue larger than the threadpool size to prevent the threads from sleeping\&. When inserting into the queue, if there are no available slots the \fBM_threadpool_dispatch()\fP function will block\&. If blocking is not desirable, use SIZE_MAX to allow an unbounded number of queue slots\&.
.RE
.PP
\fBReturns:\fP
.RS 4
initialized threadpool or NULL on failure 
.RE
.PP

.SS "void M_threadpool_destroy (\fBM_threadpool_t\fP * pool)"
Shuts down the thread pool, waits for all threads to exit\&.
.PP
\fBParameters:\fP
.RS 4
\fIpool\fP initialized threadpool\&. 
.RE
.PP

.SS "\fBM_threadpool_parent_t\fP* M_threadpool_parent_create (\fBM_threadpool_t\fP * pool)"
Creates a new parent/user/consumer of the threadpool\&.
.PP
This is the handle used to insert tasks and wait for task completion specific to the consumer\&.
.PP
It is safe to share this handle across multiple threads if convenient as long as it is guaranteed to not be destroyed until all consumers are done using it\&. If sharing across multiple threads, it probably would mean you would not be using \fBM_threadpool_parent_wait()\fP from multiple threads simultaneously\&.
.PP
\fBParameters:\fP
.RS 4
\fIpool\fP Initialized thread pool\&.
.RE
.PP
\fBReturns:\fP
.RS 4
initialized parent/user/consumer handle\&. 
.RE
.PP

.SS "M_bool M_threadpool_parent_destroy (\fBM_threadpool_parent_t\fP * parent)"
Frees the parent handle\&.
.PP
There must be no oustanding tasks prior to calling this\&. Call \fBM_threadpool_parent_wait()\fP first if unsure to wait on all tasks to complete\&.
.PP
\fBParameters:\fP
.RS 4
\fIparent\fP Initialized parent handle\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_FALSE if there are tasks remaining, M_TRUE if successfully cleaned up\&. 
.RE
.PP

.SS "void M_threadpool_dispatch (\fBM_threadpool_parent_t\fP * parent, void(*)(void *) task, void ** task_args, size_t num_tasks)"
Dispatch a task or set of tasks to the threadpool\&.
.PP
Requires a callback function to do the processing and an argument that is passed to the function\&. There is no way to retrieve a return value from the task, so the argument passed to the task should hold a result parameter if it is necessary to know the completion status\&. Multiple tasks may be queued simultaneously\&.
.PP
This may take a while to complete if there are no queue slots available\&.
.PP
\fBParameters:\fP
.RS 4
\fIparent\fP Initialized parent handle\&. 
.br
\fItask\fP Task callback\&. 
.br
\fItask_args\fP Argument array to pass to each task (one per task)\&. 
.br
\fInum_tasks\fP total number of tasks being enqueued\&. 
.RE
.PP

.SS "size_t M_threadpool_available_slots (const \fBM_threadpool_t\fP * pool)"
Count the number of queue slots available to be enqueued for a threadpool\&.
.PP
\fBParameters:\fP
.RS 4
\fIpool\fP initialized threadpool\&. 
.RE
.PP

.SS "void M_threadpool_wait_available_thread (\fBM_threadpool_parent_t\fP * parent)"
Wait for a thread to become available for processing tasks\&.
.PP
This explicitly waits for a THREAD and NOT an available queue slot which there could be available slots\&. This is meant as an optimization in some instances where you want to ensure you enqueue some things together, especially if you're trying to manage SQL locks for tasks being performed\&. Typically though, this function would never be used\&.
.PP
\fBParameters:\fP
.RS 4
\fIparent\fP Initialized parent handle\&. 
.RE
.PP

.SS "size_t M_threadpool_num_threads (const \fBM_threadpool_t\fP * pool)"
Get the current count of the number of threads in the thread pool\&.
.PP
\fBParameters:\fP
.RS 4
\fIpool\fP Initialized pool handle\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
count of threads 
.RE
.PP

.SS "void M_threadpool_parent_wait (\fBM_threadpool_parent_t\fP * parent)"
Wait for all queued tasks to complete then return\&.
.PP
This is a blocking function with no return value\&. It is not recommended to call this from mulitiple threads simultaneously\&.
.PP
\fBParameters:\fP
.RS 4
\fIparent\fP the initialized parent/user/consumer handle\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
