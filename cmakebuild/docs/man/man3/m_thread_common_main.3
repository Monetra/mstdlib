.TH "m_thread_common_main" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_thread_common_main
.SH SYNOPSIS
.br
.PP
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_thread_model_t\fP { \fBM_THREAD_MODEL_INVALID\fP = -1, \fBM_THREAD_MODEL_NATIVE\fP = 0, \fBM_THREAD_MODEL_COOP\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "M_bool \fBM_thread_init\fP (\fBM_thread_model_t\fP model)"
.br
.ti -1c
.RI "M_bool \fBM_thread_active_model\fP (\fBM_thread_model_t\fP *model, const char **model_name)"
.br
.ti -1c
.RI "M_bool \fBM_thread_destructor_insert\fP (void(*destructor)(void))"
.br
.ti -1c
.RI "void \fBM_thread_destructor_remove\fP (void(*destructor)(void))"
.br
.ti -1c
.RI "void \fBM_library_cleanup\fP (void)"
.br
.ti -1c
.RI "void \fBM_library_cleanup_register\fP (void(*cleanup_cb)(void *arg), void *arg)"
.br
.ti -1c
.RI "size_t \fBM_thread_count\fP (void)"
.br
.ti -1c
.RI "size_t \fBM_thread_num_cpu_cores\fP (void)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Thread System Initialization, Destruction, and Information 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_thread_model_t\fP"
Thread model\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_THREAD_MODEL_INVALID \fP\fP
Invalid/no model\&. 
.TP
\fB\fIM_THREAD_MODEL_NATIVE \fP\fP
System's native thread model\&. 
.TP
\fB\fIM_THREAD_MODEL_COOP \fP\fP
Cooperative threads\&. 
.SH "Function Documentation"
.PP 
.SS "M_bool M_thread_init (\fBM_thread_model_t\fP model)"
Initialize the thread model (system)\&.
.PP
This should be called before any other thread function is used\&. This will initialize the specified threading system\&. If this is not called before a thread function is used then the native threading model will be automatically initialized\&.
.PP
Only one thread model can be use at any given time\&.
.PP
\fBParameters:\fP
.RS 4
\fImodel\fP The thread model that should be used for threading\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the model was successfully initialized\&. Otherwise M_FALSE\&. This can fail if called after a model has already been initialized\&. 
.RE
.PP

.SS "M_bool M_thread_active_model (\fBM_thread_model_t\fP * model, const char ** model_name)"
Get the active thread model\&.
.PP
\fBParameters:\fP
.RS 4
\fImodel\fP The active model\&. 
.br
\fImodel_name\fP The textual name of the model\&. This will provide descriptive information such as what is the underlying native threading model\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if a thread model is active otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_thread_destructor_insert (void(*)(void) destructor)"
Adds a function to be called each time a thread finishes\&.
.PP
Some libraries (OpenSSL in particular) keep their own per thread memory store\&. This allows registering functions to be called to handle this situation\&.
.PP
OpenSSL keeps a per-thread error state which must be cleaned up at thread destruction otherwise it will leak memory like crazy\&. Wrap ERR_remove_state(0); in a function that doesn't take any arugments, then register the function and this problem is solved\&.
.PP
Registered functions will be called in the order they were added\&.
.PP
\fBParameters:\fP
.RS 4
\fIdestructor\fP The function to register\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the function was added\&. Otherwise M_FALSE\&. This can fail if the function was already registered\&. A function can only be registered once\&. 
.RE
.PP

.SS "void M_thread_destructor_remove (void(*)(void) destructor)"
Remove a function from the list of function to be called each time a thread finished\&.
.PP
\fBParameters:\fP
.RS 4
\fIdestructor\fP The function to remove\&. 
.RE
.PP

.SS "void M_library_cleanup (void)"
Thread-safe library cleanup\&.
.PP
Cleans up any initialized static/global members by the library\&. Useful to be called at the end of program execution to free memory or other resources, especially if running under a leak checker such as Valgrind\&. 
.SS "void M_library_cleanup_register (void(*)(void *arg) cleanup_cb, void * arg)"
Registers a callback to be called during \fBM_library_cleanup()\fP\&.
.PP
There is no way to 'unregister' a callback, so it must be ensured the callback will remain valid until the end of program execution\&.
.PP
\fBParameters:\fP
.RS 4
\fIcleanup_cb\fP Callback to call for cleanup 
.br
\fIarg\fP Optional argument to be passed to the callback\&. 
.RE
.PP

.SS "size_t M_thread_count (void)"
Get the number of actively running threads\&.
.PP
This count does not include the threads that have finished but are still joinable\&.
.PP
\fBReturns:\fP
.RS 4
Thread count\&. 
.RE
.PP

.SS "size_t M_thread_num_cpu_cores (void)"
Retrieve the count of CPU cores that are online and usable\&. When using cooperative threading, only 1 cpu core is usable\&.
.PP
\fBReturns:\fP
.RS 4
count of cores or 0 on failure\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
