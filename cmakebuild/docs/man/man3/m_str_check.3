.TH "m_str_check" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_str_check
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "const char * \fBM_str_safe\fP (const char *s)"
.br
.ti -1c
.RI "M_bool \fBM_str_isempty\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_istrue\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "size_t \fBM_str_len\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "size_t \fBM_str_len_max\fP (const char *s, size_t max) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_ispredicate\fP (const char *s, \fBM_chr_predicate_func\fP pred)"
.br
.ti -1c
.RI "M_bool \fBM_str_isalnum\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_isalnumsp\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_isalpha\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_isalphasp\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_isspace\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_isgraph\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_isprint\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_ishex\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_isnum\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_isdec\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_ismoney\fP (const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_ischarset\fP (const char *str, const char *charset)"
.br
.ti -1c
.RI "M_bool \fBM_str_isnotcharset\fP (const char *str, const char *charset)"
.br
.ti -1c
.RI "M_bool \fBM_str_isstr\fP (const unsigned char *s, size_t len)"
.br
.ti -1c
.RI "M_bool \fBM_str_ispredicate_max\fP (const char *s, size_t max, \fBM_chr_predicate_func\fP pred)"
.br
.ti -1c
.RI "M_bool \fBM_str_isalnum_max\fP (const char *s, size_t max) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_isalnumsp_max\fP (const char *s, size_t max) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_isalpha_max\fP (const char *s, size_t max) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_isalphasp_max\fP (const char *s, size_t max) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_isspace_max\fP (const char *s, size_t max) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_isgraph_max\fP (const char *s, size_t max) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_isprint_max\fP (const char *s, size_t max) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_ishex_max\fP (const char *s, size_t max) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_isnum_max\fP (const char *s, size_t max) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_isdec_max\fP (const char *s, size_t max) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "int \fBM_str_cmpsort\fP (const char *s1, const char *s2) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "int \fBM_str_cmpsort_max\fP (const char *s1, const char *s2, size_t max) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "int \fBM_str_casecmpsort\fP (const char *s1, const char *s2) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "int \fBM_str_casecmpsort_max\fP (const char *s1, const char *s2, size_t max) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_eq_max\fP (const char *s1, const char *s2, size_t max)"
.br
.ti -1c
.RI "M_bool \fBM_str_eq\fP (const char *s1, const char *s2)"
.br
.ti -1c
.RI "M_bool \fBM_str_caseeq_max\fP (const char *s1, const char *s2, size_t max)"
.br
.ti -1c
.RI "M_bool \fBM_str_caseeq\fP (const char *s1, const char *s2)"
.br
.ti -1c
.RI "M_bool \fBM_str_eq_end\fP (const char *s1, const char *s2)"
.br
.ti -1c
.RI "M_bool \fBM_str_caseeq_end\fP (const char *s1, const char *s2)"
.br
.ti -1c
.RI "M_bool \fBM_str_eq_start\fP (const char *s1, const char *s2)"
.br
.ti -1c
.RI "M_bool \fBM_str_caseeq_start\fP (const char *s1, const char *s2)"
.br
.ti -1c
.RI "M_bool \fBM_str_pattern_match\fP (const char *pattern, const char *s) M_WARN_UNUSED_RESULT"
.br
.ti -1c
.RI "M_bool \fBM_str_case_pattern_match\fP (const char *pattern, const char *s) M_WARN_UNUSED_RESULT"
.br
.in -1c
.SH "Detailed Description"
.PP 
String Checking and Validation 
.SH "Function Documentation"
.PP 
.SS "const char* M_str_safe (const char * s)"
Ensure a NULL will not be used as a string\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
'' if s is NULL or s\&. 
.RE
.PP

.SS "M_bool M_str_isempty (const char * s)"
Determines if the string is considered empty\&.
.PP
A string is considered empty if it is NULL or has a 0 length\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if it is empty\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_istrue (const char * s)"
Check if a string is considered true\&.
.PP
A string is considered true when it equals any of the following (case intensive):
.IP "\(bu" 2
t
.IP "\(bu" 2
true
.IP "\(bu" 2
y
.IP "\(bu" 2
yes
.IP "\(bu" 2
1
.IP "\(bu" 2
on
.PP
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if it is considered true\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "size_t M_str_len (const char * s)"
A wrapper around strlen that treats NULL as a string with length 0\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Length of string\&. 
.RE
.PP

.SS "size_t M_str_len_max (const char * s, size_t max)"
A wrapper around strlen that treats NULL as a string with length 0, but returns at most max bytes\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fImax\fP Maximum number of bytes to return\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Length of string up to max bytes\&. 
.RE
.PP

.SS "M_bool M_str_ispredicate (const char * s, \fBM_chr_predicate_func\fP pred)"
Determines if all characters of string \fCs\fP satisfy predicate \fCpred\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fIpred\fP Predicate to apply to each character\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_isalnum (const char * s)"
Check whether each character of a string s are alphanumeric\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_isalnumsp (const char * s)"
Check whether each character of a string s ar alphanumeric or contains spaces\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_isalpha (const char * s)"
Check whether each character of a string s is alpha\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_isalphasp (const char * s)"
Check whether each character of a string s is alpha or contains spaces\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_isspace (const char * s)"
Check whether each character of a string s is a space\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_isgraph (const char * s)"
Check whether each character of a string s is printable except space\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_isprint (const char * s)"
Check whether each character of a string s is printable\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_ishex (const char * s)"
Check whether each character of a string s is a hexadecimal digit\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. otherwise M_TRUE 
.RE
.PP

.SS "M_bool M_str_isnum (const char * s)"
Check whether each character of a string s is a decimal digit 0-9\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_isdec (const char * s)"
Check whether each character of a string s is a decimal digit 0-9 or contains a decimal\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_ismoney (const char * s)"
Check whether each character of a string s is a money amount\&.
.PP
Assumes no more than 2 decimal places but does not require 2 decimial digits\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_ischarset (const char * str, const char * charset)"
Check whether each character of a string is in the given character set\&.
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP string to check (NULL-terminated)\&. 
.br
\fIcharset\fP list of characters that are allowed in \fIstr\fP (NULL-terminated)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters in \fIstr\fP match at least one char in \fIcharset\fP\&. 
.RE
.PP

.SS "M_bool M_str_isnotcharset (const char * str, const char * charset)"
Check whether each character of a string is not in the given character set\&.
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP string to check (NULL-terminated)\&. 
.br
\fIcharset\fP list of characters that are not allowed in \fIstr\fP (NULL-terminated)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if none of the characters in \fIcharset\fP are present in \fIstr\fP\&. 
.RE
.PP

.SS "M_bool M_str_isstr (const unsigned char * s, size_t len)"
Check whether or not the data provided is a string\&.
.PP
This is useful for parsing binary protocols that contain string data as a verification\&. The length passed in is the size of the buffer, the last byte of the buffer must be a NULL terminator or this function will fail (This means, of course, the string length should be exactly 1 byte less than the provided buffer size)\&. Then the remainder of the buffer will be checked for printable data, otherwise it is not considered a string\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Buffer to see if data is a null-terminated string 
.br
\fIlen\fP Size of buffer, including NULL terminator 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if buffer contains a string, M_FALSE otherwise 
.RE
.PP

.SS "M_bool M_str_ispredicate_max (const char * s, size_t max, \fBM_chr_predicate_func\fP pred)"
Determines if the first \fCmax\fP characters of string \fCs\fP satisfy predicate \fCpred\fP up to max bytes\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fImax\fP Max number of characters to process of \fCs\fP\&. 
.br
\fIpred\fP Predicate to apply to each character\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_isalnum_max (const char * s, size_t max)"
Check whether each character of a string s are alphanumeric up to at most max bytes\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fImax\fP Maximum number of bytes\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_isalnumsp_max (const char * s, size_t max)"
Check whether each character of a string s ar alphanumeric or contains spaces up to at most max bytes\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fImax\fP Maximum number of bytes\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_isalpha_max (const char * s, size_t max)"
Check whether each character of a string s is alpha up to at most max bytes\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fImax\fP Maximum number of bytes\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_isalphasp_max (const char * s, size_t max)"
Check whether each character of a string s is alpha or contains spaces up to at most max bytes\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fImax\fP Maximum number of bytes\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_isspace_max (const char * s, size_t max)"
Check whether each character of a string s is a space up to at most max bytes\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fImax\fP Maximum number of bytes\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_isgraph_max (const char * s, size_t max)"
Check whether each character of a string s is printable except space up to at most max bytes\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fImax\fP Maximum number of bytes\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_isprint_max (const char * s, size_t max)"
Check whether each character of a string s is printable up to at most max bytes\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fImax\fP Maximum number of bytes\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_ishex_max (const char * s, size_t max)"
Check whether each character of a string s is a hexadecimal digit up to at most max bytes\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fImax\fP Maximum number of bytes\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_isnum_max (const char * s, size_t max)"
Check whether each character of a string s is a decimal digit 0-9 up to at most max bytes\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fImax\fP Maximum number of bytes\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_isdec_max (const char * s, size_t max)"
Check whether each character of a string s is a decimal digit 0-9 or contains a decimal up to at most max bytes\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fImax\fP Maximum number of bytes\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if all characters match\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "int M_str_cmpsort (const char * s1, const char * s2)"
A wrapper around strcmp that treats NULL as an empty string\&.
.PP
NOTE: this is not a constant-time comparison and thus should ONLY be used for sorting such as within qsort()!
.PP
\fBParameters:\fP
.RS 4
\fIs1\fP NULL-terminated string\&. 
.br
\fIs2\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
An integer less than, equal to, or greater than zero if s1 is less than, equal, or greater than s2 respectively\&. 
.RE
.PP

.SS "int M_str_cmpsort_max (const char * s1, const char * s2, size_t max)"
A wrapper around strcmp that treats NULL as an empty string, but limited to max characters\&.
.PP
NOTE: this is not a constant-time comparison and thus should ONLY be used for sorting such as within qsort()!
.PP
\fBParameters:\fP
.RS 4
\fIs1\fP NULL-terminated string\&. 
.br
\fIs2\fP NULL-terminated string\&. 
.br
\fImax\fP Max number of characters to process of \fCs\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
An integer less than, equal to, or greater than zero if s1 is less than, equal, or greater than s2 respectively\&. 
.RE
.PP

.SS "int M_str_casecmpsort (const char * s1, const char * s2)"
A wrapper around strcmp that treats NULL as an empty string and compares case insensitive\&.
.PP
NOTE: this is not a constant-time comparison and thus should ONLY be used for sorting such as within qsort()!
.PP
\fBParameters:\fP
.RS 4
\fIs1\fP NULL-terminated string\&. 
.br
\fIs2\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
An integer less than, equal to, or greater than zero if s1 is less than, equal, or greater than s2 respectively\&. 
.RE
.PP

.SS "int M_str_casecmpsort_max (const char * s1, const char * s2, size_t max)"
A wrapper around strcmp that treats NULL as an empty string and compares case insensitive, but limited to max characters\&.
.PP
NOTE: this is not a constant-time comparison and thus should ONLY be used for sorting such as within qsort()!
.PP
\fBParameters:\fP
.RS 4
\fIs1\fP NULL-terminated string\&. 
.br
\fIs2\fP NULL-terminated string\&. 
.br
\fImax\fP Max number of characters to process of \fCs\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
An integer less than, equal to, or greater than zero if s1 is less than, equal, or greater than s2 respectively\&. 
.RE
.PP

.SS "M_bool M_str_eq_max (const char * s1, const char * s2, size_t max)"
Comparison for string equality\&.
.PP
This implementation is constant-time meaning it should not be vulnerable to timing-based attacks\&. Limited to first max bytes\&. NULL and '' are considered equal strings\&.
.PP
\fBParameters:\fP
.RS 4
\fIs1\fP NULL-terminated string\&. 
.br
\fIs2\fP NULL-terminated string\&. 
.br
\fImax\fP maximum length to check, or 0 for no maximum\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if equal, M_FALSE if not equal\&. 
.RE
.PP

.SS "M_bool M_str_eq (const char * s1, const char * s2)"
Comparison for string equality\&.
.PP
This implementation is constant-time meaning it should not be vulnerable to timing-based attacks\&. NULL and '' are considered equal strings\&.
.PP
\fBParameters:\fP
.RS 4
\fIs1\fP NULL-terminated string\&. 
.br
\fIs2\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if equal, M_FALSE if not equal\&. 
.RE
.PP

.SS "M_bool M_str_caseeq_max (const char * s1, const char * s2, size_t max)"
Comparison for string equality in a case-insensitive manner\&.
.PP
This implementation is constant-time meaning it should not be vulnerable to timing-based attacks\&. Limited to first max bytes\&. NULL and '' are considered equal strings\&.
.PP
\fBParameters:\fP
.RS 4
\fIs1\fP NULL-terminated string\&. 
.br
\fIs2\fP NULL-terminated string\&. 
.br
\fImax\fP maximum length to check, or 0 for no maximum\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if equal, M_FALSE if not equal\&. 
.RE
.PP

.SS "M_bool M_str_caseeq (const char * s1, const char * s2)"
Comparison for string equality in a case-insensitive manner\&.
.PP
This implementation is constant-time meaning it should not be vulnerable to timing-based attacks\&. NULL and '' are considered equal strings\&.
.PP
\fBParameters:\fP
.RS 4
\fIs1\fP NULL-terminated string\&. 
.br
\fIs2\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if equal, M_FALSE if not equal\&. 
.RE
.PP

.SS "M_bool M_str_eq_end (const char * s1, const char * s2)"
Determine if a string ends with a given string\&.
.PP
\fBParameters:\fP
.RS 4
\fIs1\fP NULL-terminated string\&. 
.br
\fIs2\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if s1 ends with s2, otherwise M_FALSE; 
.RE
.PP

.SS "M_bool M_str_caseeq_end (const char * s1, const char * s2)"
Determine if a string ends with a given string in a case-insensitive manner\&.
.PP
\fBParameters:\fP
.RS 4
\fIs1\fP NULL-terminated string\&. 
.br
\fIs2\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if s1 ends with s2, otherwise M_FALSE; 
.RE
.PP

.SS "M_bool M_str_eq_start (const char * s1, const char * s2)"
Determine if a string starts with a given string\&.
.PP
\fBParameters:\fP
.RS 4
\fIs1\fP NULL-terminated string, or non-terminated string that's at least as long as s2\&. 
.br
\fIs2\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if s1 starts with s2, otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_caseeq_start (const char * s1, const char * s2)"
Determine if a string starts with a given string in a case-insensitive manner\&.
.PP
\fBParameters:\fP
.RS 4
\fIs1\fP NULL-terminated string, or non-terminated string that's at least as long as s2\&. 
.br
\fIs2\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if s1 starts with s2 (case insensitive), otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_pattern_match (const char * pattern, const char * s)"
Match pattern against string as per 'man 7 glob'\&.
.PP
We don't support newer POSIX functions like named character classes (e\&.g\&. [:lower:]), collating symbols, or equivalence class expressions
.PP
\fBParameters:\fP
.RS 4
\fIpattern\fP The pattern to match using\&. 
.br
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the pattern matches the string otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_case_pattern_match (const char * pattern, const char * s)"
Match pattern against string as per 'man 7 glob' case insensitive\&.
.PP
We don't support newer POSIX functions like named character classes (e\&.g\&. [:lower:]), collating symbols, or equivalence class expressions
.PP
\fBParameters:\fP
.RS 4
\fIpattern\fP The pattern to match using\&. 
.br
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the pattern matches the string otherwise M_FALSE\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_str_pattern_match\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
