.TH "m_io_hid" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_io_hid
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBM_io_hid_enum\fP \fBM_io_hid_enum_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_io_hid_enum_t\fP * \fBM_io_hid_enum\fP (M_uint16 vendorid, const M_uint16 *productids, size_t num_productids, const char *serial)"
.br
.ti -1c
.RI "void \fBM_io_hid_enum_destroy\fP (\fBM_io_hid_enum_t\fP *hidenum)"
.br
.ti -1c
.RI "size_t \fBM_io_hid_enum_count\fP (const \fBM_io_hid_enum_t\fP *hidenum)"
.br
.ti -1c
.RI "const char * \fBM_io_hid_enum_path\fP (const \fBM_io_hid_enum_t\fP *hidenum, size_t idx)"
.br
.ti -1c
.RI "const char * \fBM_io_hid_enum_manufacturer\fP (const \fBM_io_hid_enum_t\fP *hidenum, size_t idx)"
.br
.ti -1c
.RI "const char * \fBM_io_hid_enum_product\fP (const \fBM_io_hid_enum_t\fP *hidenum, size_t idx)"
.br
.ti -1c
.RI "const char * \fBM_io_hid_enum_serial\fP (const \fBM_io_hid_enum_t\fP *hidenum, size_t idx)"
.br
.ti -1c
.RI "M_uint16 \fBM_io_hid_enum_vendorid\fP (const \fBM_io_hid_enum_t\fP *hidenum, size_t idx)"
.br
.ti -1c
.RI "M_uint16 \fBM_io_hid_enum_productid\fP (const \fBM_io_hid_enum_t\fP *hidenum, size_t idx)"
.br
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_hid_create\fP (\fBM_io_t\fP **io_out, M_uint16 vendorid, M_uint16 productid, const char *serial)"
.br
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_hid_create_one\fP (\fBM_io_t\fP **io_out, M_uint16 vendorid, const M_uint16 *productids, size_t num_productids, const char *serial)"
.br
.ti -1c
.RI "const char * \fBM_io_hid_get_manufacturer\fP (\fBM_io_t\fP *io)"
.br
.ti -1c
.RI "const char * \fBM_io_hid_get_path\fP (\fBM_io_t\fP *io)"
.br
.ti -1c
.RI "const char * \fBM_io_hid_get_product\fP (\fBM_io_t\fP *io)"
.br
.ti -1c
.RI "M_uint16 \fBM_io_hid_get_productid\fP (\fBM_io_t\fP *io)"
.br
.ti -1c
.RI "M_uint16 \fBM_io_hid_get_vendorid\fP (\fBM_io_t\fP *io)"
.br
.ti -1c
.RI "const char * \fBM_io_hid_get_serial\fP (\fBM_io_t\fP *io)"
.br
.ti -1c
.RI "void \fBM_io_hid_get_max_report_sizes\fP (\fBM_io_t\fP *io, size_t *max_input_size, size_t *max_output_size)"
.br
.in -1c
.SH "Detailed Description"
.PP 
HID (Human Interface Device) IO functions\&. Typically used with USB devices\&.
.PP
Report IDs need to be the first byte of any data sent to a device and will be the first byte of any data received from a device\&. All buffer sizes report will include the extra byte for the report ID\&.
.PP
If a device does not use report IDs 0 should be sent as the first byte of any data and will be the first byte of any read data\&.
.PP
Supported OS:
.IP "\(bu" 2
Windows
.IP "\(bu" 2
Linux
.IP "\(bu" 2
macOS 
.PP

.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBM_io_hid_enum\fP \fBM_io_hid_enum_t\fP"

.SH "Function Documentation"
.PP 
.SS "\fBM_io_hid_enum_t\fP* M_io_hid_enum (M_uint16 vendorid, const M_uint16 * productids, size_t num_productids, const char * serial)"
Create a HID enumeration object\&.
.PP
\fBParameters:\fP
.RS 4
\fIvendorid\fP Optional\&. Filter by vendor id\&. Set to 0 if no filter should be applied\&. 
.br
\fIproductids\fP Optional\&. Filter by product ids\&. Set to NULL if no filter should be applied\&. 
.br
\fInum_productids\fP Number of product ids in list of product ids\&. Should be 0 if productids is NULL\&. 
.br
\fIserial\fP Optional\&. Filter by serial number\&.
.RE
.PP
\fBReturns:\fP
.RS 4
HID enumeration object\&. 
.RE
.PP

.SS "void M_io_hid_enum_destroy (\fBM_io_hid_enum_t\fP * hidenum)"
Destroy a HID enumeration object\&.
.PP
\fBParameters:\fP
.RS 4
\fIhidenum\fP HID enumeration object\&. 
.RE
.PP

.SS "size_t M_io_hid_enum_count (const \fBM_io_hid_enum_t\fP * hidenum)"
Number of HID objects in the enumeration\&.
.PP
\fBParameters:\fP
.RS 4
\fIhidenum\fP HID enumeration object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Count of HID devices\&. 
.RE
.PP

.SS "const char* M_io_hid_enum_path (const \fBM_io_hid_enum_t\fP * hidenum, size_t idx)"

.SS "const char* M_io_hid_enum_manufacturer (const \fBM_io_hid_enum_t\fP * hidenum, size_t idx)"

.SS "const char* M_io_hid_enum_product (const \fBM_io_hid_enum_t\fP * hidenum, size_t idx)"

.SS "const char* M_io_hid_enum_serial (const \fBM_io_hid_enum_t\fP * hidenum, size_t idx)"

.SS "M_uint16 M_io_hid_enum_vendorid (const \fBM_io_hid_enum_t\fP * hidenum, size_t idx)"

.SS "M_uint16 M_io_hid_enum_productid (const \fBM_io_hid_enum_t\fP * hidenum, size_t idx)"

.SS "\fBM_io_error_t\fP M_io_hid_create (\fBM_io_t\fP ** io_out, M_uint16 vendorid, M_uint16 productid, const char * serial)"
Create a HID connection\&.
.PP
\fBParameters:\fP
.RS 4
\fIio_out\fP io object for communication\&. 
.br
\fIvendorid\fP Vendor id\&. 
.br
\fIproductid\fP Product id\&. 
.br
\fIserial\fP Product serial number\&. Optional\&. If multiple devices with the same vendor an product id it is undefined which will be chosen\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SS "\fBM_io_error_t\fP M_io_hid_create_one (\fBM_io_t\fP ** io_out, M_uint16 vendorid, const M_uint16 * productids, size_t num_productids, const char * serial)"
Create a HID device connection\&.
.PP
Creates a connection to the first device from from a given list of ids\&.
.PP
\fBParameters:\fP
.RS 4
\fIio_out\fP io object for communication\&. 
.br
\fIvendorid\fP Vendor id\&. 
.br
\fIproductids\fP A list of product ids to look for\&. 
.br
\fInum_productids\fP Number of product ids in the list of product ids\&. These should be in priority order\&. 
.br
\fIserial\fP Product serial number\&. Optional\&. If multiple devices with the same vendor an product id it is undefined which will be chosen\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SS "const char* M_io_hid_get_manufacturer (\fBM_io_t\fP * io)"
Get the HID manufacturer from an io object\&.
.PP
Queries the highest HID layer in the stack, if there are more than one\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "const char* M_io_hid_get_path (\fBM_io_t\fP * io)"
Get the HID path from an io object\&.
.PP
Queries the highest HID layer in the stack, if there are more than one\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "const char* M_io_hid_get_product (\fBM_io_t\fP * io)"
Get the HID product from an io object\&.
.PP
Queries the highest HID layer in the stack, if there are more than one\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "M_uint16 M_io_hid_get_productid (\fBM_io_t\fP * io)"
Get the HID product ID from an io object\&.
.PP
Queries the highest HID layer in the stack, if there are more than one\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "M_uint16 M_io_hid_get_vendorid (\fBM_io_t\fP * io)"
Get the HID vendor ID from an io object\&.
.PP
Queries the highest HID layer in the stack, if there are more than one\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "const char* M_io_hid_get_serial (\fBM_io_t\fP * io)"
Get the HID serial number from an io object\&.
.PP
Queries the highest HID layer in the stack, if there are more than one\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "void M_io_hid_get_max_report_sizes (\fBM_io_t\fP * io, size_t * max_input_size, size_t * max_output_size)"
Get the HID maximum input and output report sizes from an io object\&.
.PP
The report sizes returned may be 1 byte larger than the actual report size to account for the report ID that is prepended to the data block\&.
.PP
Queries the highest HID layer in the stack, if there are more than one\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fImax_input_size\fP Maximum input report size\&. 
.br
\fImax_output_size\fP Maximum output report size\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
