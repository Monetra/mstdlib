.TH "m_sql_trans" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_sql_trans
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct M_sql_trans \fBM_sql_trans_t\fP"
.br
.ti -1c
.RI "typedef \fBM_sql_error_t\fP(* \fBM_sql_trans_commands_t\fP) (\fBM_sql_trans_t\fP *trans, void *arg, char *error, size_t error_size)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_sql_isolation_t\fP { \fBM_SQL_ISOLATION_UNKNOWN\fP = 0, \fBM_SQL_ISOLATION_READUNCOMMITTED\fP = 1, \fBM_SQL_ISOLATION_READCOMMITTED\fP = 2, \fBM_SQL_ISOLATION_REPEATABLEREAD\fP = 3, \fBM_SQL_ISOLATION_SNAPSHOT\fP = 4, \fBM_SQL_ISOLATION_SERIALIZABLE\fP = 5 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_sql_error_t\fP \fBM_sql_trans_begin\fP (\fBM_sql_trans_t\fP **trans, \fBM_sql_connpool_t\fP *pool, \fBM_sql_isolation_t\fP isolation, char *error, size_t error_size)"
.br
.ti -1c
.RI "\fBM_sql_error_t\fP \fBM_sql_trans_rollback\fP (\fBM_sql_trans_t\fP *trans)"
.br
.ti -1c
.RI "\fBM_sql_error_t\fP \fBM_sql_trans_commit\fP (\fBM_sql_trans_t\fP *trans, char *error, size_t error_size)"
.br
.ti -1c
.RI "\fBM_sql_error_t\fP \fBM_sql_trans_execute\fP (\fBM_sql_trans_t\fP *trans, \fBM_sql_stmt_t\fP *stmt)"
.br
.ti -1c
.RI "\fBM_sql_error_t\fP \fBM_sql_trans_process\fP (\fBM_sql_connpool_t\fP *pool, \fBM_sql_isolation_t\fP isolation, \fBM_sql_trans_commands_t\fP cmd, void *cmd_arg, char *error, size_t error_size)"
.br
.ti -1c
.RI "\fBM_sql_connpool_t\fP * \fBM_sql_trans_get_pool\fP (\fBM_sql_trans_t\fP *trans)"
.br
.in -1c
.SH "Detailed Description"
.PP 
SQL Transaction Handling 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct M_sql_trans \fBM_sql_trans_t\fP"
Object holding the state for an active transaction 
.SS "typedef \fBM_sql_error_t\fP(* M_sql_trans_commands_t) (\fBM_sql_trans_t\fP *trans, void *arg, char *error, size_t error_size)"
Function prototype called by \fBM_sql_trans_process()\fP\&.
.PP
Inside the function created, the integrator should perform each step of the SQL transaction, and if an error occurs, return the appropriate error condition, whether it is an error condition as returned by \fBM_sql_trans_execute()\fP, which should be passed through unmodified, or an internally generated error condition if internal logic fails\&. For user-logic generated errors, special error conditions of \fBM_SQL_ERROR_USER_SUCCESS\fP, \fBM_SQL_ERROR_USER_RETRY\fP and \fBM_SQL_ERROR_USER_FAILURE\fP exist to more accurately identify the condition rather than attempting to map to the generic SQL subsystem condtions\&.
.PP
\fBNote:\fP
.RS 4
The function should expect to be called potentially multiple times, so state tracking must be reset on entry to this user-specified function\&. If a rollback or connectivity failure condition is met, it will automatically be called again\&.
.RE
.PP
\fBWarning:\fP
.RS 4
This function should NEVER call \fBM_sql_trans_commit()\fP or \fBM_sql_trans_rollback()\fP as that is handled internally by the helper \fBM_sql_trans_process()\fP\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fItrans\fP Pointer to initialized transaction object to use to execute the transaction\&. 
.br
\fIarg\fP User-specified argument used for storing metadata about the flow/process\&. 
.br
\fIerror\fP User-supplied error buffer to output error message\&. 
.br
\fIerror_size\fP Size of user-supplied error buffer\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBM_SQL_ERROR_SUCCESS\fP or \fBM_SQL_ERROR_USER_SUCCESS\fP on successful completion, or one of the \fBM_sql_error_t\fP error conditions\&. 
.RE
.PP

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_sql_isolation_t\fP"
Transaction isolation levels 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_SQL_ISOLATION_UNKNOWN \fP\fP
Unknown, used for error conditions, never set 
.TP
\fB\fIM_SQL_ISOLATION_READUNCOMMITTED \fP\fP
Read Uncommitted 
.TP
\fB\fIM_SQL_ISOLATION_READCOMMITTED \fP\fP
Read Committed 
.TP
\fB\fIM_SQL_ISOLATION_REPEATABLEREAD \fP\fP
Repeatable Read 
.TP
\fB\fIM_SQL_ISOLATION_SNAPSHOT \fP\fP
Snapshot 
.TP
\fB\fIM_SQL_ISOLATION_SERIALIZABLE \fP\fP
Serializable 
.SH "Function Documentation"
.PP 
.SS "\fBM_sql_error_t\fP M_sql_trans_begin (\fBM_sql_trans_t\fP ** trans, \fBM_sql_connpool_t\fP * pool, \fBM_sql_isolation_t\fP isolation, char * error, size_t error_size)"
Begin a new SQL transaction at the requested isolation level\&.
.PP
Beginning a new transaction will reserve an SQL connection from the pool until either a rollback or commit is performed\&. Callers in most cases should not start more than one SQL transaction per thread as it could lead to deadlocks waiting on a connection to become available if insufficient connections are available in the pool\&.
.PP
In order to clean up the returned transaction handle, a caller must call either \fBM_sql_trans_commit()\fP or \fBM_sql_trans_rollback()\fP as appropriate\&.
.PP
\fBNote:\fP
.RS 4
It is recommended to use the \fBM_sql_trans_process()\fP helper rather than calling \fBM_sql_trans_begin()\fP, \fBM_sql_trans_rollback()\fP or \fBM_sql_trans_commit()\fP yourself\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fItrans\fP Returns initialized transaction handle to be used for queries\&. 
.br
\fIpool\fP Initialized \fBM_sql_connpool_t\fP object 
.br
\fIisolation\fP Requested isolation level\&. The database may choose the closest match if the isolation level requested is not supported\&. 
.br
\fIerror\fP User-supplied buffer to hold error message\&. 
.br
\fIerror_size\fP Size of User-supplied buffer\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBM_SQL_ERROR_SUCCESS\fP on success, or one of the \fBM_sql_error_t\fP results on failure\&. 
.RE
.PP

.SS "\fBM_sql_error_t\fP M_sql_trans_rollback (\fBM_sql_trans_t\fP * trans)"
Rollback an SQL transaction\&.
.PP
This function should be called if the caller needs to cancel the transaction, or must be called to clean up the \fBM_sql_trans_t\fP handle when an unrecoverable error has occurred such as a server disconnect or deadlock\&.
.PP
The passed in trans handle will be destroyed regardless if this function returns success or fail\&.
.PP
\fBNote:\fP
.RS 4
It is recommended to use the \fBM_sql_trans_process()\fP helper rather than calling \fBM_sql_trans_begin()\fP, \fBM_sql_trans_rollback()\fP or \fBM_sql_trans_commit()\fP yourself\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fItrans\fP Initialized transaction handle that will be used to rollback the pending transaction, and will be will be destroyed automatically upon return of this function\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBM_SQL_ERROR_SUCCESS\fP on success, or one of the \fBM_sql_error_t\fP results on failure\&. 
.RE
.PP

.SS "\fBM_sql_error_t\fP M_sql_trans_commit (\fBM_sql_trans_t\fP * trans, char * error, size_t error_size)"
Commit a pending SQL transaction\&.
.PP
Any statements executed against the transaction handle will not be applied to the database until this command is called\&.
.PP
The associated transaction handle will be automatically destroyed regardless if this function returns success or fail\&. If a failure occurs, the caller must assume the transaction was NOT applied (e\&.g\&. rolled back)\&.
.PP
\fBNote:\fP
.RS 4
It is recommended to use the \fBM_sql_trans_process()\fP helper rather than calling \fBM_sql_trans_begin()\fP, \fBM_sql_trans_rollback()\fP or \fBM_sql_trans_commit()\fP yourself\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fItrans\fP Initialized transaction handle that will be used to commit the pending transaction, and will be will be destroyed automatically upon return of this function\&. 
.br
\fIerror\fP User-supplied buffer to hold error message\&. 
.br
\fIerror_size\fP Size of User-supplied buffer\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBM_SQL_ERROR_SUCCESS\fP on success, or one of the \fBM_sql_error_t\fP results on failure\&. 
.RE
.PP

.SS "\fBM_sql_error_t\fP M_sql_trans_execute (\fBM_sql_trans_t\fP * trans, \fBM_sql_stmt_t\fP * stmt)"
Execute a query against the database that is part of an open transaction\&. This request will not automatically commit and must be manually committed via \fBM_sql_trans_commit()\fP\&.
.PP
Must call \fBM_sql_stmt_prepare()\fP or \fBM_sql_stmt_prepare_buf()\fP prior to execution\&. Must also bind any parameters using \fBM_sql_stmt_bind_*() \fP series of functions\&.
.PP
This function will NOT destroy the passed in \fBM_sql_trans_t\fP object, it is kept open so additional statements can be executed within the same transaction\&. If NOT using the \fBM_sql_trans_process()\fP helper, it is the caller's responsibility to call \fBM_sql_trans_commit()\fP or \fBM_sql_trans_rollback()\fP as appropriate\&.
.PP
\fBParameters:\fP
.RS 4
\fItrans\fP Initialized \fBM_sql_trans_t\fP object\&. 
.br
\fIstmt\fP Initialized and prepared \fBM_sql_stmt_t\fP object 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBM_SQL_ERROR_SUCCESS\fP on success, or one of the \fBM_sql_error_t\fP values on failure\&. 
.RE
.PP

.SS "\fBM_sql_error_t\fP M_sql_trans_process (\fBM_sql_connpool_t\fP * pool, \fBM_sql_isolation_t\fP isolation, \fBM_sql_trans_commands_t\fP cmd, void * cmd_arg, char * error, size_t error_size)"
Helper function for processing a sequence of SQL commands as a single atomic operation, while automatically handling things like rollback and connectivity failure situations\&.
.PP
\fBWarning:\fP
.RS 4
The user-supplied function being called should expect to be called, potentially, multiple times when errors occur\&. State MUST NOT be maintained from call to call or risk having inconstent data\&.
.RE
.PP
Usage Example: 
.PP
.nf
typedef struct {
   M_int64 id;
   M_int64 inc;
   M_int64 result;
} my_counter_metadata_t;

// Table: CREATE TABLE counters (id INTEGER, val INTEGER, PRIMARY KEY(id))
// Increment requested id by requested amount
static M_sql_error_t my_counter_inc(M_sql_trans_t *trans, void *arg, char *error, size_t error_size)
{
  my_counter_metadata_t *data     = arg;
  M_sql_stmt_t          *stmt;
  M_sql_error_t          err;
  M_int64                curr_val = 0;
  M_buf_t               *query;

  M_mem_set(error, 0, error_size);

  // Retrieve current value for id - don't forget to use update locks!
  stmt  = M_sql_stmt_create();
  query = M_buf_create();
  M_buf_add_str(query, "SELECT \"val\" FROM \"counters\"");
  M_sql_query_append_updlock(M_sql_trans_get_pool(trans), query, M_SQL_QUERY_UPDLOCK_TABLE);
  M_buf_add_str(query, " WHERE \"id\" = ?");
  M_sql_query_append_updlock(M_sql_trans_get_pool(trans), query, M_SQL_QUERY_UPDLOCK_QUERYEND);
  M_sql_stmt_prepare_buf(stmt, query);
  M_sql_stmt_bind_int64(stmt, data->id);
  err  = M_sql_trans_execute(trans, stmt);
  if (err != M_SQL_ERROR_SUCCESS)
    goto done;

  if (M_sql_stmt_result_int64(stmt, 0, 0, &curr_val) != M_SQL_ERROR_SUCCESS) {
    M_snprintf(error, error_size, "id %lld not found", data->id);
    err = M_SQL_ERROR_QUERY_FAILED;
    goto done;
  }
  M_sql_stmt_destroy(stmt);

  // Increment the value for the id
  data->result = curr_val + data->inc;
  stmt = M_sql_stmt_create();
  M_sql_stmt_prepare(stmt, "UPDATE \"counters\" SET \"val\" = ? WHERE \"id\" = ?");
  M_sql_stmt_bind_int64(stmt, data->result);
  M_sql_stmt_bind_int64(stmt, data->id);
  err  = M_sql_trans_execute(trans, stmt);
  if (err != M_SQL_ERROR_SUCCESS)
    goto done;

done:
  if (err != M_SQL_ERROR_SUCCESS && M_str_isempty(error)) {
    M_snprintf(error, error_size, "%s", M_sql_stmt_get_error_string(stmt));
  }
  M_sql_stmt_destroy(stmt);

  return err;
}

static void run_txn(M_sql_connpool_t *pool)
{
  my_counter_metadata_t data;
  M_sql_error_t         err;
  char                  msg[256];

  data\&.id     = 5;
  data\&.inc    = 25;
  data\&.result = 0;

  err = M_sql_trans_process(pool, M_SQL_ISOLATION_SERIALIZABLE, my_counter_inc, &data, msg, sizeof(msg));
  if (err != M_SQL_ERROR_SUCCESS) {
    M_printf("Error: %s: %s\n", M_sql_error_string(err), msg);
    return;
  }
  M_printf("Success! Final result: %lld\n", data\&.result);
}

.fi
.PP
.PP
\fBParameters:\fP
.RS 4
\fIpool\fP Initialized and started pool object\&. 
.br
\fIisolation\fP Requested isolation level\&. The database may choose the closest match if the isolation level requested is not supported\&. 
.br
\fIcmd\fP User-specified function to call to step through the sequence of SQL commands to run as part of the transaction\&. 
.br
\fIcmd_arg\fP Argument to pass to User-specified function for metadata about the command(s) being executed\&. 
.br
\fIerror\fP User-supplied error buffer to output error message\&. 
.br
\fIerror_size\fP Size of user-supplied error buffer\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBM_SQL_ERROR_SUCCESS\fP if executed to completion, or one of the \fBM_sql_error_t\fP fatal errors on failure (but never \fBM_SQL_ERROR_QUERY_DEADLOCK\fP or \fBM_SQL_ERROR_CONN_LOST\fP as those are automatic retry events) 
.RE
.PP

.SS "\fBM_sql_connpool_t\fP* M_sql_trans_get_pool (\fBM_sql_trans_t\fP * trans)"
Retrieve the \fBM_sql_connpool_t\fP object from a transaction handle typically used within \fBM_sql_trans_process()\fP for using the SQL helpers like \fBM_sql_query_append_updlock()\fP and \fBM_sql_query_append_bitop()\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fItrans\fP Transaction object 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBM_sql_connpool_t\fP object 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
