.TH "m_getopt" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_getopt
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct M_getopt \fBM_getopt_t\fP"
.br
.ti -1c
.RI "typedef M_bool(* \fBM_getopt_nonopt_cb\fP) (size_t idx, const char *option, void *thunk)"
.br
.ti -1c
.RI "typedef M_bool(* \fBM_getopt_integer_cb\fP) (char short_opt, const char *long_opt, M_int64 *integer, void *thunk)"
.br
.ti -1c
.RI "typedef M_bool(* \fBM_getopt_decimal_cb\fP) (char short_opt, const char *long_opt, \fBM_decimal_t\fP *decimal, void *thunk)"
.br
.ti -1c
.RI "typedef M_bool(* \fBM_getopt_string_cb\fP) (char short_opt, const char *long_opt, const char *string, void *thunk)"
.br
.ti -1c
.RI "typedef M_bool(* \fBM_getopt_boolean_cb\fP) (char short_opt, const char *long_opt, M_bool boolean, void *thunk)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_getopt_error_t\fP { \fBM_GETOPT_ERROR_SUCCESS\fP = 0, \fBM_GETOPT_ERROR_INVALIDOPT\fP, \fBM_GETOPT_ERROR_INVALIDDATATYPE\fP, \fBM_GETOPT_ERROR_INVALIDORDER\fP, \fBM_GETOPT_ERROR_MISSINGVALUE\fP, \fBM_GETOPT_ERROR_NONOPTION\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_getopt_t\fP * \fBM_getopt_create\fP (\fBM_getopt_nonopt_cb\fP cb)"
.br
.ti -1c
.RI "void \fBM_getopt_destroy\fP (\fBM_getopt_t\fP *g)"
.br
.ti -1c
.RI "char * \fBM_getopt_help\fP (const \fBM_getopt_t\fP *g)"
.br
.ti -1c
.RI "M_bool \fBM_getopt_addinteger\fP (\fBM_getopt_t\fP *g, char short_opt, const char *long_opt, M_bool val_required, const char *description, \fBM_getopt_integer_cb\fP cb)"
.br
.ti -1c
.RI "M_bool \fBM_getopt_adddecimal\fP (\fBM_getopt_t\fP *g, char short_opt, const char *long_opt, M_bool val_required, const char *description, \fBM_getopt_decimal_cb\fP cb)"
.br
.ti -1c
.RI "M_bool \fBM_getopt_addstring\fP (\fBM_getopt_t\fP *g, char short_opt, const char *long_opt, M_bool val_required, const char *description, \fBM_getopt_string_cb\fP cb)"
.br
.ti -1c
.RI "M_bool \fBM_getopt_addboolean\fP (\fBM_getopt_t\fP *g, char short_opt, const char *long_opt, M_bool val_required, const char *description, \fBM_getopt_boolean_cb\fP cb)"
.br
.ti -1c
.RI "\fBM_getopt_error_t\fP \fBM_getopt_parse\fP (\fBM_getopt_t\fP *g, const char *const *argv, int argc, const char **opt_fail, void *thunk)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Command line argument parsing\&.
.PP
Handles parsing using a series of provided callbacks for each type\&. Auto conversion of the argument for the option type will take place\&. Callbacks are allowed to reject the option or argument\&. This will stop parsing\&.
.PP
If auto conversion is unwanted use the string option type\&. String options will alway shave their arguments passed unmodified\&.
.PP
Options can be marked as having required or optional arguments\&.
.PP
The boolean type is somewhat special\&. If marked as not having a required argument it is treated as a flag\&. For example -b would call the boolean callback with a value of M_TRUE\&. If a boolean is marked as val required then a value is required and the result of conversion (using M_str_istrue) will be passed to the callback\&.
.PP
For options that should \fInot\fP have an argument use the boolean type with val not required\&.
.PP
Supports auto generation of help message\&.
.PP
Valid characters for options (short/long) is all ASCII printable [!-~] except:
.IP "\(bu" 2
space
.IP "\(bu" 2
'-' (short or start/end long)
.IP "\(bu" 2
'='
.IP "\(bu" 2
'''
.IP "\(bu" 2
'''
.PP
.PP
To stop option processing and treat all following values as nonoptions use -- as an option\&.
.PP
An optional thunk can be passed in during parsing which will be passed to all callbacks\&. This can be used to collect all options into an object instead of stored in global variables\&.
.PP
Option callbacks will receive the short and long options associated with the option\&. If no short option was set the short_opt callback value will be 0\&. If no long option was set the long_opt callback value will be NULL\&.
.PP
Example:
.PP
.PP
.nf
static M_bool nonopt_cb(size_t idx, const char *option, void *thunk)
{
    M_printf("option='%s'\n", option);
}

static M_bool int_cb(char short_opt, const char *long_opt, M_int64 *integer, void *thunk)
{
    M_printf("short_opt='%d', long_opt='%s', integer='%lld'\n", short_opt, long_opt, integer);
}

int main(int argc, char **argv) {
    M_getopt_t *g; 
    char       *help;
    const char *fail;

    g = M_getopt_create(nonopt_cb);
    M_getopt_addinteger(g, 'i', "i1", M_TRUE, "DESCR 1", check_getopt_int_cb);

    help = M_getopt_help(g);
    M_printf("help=\n%s\n", help);
    M_free(help);

    if (M_getopt_parse(g, argv, argc, &fail, NULL) == M_GETOPT_ERROR_SUCCESS) {
        M_printf("Options parsed successfully\n");
    } else {
        M_printf("Options parse error: %s\n", fail);
    }

    M_getopt_destroy(g);
    return 0;
} 
.fi
.PP
 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct M_getopt \fBM_getopt_t\fP"

.SS "typedef M_bool(* M_getopt_nonopt_cb) (size_t idx, const char *option, void *thunk)"
Callback for non-option parameters 
.SS "typedef M_bool(* M_getopt_integer_cb) (char short_opt, const char *long_opt, M_int64 *integer, void *thunk)"
Callback for integer data type 
.SS "typedef M_bool(* M_getopt_decimal_cb) (char short_opt, const char *long_opt, \fBM_decimal_t\fP *decimal, void *thunk)"
Callback for decimal data type 
.SS "typedef M_bool(* M_getopt_string_cb) (char short_opt, const char *long_opt, const char *string, void *thunk)"
Callback for string data type 
.SS "typedef M_bool(* M_getopt_boolean_cb) (char short_opt, const char *long_opt, M_bool boolean, void *thunk)"
Callback for boolean data type 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_getopt_error_t\fP"
Error codes\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_GETOPT_ERROR_SUCCESS \fP\fP
.TP
\fB\fIM_GETOPT_ERROR_INVALIDOPT \fP\fP
.TP
\fB\fIM_GETOPT_ERROR_INVALIDDATATYPE \fP\fP
.TP
\fB\fIM_GETOPT_ERROR_INVALIDORDER \fP\fP
.TP
\fB\fIM_GETOPT_ERROR_MISSINGVALUE \fP\fP
.TP
\fB\fIM_GETOPT_ERROR_NONOPTION \fP\fP
.SH "Function Documentation"
.PP 
.SS "\fBM_getopt_t\fP* M_getopt_create (\fBM_getopt_nonopt_cb\fP cb)"
Create a new getopt object\&.
.PP
\fBParameters:\fP
.RS 4
\fIcb\fP Callback to be called with non-option parameters\&. NULL if non-option parameters are not allowed\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Getopt object\&. 
.RE
.PP

.SS "void M_getopt_destroy (\fBM_getopt_t\fP * g)"
Destroy a getopt object
.PP
\fBParameters:\fP
.RS 4
\fIg\fP Getopt object to destroy\&. 
.RE
.PP

.SS "char* M_getopt_help (const \fBM_getopt_t\fP * g)"
Output help text for command line options\&.
.PP
Components: <val> value is required [val] value is optional -s short option --long long option (type) Type such as integer, decimal \&.\&.\&. Type will not be printed for boolean options\&. Description Text description about the option
.PP
Example: 
.PP
.nf
-s \<val\> (type) Description 

.fi
.PP
 
.PP
.nf
--long [val] (type) 

.fi
.PP
 
.PP
.nf
-s, --long [val] (type) Description 

.fi
.PP
 
.PP
.nf
-s Description 

.fi
.PP
.PP
\fBParameters:\fP
.RS 4
\fIg\fP Getopt object\&. 
.RE
.PP

.SS "M_bool M_getopt_addinteger (\fBM_getopt_t\fP * g, char short_opt, const char * long_opt, M_bool val_required, const char * description, \fBM_getopt_integer_cb\fP cb)"
Add an integer parameter\&.
.PP
\fBParameters:\fP
.RS 4
\fIg\fP Getopt object 
.br
\fIshort_opt\fP Short option, must be alpha-numeric, case-sensitive\&. Pass 0 if not used 
.br
\fIlong_opt\fP Long option name, must be alpha-numeric or hyphens, case-insensitive\&. Can not start or end with hyphens\&. Pass NULL if not used\&. 
.br
\fIval_required\fP Whether or not the option requires a value\&. 
.br
\fIdescription\fP Field description\&. Used with output putting help message\&. 
.br
\fIcb\fP Callback to call with value\&. -1 will be passed if no value provided
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, M_FALSE on failure\&. 
.RE
.PP

.SS "M_bool M_getopt_adddecimal (\fBM_getopt_t\fP * g, char short_opt, const char * long_opt, M_bool val_required, const char * description, \fBM_getopt_decimal_cb\fP cb)"
Add a decimal parameter\&.
.PP
\fBParameters:\fP
.RS 4
\fIg\fP Getopt object 
.br
\fIshort_opt\fP Short option, must be alpha-numeric, case-sensitive\&. Pass 0 if not used 
.br
\fIlong_opt\fP Long option name, must be alpha-numeric or hyphens, case-insensitive\&. Can not start or end with hyphens\&. Pass NULL if not used\&. 
.br
\fIval_required\fP Whether or not the option requires a value\&. 
.br
\fIdescription\fP Field description\&. Used with output putting help message\&. 
.br
\fIcb\fP Callback to call with value\&. NULL will be passed if no value provided
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, M_FALSE on failure\&. 
.RE
.PP

.SS "M_bool M_getopt_addstring (\fBM_getopt_t\fP * g, char short_opt, const char * long_opt, M_bool val_required, const char * description, \fBM_getopt_string_cb\fP cb)"
Add a string parameter\&.
.PP
\fBParameters:\fP
.RS 4
\fIg\fP Getopt object 
.br
\fIshort_opt\fP Short option, must be alpha-numeric, case-sensitive\&. Pass 0 if not used 
.br
\fIlong_opt\fP Long option name, must be alpha-numeric or hyphens, case-insensitive\&. Can not start or end with hyphens\&. Pass NULL if not used\&. 
.br
\fIval_required\fP Whether or not the option requires a value\&. 
.br
\fIdescription\fP Field description\&. Used with output putting help message\&. 
.br
\fIcb\fP Callback to call with value\&. NULL will be passed if no value provided
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, M_FALSE on failure\&. 
.RE
.PP

.SS "M_bool M_getopt_addboolean (\fBM_getopt_t\fP * g, char short_opt, const char * long_opt, M_bool val_required, const char * description, \fBM_getopt_boolean_cb\fP cb)"
Add a boolean parameter\&.
.PP
\fBParameters:\fP
.RS 4
\fIg\fP Getopt object 
.br
\fIshort_opt\fP Short option, must be alpha-numeric, case-sensitive\&. Pass 0 if not used 
.br
\fIlong_opt\fP Long option name, must be alpha-numeric or hyphens, case-insensitive\&. Can not start or end with hyphens\&. Pass NULL if not used\&. 
.br
\fIval_required\fP Whether or not the option requires a value\&. If M_FALSE this is treated as a flag and will be treated as M_TRUE in the value of the callback\&. If M_FALSE a value cannot be provided\&. 
.br
\fIdescription\fP Field description\&. Used with output putting help message\&. 
.br
\fIcb\fP Callback to call with value\&. NULL will be passed if no value provided
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, M_FALSE on failure\&. 
.RE
.PP

.SS "\fBM_getopt_error_t\fP M_getopt_parse (\fBM_getopt_t\fP * g, const char *const * argv, int argc, const char ** opt_fail, void * thunk)"
Parse command line arguments\&.
.PP
\fBParameters:\fP
.RS 4
\fIg\fP Getopt object 
.br
\fIargv\fP Array of arguments\&. Will not be modified\&. 
.br
\fIargc\fP Number of arguments\&. 
.br
\fIopt_fail\fP On failure will have the argument that caused the failure\&. 
.br
\fIthunk\fP Thunk that will be passed to callbacks\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
