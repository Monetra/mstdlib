.TH "m_io_ble" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_io_ble
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBM_io_ble_enum\fP \fBM_io_ble_enum_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_io_ble_wtype_t\fP { \fBM_IO_BLE_WTYPE_WRITE\fP = 0, \fBM_IO_BLE_WTYPE_WRITENORESP\fP, \fBM_IO_BLE_WTYPE_REQVAL\fP, \fBM_IO_BLE_WTYPE_REQRSSI\fP }"
.br
.ti -1c
.RI "enum \fBM_io_ble_rtype_t\fP { \fBM_IO_BLE_RTYPE_READ\fP = 0, \fBM_IO_BLE_RTYPE_RSSI\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "M_bool \fBM_io_ble_scan\fP (\fBM_event_t\fP *event, \fBM_event_callback_t\fP callback, void *cb_data, M_uint64 timeout_ms)"
.br
.ti -1c
.RI "\fBM_io_ble_enum_t\fP * \fBM_io_ble_enum\fP (void)"
.br
.ti -1c
.RI "void \fBM_io_ble_enum_destroy\fP (\fBM_io_ble_enum_t\fP *btenum)"
.br
.ti -1c
.RI "size_t \fBM_io_ble_enum_count\fP (const \fBM_io_ble_enum_t\fP *btenum)"
.br
.ti -1c
.RI "const char * \fBM_io_ble_enum_name\fP (const \fBM_io_ble_enum_t\fP *btenum, size_t idx)"
.br
.ti -1c
.RI "const char * \fBM_io_ble_enum_uuid\fP (const \fBM_io_ble_enum_t\fP *btenum, size_t idx)"
.br
.ti -1c
.RI "M_bool \fBM_io_ble_enum_connected\fP (const \fBM_io_ble_enum_t\fP *btenum, size_t idx)"
.br
.ti -1c
.RI "const char * \fBM_io_ble_enum_service_uuid\fP (const \fBM_io_ble_enum_t\fP *btenum, size_t idx)"
.br
.ti -1c
.RI "\fBM_time_t\fP \fBM_io_ble_enum_last_seen\fP (const \fBM_io_ble_enum_t\fP *btenum, size_t idx)"
.br
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_ble_create\fP (\fBM_io_t\fP **io_out, const char *uuid, M_uint64 timeout_ms)"
.br
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_ble_set_notify\fP (\fBM_io_t\fP *io, const char *service_uuid, const char *characteristic_uuid, M_bool enable)"
.br
.ti -1c
.RI "\fBM_list_str_t\fP * \fBM_io_ble_get_services\fP (\fBM_io_t\fP *io)"
.br
.ti -1c
.RI "\fBM_list_str_t\fP * \fBM_io_ble_get_service_characteristics\fP (\fBM_io_t\fP *io, const char *service_uuid)"
.br
.ti -1c
.RI "void \fBM_io_ble_get_max_write_sizes\fP (\fBM_io_t\fP *io, size_t *with_response, size_t *without_response)"
.br
.ti -1c
.RI "const char * \fBM_io_ble_meta_get_service\fP (\fBM_io_t\fP *io, \fBM_io_meta_t\fP *meta)"
.br
.ti -1c
.RI "const char * \fBM_io_ble_meta_get_charateristic\fP (\fBM_io_t\fP *io, \fBM_io_meta_t\fP *meta)"
.br
.ti -1c
.RI "\fBM_io_ble_wtype_t\fP \fBM_io_ble_meta_get_write_type\fP (\fBM_io_t\fP *io, \fBM_io_meta_t\fP *meta)"
.br
.ti -1c
.RI "\fBM_io_ble_rtype_t\fP \fBM_io_ble_meta_get_read_type\fP (\fBM_io_t\fP *io, \fBM_io_meta_t\fP *meta)"
.br
.ti -1c
.RI "M_bool \fBM_io_ble_meta_get_rssi\fP (\fBM_io_t\fP *io, \fBM_io_meta_t\fP *meta, M_int64 *rssi)"
.br
.ti -1c
.RI "void \fBM_io_ble_meta_set_service\fP (\fBM_io_t\fP *io, \fBM_io_meta_t\fP *meta, const char *service_uuid)"
.br
.ti -1c
.RI "void \fBM_io_ble_meta_set_characteristic\fP (\fBM_io_t\fP *io, \fBM_io_meta_t\fP *meta, const char *characteristic_uuid)"
.br
.ti -1c
.RI "void \fBM_io_ble_meta_set_write_type\fP (\fBM_io_t\fP *io, \fBM_io_meta_t\fP *meta, \fBM_io_ble_wtype_t\fP type)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Bluetooth LE (Low Energy) IO functions\&.
.PP
Supported OS:
.IP "\(bu" 2
iOS
.IP "\(bu" 2
macOS
.PP
.PP
\fBNote:\fP
.RS 4
iOS also supports an Apple proprietary system known as Made for iPhone/iPod/iPad (MFi)\&. MFi uses ble but is handled differently\&. It's supposed though the m_io_mfi layer\&. MFi is also known as the External Accessory / EAAccessory protocol\&.
.RE
.PP
.SS "Overview"
.PP
BLE was designed to keep energy consumption to a minimum and allow for seamless device access\&. Unlike Bluetooth classic, devices are not paired to the system\&. Typical use is to scan for available devices, inspect their services, and connect to a device that provides services the application wants to use\&. A good example is a heart rate monitor\&.
.PP
A health app doesn't care which heart rate monitor is being used it only cares about getting hear rate data\&. Typically, the user will be presented with a list of suitable devices in case multiple devices are detected (for example, multiple people going on a bike ride together)\&.
.PP
Since there is no pairing the device much be found by scanning for available devices\&. This happen in two ways\&. First M_io_ble_scan will look for and cache devices that can be seen by the OS\&. During a scan, stale devices (over 15 minutes old) will be removed\&.
.PP
All devices that have been found during a scan (excluding ones that have been pruned) be listed as part of device enumeration\&. This means devices may no longer be present\&. Such as an iPhone being seen during scanning and later the owner of the phone leaving the room\&. There are no OS level events to notify that this has happened\&. At which point the seen device cache may be stale\&.
.PP
The other way a scan can be initiated is by trying to connect to a device that has not been seen\&. Opening a device requires specifying the UUID of the device and if not found a scan will be started internally for either the duration of the timeout or until the device has been found\&. This can cause a delay between trying to open a device and receiving CONNECT or ERROR events\&.
.PP
BLE devices provide services and there can be multiple services\&. Services provide characteristics and there can be multiple characteristics per service\&. Both services and characteristics can be defined using standardized profiles\&. See the Bluetooth GATT specifications\&.
.PP
Since there are multiple, potentially, read and write end points it is required to specify the service and characteristic UUIDs\&. A write event much have them specified using the M_io_meta_t and associated BLE meta functions\&. A read will fill a provided meta object with the service and characteristic the data came from\&. This means only the read and write meta functions can be use with BLE\&. The none-meta functions will return an error\&.
.PP
Characteristics can have multiple properties\&.
.IP "\(bu" 2
Read
.IP "\(bu" 2
Notify
.IP "\(bu" 2
Indicate
.IP "\(bu" 2
Write
.IP "\(bu" 2
Write without response
.PP
.PP
BLE by default is not a stream based protocol like serial, HID, or Bluetooth classic\&. Characteristics with the read property can be requested to read data\&. This is an async request\&. M_io_ble facilitates this by using M_io_write_meta with a property indicator that specifies data is not being written but a request for read is being sent\&.
.PP
Characteristics with the notify or indicate property can be subscribed to which will have them issue read events similar to a stream protocol\&. Reads will still require a meta object to specify which service and characteristic the data is from\&. Manual read requests may still be necessary\&. Notify and Indicate events are left to the device to imitate\&. The device may have internal rules which limit how often events are triggered\&. For example a heart rate monitor could notify every 2 seconds even though it's reading every 100 ms\&. A time service might send an event every second or it might send an event every minute\&.
.PP
Characteristics won't receive read events be default\&. They need to be subscribed to first\&. Subscripts will not service a disconnect or destroy of an io object\&. Also, not all characteristics support this property even if it supports read\&. Conversely some support notify/indicate but not read\&.
.PP
Write will write data to the device and the OS will issue an event whether the write as successful or failed\&. Mstdlib uses this to determine if there was a write error and will block subsequent writes (returns WOULDBLOCK) until an outstanding write has completed\&.
.PP
Write without response is a blind write\&. No result is requested from the OS\&. The state of the write is not known after it is sent\&.
.PP
.SS "macOS requirements"
.PP
BLE events are only delivered to the main run loop\&. This is a design decision by Apple\&. It is not possible to use an different run loop to receive events like can be done with classic Bluetooth or HID\&. BLE events are none blocking so there shouldn't be performance impact with the events being delivered\&. As little work as possible is performed during event processing to limit any impact of this design requirement\&.
.PP
A C application will need to manually start the macOS main runloop otherwise no events will be delivered and no BLE operations will work\&.
.PP
.SS "Examples"
.PP
.SS "Application that scans for 30 seconds and enumerates all devices and their services that were seen\&."
.PP
.PP
.nf
// Build:
// clang -g -fobjc-arc -framework CoreFoundation test_ble_enum\&.c -I \&.\&./\&.\&./include/ -L \&.\&./\&.\&./build/lib/ -l mstdlib_io -l mstdlib_thread -l mstdlib
//
// Run:
// DYLD_LIBRARY_PATH="\&.\&./\&.\&./build/lib/" \&./a\&.out

#include <mstdlib/mstdlib\&.h>
#include <mstdlib/mstdlib_thread\&.h>
#include <mstdlib/mstdlib_io\&.h>
#include <mstdlib/io/m_io_ble\&.h>

#include <CoreFoundation/CoreFoundation\&.h>

M_event_t    *el;
CFRunLoopRef  mrl = NULL;

static void scan_done_cb(M_event_t *event, M_event_type_t type, M_io_t *io, void *cb_arg)
{
    M_io_ble_enum_t *btenum;
    size_t           len;
    size_t           i;

    (void)event;
    (void)type;
    (void)io;
    (void)cb_arg;

    btenum = M_io_ble_enum();

    len = M_io_ble_enum_count(btenum);
    M_printf("Num devs = %zu\n", len);
    for (i=0; i<len; i++) {
        M_printf("Device:\n");
        M_printf("\tName: %s\n", M_io_ble_enum_name(btenum, i));
        M_printf("\tUUID: %s\n", M_io_ble_enum_uuid(btenum, i));
        M_printf("\tConnected: %s\n", M_io_ble_enum_connected(btenum, i)?"Yes":"No");
        M_printf("\tLast Seen: %llu\n", M_io_ble_enum_last_seen(btenum, i));
        M_printf("\tSerivce: %s\n", M_io_ble_enum_service_uuid(btenum, i));
    }

    M_io_ble_enum_destroy(btenum);

    if (mrl != NULL)
        CFRunLoopStop(mrl);
}

static void *run_el(void *arg)
{
    (void)arg;
    M_event_loop(el, M_TIMEOUT_INF);
    return NULL;
}

int main(int argc, char **argv)
{
    M_threadid_t     el_thread;
    M_thread_attr_t *tattr;

    el = M_event_create(M_EVENT_FLAG_NONE);

    tattr = M_thread_attr_create();
    M_thread_attr_set_create_joinable(tattr, M_TRUE);
    el_thread = M_thread_create(tattr, run_el, NULL);
    M_thread_attr_destroy(tattr);

    M_io_ble_scan(el, scan_done_cb, NULL, 30000);

    mrl = CFRunLoopGetCurrent();
    CFRunLoopRun();

    // 5 sec timeout\&.
    M_event_done_with_disconnect(el, 5*1000);
    M_thread_join(el_thread, NULL);

    return 0;
}
.fi
.PP
.PP
.SS "Application that scans for 30 seconds and connects to a specified device which has been seen and cached (hopefully)\&."
.PP
.PP
.nf
// Build:
// clang -g -fobjc-arc -framework CoreFoundation test_ble_connect\&.c -I \&.\&./\&.\&./include/ -L \&.\&./\&.\&./build/lib/ -l mstdlib_io -l mstdlib_thread -l mstdlib
//
// Run:
// DYLD_LIBRARY_PATH="\&.\&./\&.\&./build/lib/" \&./a\&.out

#include <mstdlib/mstdlib\&.h>
#include <mstdlib/mstdlib_thread\&.h>
#include <mstdlib/mstdlib_io\&.h>
#include <mstdlib/io/m_io_ble\&.h>

#include <CoreFoundation/CoreFoundation\&.h>

M_event_t    *el;
M_io_t       *io;
CFRunLoopRef  mrl = NULL;

void events(M_event_t *el, M_event_type_t etype, M_io_t *io, void *thunk)
{
    (void)el;
    (void)io;
    (void)thunk;

    switch (etype) {
        case M_EVENT_TYPE_CONNECTED:
            M_printf("CONNECTED!!!\n");
            break;
        case M_EVENT_TYPE_DISCONNECTED:
            M_printf("DISCONNECTED!!!\n");
            M_io_destroy(io);
            if (mrl != NULL)
                CFRunLoopStop(mrl);
            break;
        case M_EVENT_TYPE_READ:
        case M_EVENT_TYPE_WRITE:
        case M_EVENT_TYPE_ACCEPT:
            break;
        case M_EVENT_TYPE_ERROR:
            M_io_destroy(io);
            if (mrl != NULL)
                CFRunLoopStop(mrl);
            break;
        case M_EVENT_TYPE_OTHER:
            break;
    }
}

static void scan_done_cb(M_event_t *event, M_event_type_t type, M_io_t *io, void *cb_arg)
{
    M_io_ble_enum_t *btenum;
    size_t           len;
    size_t           i;

    (void)event;
    (void)type;
    (void)io;
    (void)cb_arg;

    // XXX: Set the id to the device you want to connect to\&.
    M_io_ble_create(&io, "92BD9AC6-3BC8-4B24-8BF8-AE583AFE3ED4", 5000);
    M_event_add(el, io, events, NULL);

    M_printf("SCAN DONE\n");
}

static void *run_el(void *arg)
{
    (void)arg;
    M_event_loop(el, M_TIMEOUT_INF);
    return NULL;
}

int main(int argc, char **argv)
{
    M_threadid_t     el_thread;
    M_thread_attr_t *tattr;

    el = M_event_create(M_EVENT_FLAG_NONE);

    tattr = M_thread_attr_create();
    M_thread_attr_set_create_joinable(tattr, M_TRUE);
    el_thread = M_thread_create(tattr, run_el, NULL);
    M_thread_attr_destroy(tattr);

    M_io_ble_scan(el, scan_done_cb, NULL, 5000);

    mrl = CFRunLoopGetCurrent();
    CFRunLoopRun();

    M_event_done_with_disconnect(el, 5*1000);
    M_thread_join(el_thread, NULL);

    return 0;
}
.fi
.PP
.PP
.SS "Application that implicitly scans and connects to a specified device which has not been seen and cached\&."
.PP
.PP
.nf
// Build:
// clang -g -fobjc-arc -framework CoreFoundation test_ble_connect_noscan\&.c -I \&.\&./\&.\&./include/ -L \&.\&./\&.\&./build/lib/ -l mstdlib_io -l mstdlib_thread -l mstdlib
//
// Run:
// DYLD_LIBRARY_PATH="\&.\&./\&.\&./build/lib/" \&./a\&.out

#include <mstdlib/mstdlib\&.h>
#include <mstdlib/mstdlib_thread\&.h>
#include <mstdlib/mstdlib_io\&.h>
#include <mstdlib/io/m_io_ble\&.h>

#include <CoreFoundation/CoreFoundation\&.h>

M_event_t    *el;
M_io_t       *io;
CFRunLoopRef  mrl = NULL;

void events(M_event_t *el, M_event_type_t etype, M_io_t *io, void *thunk)
{
    (void)el;
    (void)io;
    (void)thunk;

    switch (etype) {
        case M_EVENT_TYPE_CONNECTED:
            M_printf("CONNECTED!!!\n");
            M_io_disconnect(io);
            break;
        case M_EVENT_TYPE_DISCONNECTED:
            M_printf("DISCONNECTED!!!\n");
        case M_EVENT_TYPE_READ:
        case M_EVENT_TYPE_WRITE:
        case M_EVENT_TYPE_ACCEPT:
        case M_EVENT_TYPE_ERROR:
            M_io_destroy(io);
            if (mrl != NULL)
                CFRunLoopStop(mrl);
            break;
        case M_EVENT_TYPE_OTHER:
            break;
    }
}

static void *run_el(void *arg)
{
    (void)arg;
    M_event_loop(el, M_TIMEOUT_INF);
    return NULL;
}

int main(int argc, char **argv)
{
    M_threadid_t     el_thread;
    M_thread_attr_t *tattr;

    el = M_event_create(M_EVENT_FLAG_NONE);

    tattr = M_thread_attr_create();
    M_thread_attr_set_create_joinable(tattr, M_TRUE);
    el_thread = M_thread_create(tattr, run_el, NULL);
    M_thread_attr_destroy(tattr);

    // XXX: Set the id to the device you want to connect to\&.
    M_io_ble_create(&io, "92BD9AC6-3BC8-4B24-8BF8-AE583AFE3ED4", 5000);
    M_event_add(el, io, events, NULL);

    mrl = CFRunLoopGetCurrent();
    CFRunLoopRun();

    M_event_done_with_disconnect(el, 5*1000);
    M_thread_join(el_thread, NULL);

    return 0;
}
.fi
.PP
.PP
.SS "Application that reads by polling the device for a read using a write"
.PP
.PP
.nf
// Build:
// clang -g -fobjc-arc -framework CoreFoundation test_ble_readp\&.c -I \&.\&./\&.\&./include/ -L \&.\&./\&.\&./build/lib/ -l mstdlib_io -l mstdlib_thread -l mstdlib
//
// Run:
// DYLD_LIBRARY_PATH="\&.\&./\&.\&./build/lib/" \&./a\&.out

#include <mstdlib/mstdlib\&.h>
#include <mstdlib/mstdlib_thread\&.h>
#include <mstdlib/mstdlib_io\&.h>
#include <mstdlib/io/m_io_ble\&.h>

#include <CoreFoundation/CoreFoundation\&.h>

M_event_t    *el;
M_io_t       *dio;
M_io_meta_t  *wmeta;
CFRunLoopRef  mrl = NULL;

void events(M_event_t *el, M_event_type_t etype, M_io_t *io, void *thunk)
{
    M_int64      rssi  = M_INT64_MIN;
    M_io_meta_t *rmeta = NULL;
    const char  *service_uuid;
    const char  *characteristic_uuid;
    char         msg[256];
    size_t       len;

    (void)el;
    (void)io;
    (void)thunk;

    switch (etype) {
        case M_EVENT_TYPE_CONNECTED:
            M_printf("CONNECTED!!!\n");
            M_io_write_meta(dio, NULL, 0, NULL, wmeta);
            break;
        case M_EVENT_TYPE_READ:
            rmeta = M_io_meta_create();
            M_io_read_meta(dio, msg, sizeof(msg)-1, &len, rmeta);
            msg[len]            = '\0';
            service_uuid        = M_io_ble_meta_get_service(dio, rmeta);
            characteristic_uuid = M_io_ble_meta_get_charateristic(dio, rmeta);

            M_printf("%s - %s: %s\n", service_uuid, characteristic_uuid, msg);

            M_io_meta_destroy(rmeta);

            M_thread_sleep(100000);
            M_io_write_meta(dio, NULL, 0, NULL, wmeta);
            break;
        case M_EVENT_TYPE_WRITE:
            break;
        case M_EVENT_TYPE_ERROR:
            M_io_get_error_string(dio, msg, sizeof(msg));
            M_printf("ERROR: %s\n", msg);
        case M_EVENT_TYPE_DISCONNECTED:
            if (etype == M_EVENT_TYPE_DISCONNECTED)
                M_printf("DISCONNECTED!!!\n");
            M_io_destroy(dio);
            if (mrl != NULL)
                CFRunLoopStop(mrl);
            break;
        case M_EVENT_TYPE_ACCEPT:
        case M_EVENT_TYPE_OTHER:
            break;
    }
}

static void *run_el(void *arg)
{
    (void)arg;
    M_event_loop(el, M_TIMEOUT_INF);
    return NULL;
}

int main(int argc, char **argv)
{
    M_threadid_t     el_thread;
    M_thread_attr_t *tattr;

    el = M_event_create(M_EVENT_FLAG_NONE);

    tattr = M_thread_attr_create();
    M_thread_attr_set_create_joinable(tattr, M_TRUE);
    el_thread = M_thread_create(tattr, run_el, NULL);
    M_thread_attr_destroy(tattr);

    // XXX: Set the id to the device you want to connect to\&.
    M_io_ble_create(&dio, "92BD9AC6-3BC8-4B24-8BF8-AE583AFE3ED4", 5000);
    wmeta = M_io_meta_create();
    M_io_ble_meta_set_write_type(dio, wmeta, M_IO_BLE_WTYPE_REQVAL);
    M_io_ble_meta_set_service(dio, wmeta, "1111");
    M_io_ble_meta_set_characteristic(dio, wmeta, "2222");
    M_event_add(el, dio, events, NULL);

    mrl = CFRunLoopGetCurrent();
    CFRunLoopRun();

    M_event_done_with_disconnect(el, 5*1000);
    M_thread_join(el_thread, NULL);

    M_io_meta_destroy(wmeta);

    return 0;
}
.fi
.PP
.PP
.SS "Application that reads by requesting notification when value changes"
.PP
.PP
.nf
// Build:
// clang -g -fobjc-arc -framework CoreFoundation test_ble_readn\&.c -I \&.\&./\&.\&./include/ -L \&.\&./\&.\&./build/lib/ -l mstdlib_io -l mstdlib_thread -l mstdlib
//
// Run:
// DYLD_LIBRARY_PATH="\&.\&./\&.\&./build/lib/" \&./a\&.out

#include <mstdlib/mstdlib\&.h>
#include <mstdlib/mstdlib_thread\&.h>
#include <mstdlib/mstdlib_io\&.h>
#include <mstdlib/io/m_io_ble\&.h>

#include <CoreFoundation/CoreFoundation\&.h>

M_event_t    *el;
M_io_t       *dio;
CFRunLoopRef  mrl = NULL;

void events(M_event_t *el, M_event_type_t etype, M_io_t *io, void *thunk)
{
    M_int64      rssi  = M_INT64_MIN;
    M_io_meta_t *rmeta = NULL;
    const char  *service_uuid;
    const char  *characteristic_uuid;
    char         msg[256];
    size_t       len;

    (void)el;
    (void)io;
    (void)thunk;

    switch (etype) {
        case M_EVENT_TYPE_CONNECTED:
            M_printf("CONNECTED!!!\n");
            // XXX: Set notify service and characteristic\&.
            M_io_ble_set_notify(dio, "1111", "2222", M_TRUE);
            break;
        case M_EVENT_TYPE_READ:
            rmeta = M_io_meta_create();
            M_io_read_meta(dio, msg, sizeof(msg), &len, rmeta);
            msg[len]            = '\0';
            service_uuid        = M_io_ble_meta_get_service(dio, rmeta);
            characteristic_uuid = M_io_ble_meta_get_charateristic(dio, rmeta);

            M_printf("%s - %s: %s\n", service_uuid, characteristic_uuid, msg);

            M_io_meta_destroy(rmeta);

            M_thread_sleep(100000);
            break;
        case M_EVENT_TYPE_WRITE:
            break;
        case M_EVENT_TYPE_ERROR:
            M_io_get_error_string(dio, msg, sizeof(msg));
            M_printf("ERROR: %s\n", msg);
        case M_EVENT_TYPE_DISCONNECTED:
            if (etype == M_EVENT_TYPE_DISCONNECTED)
                M_printf("DISCONNECTED!!!\n");
            M_io_destroy(dio);
            if (mrl != NULL)
                CFRunLoopStop(mrl);
            break;
        case M_EVENT_TYPE_ACCEPT:
        case M_EVENT_TYPE_OTHER:
            break;
    }
}

static void *run_el(void *arg)
{
    (void)arg;
    M_event_loop(el, M_TIMEOUT_INF);
    return NULL;
}

int main(int argc, char **argv)
{
    M_threadid_t     el_thread;
    M_thread_attr_t *tattr;

    el = M_event_create(M_EVENT_FLAG_NONE);

    tattr = M_thread_attr_create();
    M_thread_attr_set_create_joinable(tattr, M_TRUE);
    el_thread = M_thread_create(tattr, run_el, NULL);
    M_thread_attr_destroy(tattr);

    // XXX: Set the id to the device you want to connect to\&.
    M_io_ble_create(&dio, "92BD9AC6-3BC8-4B24-8BF8-AE583AFE3ED4", 5000);
    M_event_add(el, dio, events, NULL);

    mrl = CFRunLoopGetCurrent();
    CFRunLoopRun();

    M_event_done_with_disconnect(el, 5*1000);
    M_thread_join(el_thread, NULL);

    return 0;
}
.fi
.PP
.PP
.SS "Application that uses writes to request current RSSI value\&."
.PP
.PP
.nf
// Build:
// clang -g -fobjc-arc -framework CoreFoundation test_ble_rssi\&.c -I \&.\&./\&.\&./include/ -L \&.\&./\&.\&./build/lib/ -l mstdlib_io -l mstdlib_thread -l mstdlib
//
// Run:
// DYLD_LIBRARY_PATH="\&.\&./\&.\&./build/lib/" \&./a\&.out

#include <mstdlib/mstdlib\&.h>
#include <mstdlib/mstdlib_thread\&.h>
#include <mstdlib/mstdlib_io\&.h>
#include <mstdlib/io/m_io_ble\&.h>

#include <CoreFoundation/CoreFoundation\&.h>

M_event_t    *el;
M_io_t       *dio;
M_io_meta_t  *wmeta;
CFRunLoopRef  mrl = NULL;

void events(M_event_t *el, M_event_type_t etype, M_io_t *io, void *thunk)
{
    M_int64      rssi  = M_INT64_MIN;
    M_io_meta_t *rmeta = NULL;
    char         msg[256];

    (void)el;
    (void)io;
    (void)thunk;

    switch (etype) {
        case M_EVENT_TYPE_CONNECTED:
            M_printf("CONNECTED!!!\n");
            M_io_write_meta(dio, NULL, 0, NULL, wmeta);
            break;
        case M_EVENT_TYPE_READ:
            rmeta = M_io_meta_create();
            M_io_read_meta(dio, NULL, 0, NULL, rmeta);
            M_io_ble_meta_get_rssi(dio, rmeta, &rssi);
            M_io_meta_destroy(rmeta);

            M_printf("RSSI = %lld\n", rssi);

            M_thread_sleep(100000);
            M_io_write_meta(dio, NULL, 0, NULL, wmeta);
            break;
        case M_EVENT_TYPE_WRITE:
            break;
        case M_EVENT_TYPE_ERROR:
            M_io_get_error_string(dio, msg, sizeof(msg));
            M_printf("ERROR: %s\n", msg);
        case M_EVENT_TYPE_DISCONNECTED:
            if (etype == M_EVENT_TYPE_DISCONNECTED)
                M_printf("DISCONNECTED!!!\n");
            M_io_destroy(dio);
            if (mrl != NULL)
                CFRunLoopStop(mrl);
            break;
        case M_EVENT_TYPE_ACCEPT:
        case M_EVENT_TYPE_OTHER:
            break;
    }
}

static void *run_el(void *arg)
{
    (void)arg;
    M_event_loop(el, M_TIMEOUT_INF);
    return NULL;
}

int main(int argc, char **argv)
{
    M_threadid_t     el_thread;
    M_thread_attr_t *tattr;

    el = M_event_create(M_EVENT_FLAG_NONE);

    tattr = M_thread_attr_create();
    M_thread_attr_set_create_joinable(tattr, M_TRUE);
    el_thread = M_thread_create(tattr, run_el, NULL);
    M_thread_attr_destroy(tattr);

    // XXX: Set the id to the device you want to connect to\&.
    M_io_ble_create(&dio, "92BD9AC6-3BC8-4B24-8BF8-AE583AFE3ED4", 5000);
    wmeta = M_io_meta_create();
    M_io_ble_meta_set_write_type(dio, wmeta, M_IO_BLE_WTYPE_REQRSSI);
    M_event_add(el, dio, events, NULL);

    mrl = CFRunLoopGetCurrent();
    CFRunLoopRun();

    M_event_done_with_disconnect(el, 5*1000);
    M_thread_join(el_thread, NULL);

    M_io_meta_destroy(wmeta);

    return 0;
}
.fi
.PP
.PP
.SS "Application that writes"
.PP
.PP
.nf
// Build:
// clang -g -fobjc-arc -framework CoreFoundation test_ble_write\&.c -I \&.\&./\&.\&./include/ -L \&.\&./\&.\&./build/lib/ -l mstdlib_io -l mstdlib_thread -l mstdlib
//
// Run:
// DYLD_LIBRARY_PATH="\&.\&./\&.\&./build/lib/" \&./a\&.out

#include <mstdlib/mstdlib\&.h>
#include <mstdlib/mstdlib_thread\&.h>
#include <mstdlib/mstdlib_io\&.h>
#include <mstdlib/io/m_io_ble\&.h>

#include <CoreFoundation/CoreFoundation\&.h>

M_event_t    *el;
M_io_t       *dio;
M_io_meta_t  *meta;
CFRunLoopRef  mrl = NULL;

void events(M_event_t *el, M_event_type_t etype, M_io_t *io, void *thunk)
{
    size_t        len = 0;
    static size_t num = 1;
    char          msg[256];
    M_io_error_t  ret;

    (void)el;
    (void)io;
    (void)thunk;

    M_snprintf(msg, sizeof(msg), "%zu", num++);

    switch (etype) {
        case M_EVENT_TYPE_CONNECTED:
            M_printf("CONNECTED!!!\n");
            M_io_write_meta(dio, (const unsigned char *)msg, M_str_len(msg), &len, meta);
            break;
        case M_EVENT_TYPE_READ:
            break;
        case M_EVENT_TYPE_WRITE:
            M_printf("WRITE\n");
            M_io_write_meta(dio, (const unsigned char *)msg, M_str_len(msg), &len, meta);
            M_thread_sleep(100000);
            break;
        case M_EVENT_TYPE_ERROR:
            M_io_get_error_string(dio, msg, sizeof(msg));
            M_printf("ERROR: %s\n", msg);
        case M_EVENT_TYPE_DISCONNECTED:
            if (etype == M_EVENT_TYPE_DISCONNECTED)
                M_printf("DISCONNECTED!!!\n");
            M_io_destroy(dio);
            if (mrl != NULL)
                CFRunLoopStop(mrl);
            break;
        case M_EVENT_TYPE_ACCEPT:
        case M_EVENT_TYPE_OTHER:
            break;
    }
}

static void *run_el(void *arg)
{
    (void)arg;
    M_event_loop(el, M_TIMEOUT_INF);
    return NULL;
}

int main(int argc, char **argv)
{
    M_threadid_t     el_thread;
    M_thread_attr_t *tattr;

    el = M_event_create(M_EVENT_FLAG_NONE);

    tattr = M_thread_attr_create();
    M_thread_attr_set_create_joinable(tattr, M_TRUE);
    el_thread = M_thread_create(tattr, run_el, NULL);
    M_thread_attr_destroy(tattr);

    // XXX: Set the id to the device you want to connect to\&.
    M_io_ble_create(&dio, "92BD9AC6-3BC8-4B24-8BF8-AE583AFE3ED4", 5000);
    meta = M_io_meta_create();
    M_io_ble_meta_set_service(dio, meta, "1111");
    M_io_ble_meta_set_characteristic(dio, meta, "2222");
    M_event_add(el, dio, events, NULL);

    mrl = CFRunLoopGetCurrent();
    CFRunLoopRun();

    M_event_done_with_disconnect(el, 5*1000);
    M_thread_join(el_thread, NULL);

    M_io_meta_destroy(meta);

    return 0;
}
.fi
.PP
 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBM_io_ble_enum\fP \fBM_io_ble_enum_t\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_io_ble_wtype_t\fP"
Meta property types used by M_io_write_meta\&.
.PP
Specifies how the write should function\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_IO_BLE_WTYPE_WRITE \fP\fP
Normal write\&. Waits for confirmation data was written before writes can take place again\&. 
.TP
\fB\fIM_IO_BLE_WTYPE_WRITENORESP \fP\fP
Write without confirmation response\&. Blind write\&. 
.TP
\fB\fIM_IO_BLE_WTYPE_REQVAL \fP\fP
Request value for service and characteristic\&. Not an actual write but a pseudo write to poll for a read event\&. 
.TP
\fB\fIM_IO_BLE_WTYPE_REQRSSI \fP\fP
Request RSSI value\&. 
.SS "enum \fBM_io_ble_rtype_t\fP"
Meta types used by M_io_read_meta\&.
.PP
Specifies what type of read is being returned\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_IO_BLE_RTYPE_READ \fP\fP
Regular read of data from service and characteristic\&. 
.TP
\fB\fIM_IO_BLE_RTYPE_RSSI \fP\fP
RSSI data read\&. Use M_io_ble_meta_get_rssi\&. 
.SH "Function Documentation"
.PP 
.SS "M_bool M_io_ble_scan (\fBM_event_t\fP * event, \fBM_event_callback_t\fP callback, void * cb_data, M_uint64 timeout_ms)"
Start a BLE scan\&.
.PP
A scan needs to take place for nearby devices to be found\&. Once found they will appear in an enumeration\&.
.PP
Opening a known device does not require explicitly scanning\&. Scanning will happen implicitly if the device has not been seen before\&.
.PP
\fBWarning:\fP
.RS 4
On macOS the callback will never be called if the main event loop is not running!
.RE
.PP
\fBParameters:\fP
.RS 4
\fIevent\fP Event handle to receive scan events\&. 
.br
\fIcallback\fP User-specified callback to call when the scan finishes 
.br
\fIcb_data\fP Optional\&. User-specified data supplied to user-specified callback when executed\&. 
.br
\fItimeout_ms\fP How long the scan should run before stopping\&. 0 will default to 1 minute\&. Scanning for devices can take a long time\&. During testing of a simple pedometer times upwards of 50 seconds were seen before the device was detected while sitting 6 inches away\&. A maximum of 5 minutes is allowed\&. Any amount larger will be reduced to the max\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the scan was started and the callback will be called\&. Otherwise M_FALSE, the callback will not be called\&. 
.RE
.PP

.SS "\fBM_io_ble_enum_t\fP* M_io_ble_enum (void)"
Create a ble enumeration object\&.
.PP
You must call M_io_ble_scan to populate the enumeration\&. Failing to do so will result in an empty enumeration\&.
.PP
Use to determine what ble devices are connected and what services are being offered\&. This is a list of associated devices not necessarily what's actively connected\&.
.PP
The enumeration is based on available services\&. Meaning a device may be listed multiple times if it exposes multiple services\&.
.PP
\fBReturns:\fP
.RS 4
Bluetooth enumeration object\&. 
.RE
.PP

.SS "void M_io_ble_enum_destroy (\fBM_io_ble_enum_t\fP * btenum)"
Destroy a ble enumeration object\&.
.PP
\fBParameters:\fP
.RS 4
\fIbtenum\fP Bluetooth enumeration object\&. 
.RE
.PP

.SS "size_t M_io_ble_enum_count (const \fBM_io_ble_enum_t\fP * btenum)"
Number of ble objects in the enumeration\&.
.PP
\fBParameters:\fP
.RS 4
\fIbtenum\fP Bluetooth enumeration object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Count of ble devices\&. 
.RE
.PP

.SS "const char* M_io_ble_enum_name (const \fBM_io_ble_enum_t\fP * btenum, size_t idx)"
Name of ble device as reported by the device\&.
.PP
\fBParameters:\fP
.RS 4
\fIbtenum\fP Bluetooth enumeration object\&. 
.br
\fIidx\fP Index in ble enumeration\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "const char* M_io_ble_enum_uuid (const \fBM_io_ble_enum_t\fP * btenum, size_t idx)"
UUID of ble device\&.
.PP
\fBParameters:\fP
.RS 4
\fIbtenum\fP Bluetooth enumeration object\&. 
.br
\fIidx\fP Index in ble enumeration\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "M_bool M_io_ble_enum_connected (const \fBM_io_ble_enum_t\fP * btenum, size_t idx)"
Whether the device is connected\&.
.PP
This does not mean it is currently in use\&. It means the device is present and connected to the OS\&. This is mainly a way to determine if a device in the enumeration is still within range and can be used\&.
.PP
Not all systems are able to report the connected status making this function less useful than you would think\&.
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the device is connected, otherwise M_FALSE\&. If it is not possible to determine the connected status this function will return M_TRUE\&. 
.RE
.PP

.SS "const char* M_io_ble_enum_service_uuid (const \fBM_io_ble_enum_t\fP * btenum, size_t idx)"
Uuid of service reported by device\&.
.PP
\fBParameters:\fP
.RS 4
\fIbtenum\fP Bluetooth enumeration object\&. 
.br
\fIidx\fP Index in ble enumeration\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "\fBM_time_t\fP M_io_ble_enum_last_seen (const \fBM_io_ble_enum_t\fP * btenum, size_t idx)"
Last time the device was seen\&.
.PP
Run a scan to ensure this is up to date\&. Opening a device will also update the last seen time\&.
.PP
\fBParameters:\fP
.RS 4
\fIbtenum\fP Bluetooth enumeration object\&. 
.br
\fIidx\fP Index in ble enumeration\&.
.RE
.PP
\fBReturns:\fP
.RS 4
time\&. 
.RE
.PP

.SS "\fBM_io_error_t\fP M_io_ble_create (\fBM_io_t\fP ** io_out, const char * uuid, M_uint64 timeout_ms)"
Create a ble connection\&.
.PP
\fBParameters:\fP
.RS 4
\fIio_out\fP io object for communication\&. 
.br
\fIuuid\fP Required uuid of the device\&. 
.br
\fItimeout_ms\fP If the device has not already been seen a scan will be performed\&. This time out is how long we should wait to search for the device\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SS "\fBM_io_error_t\fP M_io_ble_set_notify (\fBM_io_t\fP * io, const char * service_uuid, const char * characteristic_uuid, M_bool enable)"
Request read event's when the characteristic's value changes\&.
.PP
Not all characteristic's support notifications\&. If not supported polling with M_io_write_meta using M_IO_BLE_WTYPE_REQVAL is the only way to retrieve the current value\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIservice_uuid\fP UUID of service\&. 
.br
\fIcharacteristic_uuid\fP UUID of characteristic\&. 
.br
\fIenable\fP Receive notifications?
.RE
.PP
\fBReturns:\fP
.RS 4
Result 
.RE
.PP

.SS "\fBM_list_str_t\fP* M_io_ble_get_services (\fBM_io_t\fP * io)"
Get a list of service UUIDs provided by the device\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
List of strings\&. 
.RE
.PP

.SS "\fBM_list_str_t\fP* M_io_ble_get_service_characteristics (\fBM_io_t\fP * io, const char * service_uuid)"
Get a list of characteristic UUIDs provided a service provided by the device\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIservice_uuid\fP UUID of service\&.
.RE
.PP
\fBReturns:\fP
.RS 4
List of strings\&. 
.RE
.PP

.SS "void M_io_ble_get_max_write_sizes (\fBM_io_t\fP * io, size_t * with_response, size_t * without_response)"
Get the maximum write sizes from an io object\&.
.PP
Queries the highest BLE layer in the stack, if there are more than one\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIwith_response\fP The maximum size that will receive a response\&. 
.br
\fIwithout_response\fP The maximum size that will not receive a response\&. 
.RE
.PP

.SS "const char* M_io_ble_meta_get_service (\fBM_io_t\fP * io, \fBM_io_meta_t\fP * meta)"
Get the service associated with a meta object\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fImeta\fP Meta\&.
.RE
.PP
\fBReturns:\fP
.RS 4
UUID 
.RE
.PP

.SS "const char* M_io_ble_meta_get_charateristic (\fBM_io_t\fP * io, \fBM_io_meta_t\fP * meta)"
Get the characteristic associated with a meta object\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fImeta\fP Meta\&.
.RE
.PP
\fBReturns:\fP
.RS 4
UUID 
.RE
.PP

.SS "\fBM_io_ble_wtype_t\fP M_io_ble_meta_get_write_type (\fBM_io_t\fP * io, \fBM_io_meta_t\fP * meta)"
Get the write type\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fImeta\fP Meta\&.
.RE
.PP
\fBReturns:\fP
.RS 4
type\&. 
.RE
.PP

.SS "\fBM_io_ble_rtype_t\fP M_io_ble_meta_get_read_type (\fBM_io_t\fP * io, \fBM_io_meta_t\fP * meta)"
Get the read type\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fImeta\fP Meta\&.
.RE
.PP
\fBReturns:\fP
.RS 4
type\&. 
.RE
.PP

.SS "M_bool M_io_ble_meta_get_rssi (\fBM_io_t\fP * io, \fBM_io_meta_t\fP * meta, M_int64 * rssi)"
Get the RSSI value from an RSSI read\&.
.PP
RSSI value is in decibels\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fImeta\fP Meta\&. 
.br
\fIrssi\fP RSSI value\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if RSSI read\&. Otherwise, M_FALSE\&. 
.RE
.PP

.SS "void M_io_ble_meta_set_service (\fBM_io_t\fP * io, \fBM_io_meta_t\fP * meta, const char * service_uuid)"
Set the service associated with a meta object\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fImeta\fP Meta\&. 
.br
\fIservice_uuid\fP UUID of service\&. 
.RE
.PP

.SS "void M_io_ble_meta_set_characteristic (\fBM_io_t\fP * io, \fBM_io_meta_t\fP * meta, const char * characteristic_uuid)"
Set the characteristic associated with a meta object\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fImeta\fP Meta\&. 
.br
\fIcharacteristic_uuid\fP UUID of characteristic\&. 
.RE
.PP

.SS "void M_io_ble_meta_set_write_type (\fBM_io_t\fP * io, \fBM_io_meta_t\fP * meta, \fBM_io_ble_wtype_t\fP type)"
Set whether a write should be blind\&.
.PP
If the type is not set, the default is to have writes wait for confirmation response before subsequent writes will be allowed\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fImeta\fP Meta\&. 
.br
\fItype\fP Property controlling 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
