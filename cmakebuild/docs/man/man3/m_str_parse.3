.TH "m_str_parse" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_str_parse
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "char * \fBM_str_split_on_char\fP (char *s, char c)"
.br
.ti -1c
.RI "char ** \fBM_str_explode\fP (unsigned char delim, const char *s, size_t s_len, size_t *num, size_t **len_array) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char ** \fBM_str_explode_quoted\fP (unsigned char delim, const char *s, size_t s_len, unsigned char quote_char, unsigned char escape_char, size_t max_sects, size_t *num, size_t **len_array) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char ** \fBM_str_explode_str\fP (unsigned char delim, const char *s, size_t *num) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char ** \fBM_str_explode_lines\fP (size_t max_lines, size_t max_chars, const char *src_str, M_bool truncate, size_t *num) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char ** \fBM_str_explode_str_quoted\fP (unsigned char delim, const char *s, unsigned char quote_char, unsigned char escape_char, size_t max_sects, size_t *num) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "int * \fBM_str_explode_int\fP (unsigned char delim, const char *s, size_t *num) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "void \fBM_str_explode_free\fP (char **strs, size_t num) M_FREE(1)"
.br
.ti -1c
.RI "char * \fBM_str_implode\fP (unsigned char delim, unsigned char enclose_char, unsigned char escape_char, char **strs, size_t num_strs, M_bool always_enclose) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_str_implode_int\fP (unsigned char delim, const int *ints, size_t num_ints) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.in -1c
.SH "Detailed Description"
.PP 
String Parsing and Joining Functions 
.SH "Function Documentation"
.PP 
.SS "char* M_str_split_on_char (char * s, char c)"
Clobber the first occurrence of character c in string s with NULL and return a pointer to the successive character\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP String to break into segments\&. 
.br
\fIc\fP Character at which to break into segments\&.
.RE
.PP
\fBReturns:\fP
.RS 4
NULL if s is NULL\&. Pointer to trailing NULL if c not found in s\&. Otherwise pointer to the character following the first occurrence of c in s\&. 
.RE
.PP

.SS "char** M_str_explode (unsigned char delim, const char * s, size_t s_len, size_t * num, size_t ** len_array)"
Find each substring of s delimited by delim and additionally record each substring's length\&.
.PP
The string can contain the character '\\0' and will be processed up to \fCs_len\fP\&. All parts will be NULL terminated\&.
.PP
Empty list elements (consecutive delimiters) will produce empty strings in the output array\&.
.PP
The last length of len_array will include any trailing '\\0'\&.
.PP
\fBParameters:\fP
.RS 4
\fIdelim\fP Delimiter\&. 
.br
\fIs\fP String to search\&. 
.br
\fIs_len\fP Length of string\&. 
.br
\fInum\fP The size of len_array and the returned array\&. 
.br
\fIlen_array\fP An array of size num containing the lengths of the substrings\&.
.RE
.PP
\fBReturns:\fP
.RS 4
an array of length num containing all substrings\&. 
.RE
.PP

.SS "char** M_str_explode_quoted (unsigned char delim, const char * s, size_t s_len, unsigned char quote_char, unsigned char escape_char, size_t max_sects, size_t * num, size_t ** len_array)"
Find each substring of s taking into account quoting\&.
.PP
The string can contain the character '\\0' and will be processed up to \fCs_len\fP\&. All parts are guaranteed to be NULL terminated\&. This takes into account if the delimiter is within a quote\&. Also allows the quote character to be escaped and not treated as a quote character\&.
.PP
An example of this would be CSV parsing\&. ',' is a delimiter but if it's in ''' it is not\&. '
 within a ' is escaped with " to denote that isn't the end of the quote\&.
.PP
Empty list elements (consecutive delimiters) will produce empty strings in the output array\&.
.PP
\fBParameters:\fP
.RS 4
\fIdelim\fP Delimiter\&. 
.br
\fIs\fP String to search\&. 
.br
\fIs_len\fP Length of string\&. 
.br
\fIquote_char\fP Character to use to denote quoted segments\&. Use 0 if not needed\&. 
.br
\fIescape_char\fP Character to use for escaping the quote character\&. Can be the same as the quote character\&. use 0 if not needed\&. 
.br
\fImax_sects\fP Maximum number of parts to return\&. The last part will have remaining data after last allowed split\&. Use 0 to disable and return all parts\&. 
.br
\fInum\fP the size of len_array and the returned array\&. 
.br
\fIlen_array\fP An array of size num containing the lengths of the substrings\&.
.RE
.PP
\fBReturns:\fP
.RS 4
an array of num string containing all substrings\&. 
.RE
.PP

.SS "char** M_str_explode_str (unsigned char delim, const char * s, size_t * num)"
Find each substring of s (a NULL terminated string)\&.
.PP
s will only be read until the first NULL\&. All parts are guaranteed to be NULL terminated\&.
.PP
Empty list elements (consecutive delimiters) will produce empty strings in the output array\&.
.PP
\fBParameters:\fP
.RS 4
\fIdelim\fP Delimiter\&. 
.br
\fIs\fP String to search\&. 
.br
\fInum\fP The size of len_array and the returned array\&.
.RE
.PP
\fBReturns:\fP
.RS 4
an array of num string containing all substrings\&. 
.RE
.PP

.SS "char** M_str_explode_lines (size_t max_lines, size_t max_chars, const char * src_str, M_bool truncate, size_t * num)"
Split a string among the given number of lines, while keeping words intact\&.
.PP
After you're done with the returned array, you must free it with \fBM_str_explode_free()\fP\&.
.PP
Words in this context are defined as contiguous blocks of non-whitespace characters\&. For each line, leading and trailing whitespace will be trimmed, but internal whitespace will be left alone\&.
.PP
An example use case is breaking up strings for display on small LCD screens\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_str_explode_free\fP 
.PP
\fBM_buf_add_str_lines\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fImax_lines\fP Maximum number of lines to output\&. 
.br
\fImax_chars\fP Maximum characters per line\&. 
.br
\fIsrc_str\fP Source string\&. 
.br
\fItruncate\fP If true, truncation is allowed\&. If false, NULL will be returned if the string won't fit\&. 
.br
\fInum\fP Number of lines displayed\&. Will be zero, if no output text was produced\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Array of strings where each is a line, or NULL if no output text was produced\&. 
.RE
.PP

.SS "char** M_str_explode_str_quoted (unsigned char delim, const char * s, unsigned char quote_char, unsigned char escape_char, size_t max_sects, size_t * num)"
Find each substring of s (a NULL terminated string) taking into account quoting\&.
.PP
s will only be read until the first NULL\&. All parts are guaranteed to be NULL terminated\&. This takes into account if the delimiter is within a quote\&. Also allows the quote character to be escaped and not treated as a quote character\&.
.PP
An example of this would be CSV parsing\&. ',' is a delimiter but if it's in ''' it is not\&. '
within a ' is escaped with " to denote that isn't the end of the quote\&.
.PP
\fBParameters:\fP
.RS 4
\fIdelim\fP Delimiter\&. 
.br
\fIs\fP String to search\&. 
.br
\fIquote_char\fP Character to use to denote quoted segments\&. Use 0 if not needed\&. 
.br
\fIescape_char\fP Character to use for escaping the quote character\&. Can be the same as the quote character\&. use 0 if not needed\&. 
.br
\fImax_sects\fP Maximum number of parts to return\&. The last part will have remaining data after last allowed split\&. Use 0 to disable and return all parts\&. 
.br
\fInum\fP the size of len_array and the returned array\&.
.RE
.PP
\fBReturns:\fP
.RS 4
an array of num string containing all substrings\&. 
.RE
.PP

.SS "int* M_str_explode_int (unsigned char delim, const char * s, size_t * num)"
Given a string containing an list of integers delimited by delim, return an array containing the integer values\&.
.PP
For example, after calling: ints = M_str_explode_int(',', '-10,11,13,,,,-15', &num) then the returns values will be: num=4 ints[0] = -10 ints[1] = 11 ints[2] = 13 ints[3] = -15
.PP
\fBParameters:\fP
.RS 4
\fIdelim\fP Delimiter\&. 
.br
\fIs\fP String containing the integer list\&. 
.br
\fInum\fP The number of integers in the returned array\&.
.RE
.PP
\fBReturns:\fP
.RS 4
an array containing num integers\&. 
.RE
.PP

.SS "void M_str_explode_free (char ** strs, size_t num)"
Free the substrings found by M_str_explode*\&.
.PP
\fBParameters:\fP
.RS 4
\fIstrs\fP An array of strings returned by M_str_explode*\&. 
.br
\fInum\fP The number of strings in strs\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_str_explode\fP 
.RE
.PP

.SS "char* M_str_implode (unsigned char delim, unsigned char enclose_char, unsigned char escape_char, char ** strs, size_t num_strs, M_bool always_enclose)"
Join an array of string separated by a delimiter and quoted if the delimiter is present in a string\&.
.PP
\fBParameters:\fP
.RS 4
\fIdelim\fP Delimiter\&. 
.br
\fIenclose_char\fP Character to use for quoting\&. 
.br
\fIescape_char\fP Character used for escaping the quote character if it's found in a string\&. 
.br
\fIstrs\fP array of string to join\&. 
.br
\fInum_strs\fP Number of string in the array of strings\&. 
.br
\fIalways_enclose\fP M_TRUE if all string should be quoted\&. M_FALSE if strings are only quoted when necessary\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Joined string\&. 
.RE
.PP

.SS "char* M_str_implode_int (unsigned char delim, const int * ints, size_t num_ints)"
Convert an array of signed integers into a string representation where each integer is delimited by a given character\&.
.PP
For example: M_str_implode_int('|', {1,-22,333}, 3) => '1|-22|333'
.PP
\fBParameters:\fP
.RS 4
\fIdelim\fP Delimiter\&. 
.br
\fIints\fP String containing the integer list\&. 
.br
\fInum_ints\fP The number of integers in the returned array\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String representation of integer list\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
