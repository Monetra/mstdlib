.TH "m_list_u64" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_list_u64
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct M_list_u64 \fBM_list_u64_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_list_u64_flags_t\fP { \fBM_LIST_U64_NONE\fP = 1 << 0, \fBM_LIST_U64_SORTASC\fP = 1 << 1, \fBM_LIST_U64_SORTDESC\fP = 1 << 2, \fBM_LIST_U64_STABLE\fP = 1 << 3, \fBM_LIST_U64_STACK\fP = 1 << 4, \fBM_LIST_U64_SET\fP = 1 << 5, \fBM_LIST_U64_NEVERSHRINK\fP = 1 << 6 }"
.br
.ti -1c
.RI "enum \fBM_list_u64_match_type_t\fP { \fBM_LIST_U64_MATCH_VAL\fP = 0, \fBM_LIST_U64_MATCH_ALL\fP = 1 << 0 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_list_u64_t\fP * \fBM_list_u64_create\fP (M_uint32 flags) M_MALLOC"
.br
.ti -1c
.RI "void \fBM_list_u64_destroy\fP (\fBM_list_u64_t\fP *d) M_FREE(1)"
.br
.ti -1c
.RI "void \fBM_list_u64_change_sorting\fP (\fBM_list_u64_t\fP *d, M_uint32 flags)"
.br
.ti -1c
.RI "M_bool \fBM_list_u64_insert\fP (\fBM_list_u64_t\fP *d, M_uint64 val)"
.br
.ti -1c
.RI "size_t \fBM_list_u64_insert_idx\fP (const \fBM_list_u64_t\fP *d, M_uint64 *val)"
.br
.ti -1c
.RI "M_bool \fBM_list_u64_insert_at\fP (\fBM_list_u64_t\fP *d, M_uint64 val, size_t idx)"
.br
.ti -1c
.RI "void \fBM_list_u64_insert_begin\fP (\fBM_list_u64_t\fP *d)"
.br
.ti -1c
.RI "void \fBM_list_u64_insert_end\fP (\fBM_list_u64_t\fP *d)"
.br
.ti -1c
.RI "size_t \fBM_list_u64_len\fP (const \fBM_list_u64_t\fP *d)"
.br
.ti -1c
.RI "size_t \fBM_list_u64_count\fP (const \fBM_list_u64_t\fP *d, M_uint64 val)"
.br
.ti -1c
.RI "M_bool \fBM_list_u64_index_of\fP (const \fBM_list_u64_t\fP *d, M_uint64 val, size_t *idx)"
.br
.ti -1c
.RI "M_uint64 \fBM_list_u64_first\fP (const \fBM_list_u64_t\fP *d)"
.br
.ti -1c
.RI "M_uint64 \fBM_list_u64_last\fP (const \fBM_list_u64_t\fP *d)"
.br
.ti -1c
.RI "M_uint64 \fBM_list_u64_at\fP (const \fBM_list_u64_t\fP *d, size_t idx)"
.br
.ti -1c
.RI "M_uint64 \fBM_list_u64_take_first\fP (\fBM_list_u64_t\fP *d)"
.br
.ti -1c
.RI "M_uint64 \fBM_list_u64_take_last\fP (\fBM_list_u64_t\fP *d)"
.br
.ti -1c
.RI "M_uint64 \fBM_list_u64_take_at\fP (\fBM_list_u64_t\fP *d, size_t idx)"
.br
.ti -1c
.RI "M_bool \fBM_list_u64_remove_first\fP (\fBM_list_u64_t\fP *d)"
.br
.ti -1c
.RI "M_bool \fBM_list_u64_remove_last\fP (\fBM_list_u64_t\fP *d)"
.br
.ti -1c
.RI "M_bool \fBM_list_u64_remove_at\fP (\fBM_list_u64_t\fP *d, size_t idx)"
.br
.ti -1c
.RI "size_t \fBM_list_u64_remove_val\fP (\fBM_list_u64_t\fP *d, M_uint64 val, M_uint32 type)"
.br
.ti -1c
.RI "M_bool \fBM_list_u64_remove_range\fP (\fBM_list_u64_t\fP *d, size_t start, size_t end)"
.br
.ti -1c
.RI "void \fBM_list_u64_remove_duplicates\fP (\fBM_list_u64_t\fP *d)"
.br
.ti -1c
.RI "size_t \fBM_list_u64_replace_val\fP (\fBM_list_u64_t\fP *d, M_uint64 val, M_uint64 new_val, M_uint32 type)"
.br
.ti -1c
.RI "M_bool \fBM_list_u64_replace_at\fP (\fBM_list_u64_t\fP *d, M_uint64 val, size_t idx)"
.br
.ti -1c
.RI "M_bool \fBM_list_u64_swap\fP (\fBM_list_u64_t\fP *d, size_t idx1, size_t idx2)"
.br
.ti -1c
.RI "\fBM_list_u64_t\fP * \fBM_list_u64_duplicate\fP (const \fBM_list_u64_t\fP *d) M_MALLOC"
.br
.ti -1c
.RI "void \fBM_list_u64_merge\fP (\fBM_list_u64_t\fP **dest, \fBM_list_u64_t\fP *src, M_bool include_duplicates) M_FREE(2)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Dynamic list (array) for storing unsigned 64 bit integer values\&.
.PP
The list can be used in multiple ways:
.IP "\(bu" 2
Unsorted\&.
.IP "\(bu" 2
Sorted\&.
.IP "\(bu" 2
Queue (FIFO) (really just unsorted)\&.
.IP "\(bu" 2
Stack (LIFO) (which cannot be sorted)\&.
.IP "\(bu" 2
Set\&.
.PP
.PP
A list is indexable\&. Find is also supported\&.
.PP
Indexes in the list are 0 at head to len-1 at end (head \&.\&.\&. end)\&. Functions like M_list_first will return head and M_list_last will return end\&.
.PP
The index start changes in STACK mode\&. In STACK mode indexing is opposite\&. Head is len-1 and end is 0 (head \&.\&.\&. end)\&. Entries are still added to end\&. Functions like M_list_first will return end and M_list_last will return head\&. This is to accommodate STACKS where entries are inserted and removed from the same end\&.
.PP
The list is designed for efficient head removal\&. A value removed from head will not cause a memmove\&. Instead a start offset will be noted\&. If there is space before head (due to removals) then additions at head will be efficient as the empty space will be used and a memmove will be avoided\&. memmoves will occur when the size (not necessarly number of elements) of the list changes (expand and shink) and for removals in the middle of the list\&.
.PP
Sorted notes:
.IP "\(bu" 2
Sorting on insert and find (\fBM_list_u64_index_of()\fP) is done using binary insert/search\&.
.IP "\(bu" 2
When \fBM_list_insert_end()\fP is called after \fBM_list_insert_begin()\fP qsort will be used to sort the list\&. 
.PP

.SH "Typedef Documentation"
.PP 
.SS "typedef struct M_list_u64 \fBM_list_u64_t\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_list_u64_flags_t\fP"
Flags for controlling the behavior of the list\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_LIST_U64_NONE \fP\fP
Not sorting, asc compare\&. 
.TP
\fB\fIM_LIST_U64_SORTASC \fP\fP
Sort asc\&. 
.TP
\fB\fIM_LIST_U64_SORTDESC \fP\fP
Sort desc\&. 
.TP
\fB\fIM_LIST_U64_STABLE \fP\fP
Make insert, search and sort stable\&. 
.TP
\fB\fIM_LIST_U64_STACK \fP\fP
Last in First out mode\&. 
.TP
\fB\fIM_LIST_U64_SET \fP\fP
Don't allow duplicates in the list\&. Insert is increased by an additional O(n) operation (on top of the insert itself) in order to determine if a value is a duplicate for unsorted\&. Insert is increased by an additional O(log(n)) operation (on top of the insert itself) in order to determine if a value is a duplicate for sorted\&. 
.TP
\fB\fIM_LIST_U64_NEVERSHRINK \fP\fP
Never allow the list to shrink\&. 
.SS "enum \fBM_list_u64_match_type_t\fP"
Type of matching that should be used when searching/modifying a value in the list\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_LIST_U64_MATCH_VAL \fP\fP
Match based on the value (equality function)\&. 
.TP
\fB\fIM_LIST_U64_MATCH_ALL \fP\fP
Include all instances\&. 
.SH "Function Documentation"
.PP 
.SS "\fBM_list_u64_t\fP* M_list_u64_create (M_uint32 flags)"
Create a new dynamic list\&.
.PP
A dynamic list is a dynamically expanding array\&. Meaning the array will expand to accommodate new elements\&. The list can be, optionally, kept in sorted order\&.
.PP
\fBParameters:\fP
.RS 4
\fIflags\fP M_list_u64_flags_t flags for controlling behavior\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Allocated dynamic list for storing strings\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_u64_destroy\fP 
.RE
.PP

.SS "void M_list_u64_destroy (\fBM_list_u64_t\fP * d)"
Destory the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list to destory\&. 
.RE
.PP

.SS "void M_list_u64_change_sorting (\fBM_list_u64_t\fP * d, M_uint32 flags)"
Change the sorting behavior of the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIflags\fP M_list_u64_flags_t flags that control sorting\&. 
.RE
.PP

.SS "M_bool M_list_u64_insert (\fBM_list_u64_t\fP * d, M_uint64 val)"
Insert a value into the list\&.
.PP
If sorted the value will be inserted in sorted order\&. Otherwise it will be appended to the end of the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIval\fP The value to insert\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success otherwise M_FALSE\&. 
.RE
.PP

.SS "size_t M_list_u64_insert_idx (const \fBM_list_u64_t\fP * d, M_uint64 * val)"
Get the index a value would be insert into the list at\&.
.PP
This does not actually insert the value into the list it only gets the position the value would be insert into the list if/when insert is called\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIval\fP The value to get the insertion index for\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The insertion index\&. 
.RE
.PP

.SS "M_bool M_list_u64_insert_at (\fBM_list_u64_t\fP * d, M_uint64 val, size_t idx)"
Insert a value into the list at a specific position\&.
.PP
This is only supported for non-sorted lists\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIval\fP The value to insert\&. 
.br
\fIidx\fP The position to insert at\&. An index larger than the number of elements in the list will result in the item being inserted at the end\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success otherwise M_FALSE\&. 
.RE
.PP

.SS "void M_list_u64_insert_begin (\fBM_list_u64_t\fP * d)"
Start a grouped insertion\&.
.PP
This is only useful for sorted lists\&. This will defer sorting until \fBM_list_u64_insert_end()\fP is called\&. This is to allow many items to be inserted at once without the sorting overhead being called for every insertion\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_u64_insert_end\fP 
.RE
.PP

.SS "void M_list_u64_insert_end (\fBM_list_u64_t\fP * d)"
End a grouped insertion\&.
.PP
This is only useful for sorted lists\&. Cause all elements in the list (if sorting is enabled) to be sorted\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_u64_insert_begin\fP 
.RE
.PP

.SS "size_t M_list_u64_len (const \fBM_list_u64_t\fP * d)"
The length of the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBReturns:\fP
.RS 4
the length of the list\&. 
.RE
.PP

.SS "size_t M_list_u64_count (const \fBM_list_u64_t\fP * d, M_uint64 val)"
Count the number of times a value occurs in the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIval\fP The value to search for\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The number of times val appears in the list\&. 
.RE
.PP

.SS "M_bool M_list_u64_index_of (const \fBM_list_u64_t\fP * d, M_uint64 val, size_t * idx)"
Get the location of a value within the list\&.
.PP
This will return a location in the list which may not be the first occurrence in the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIval\fP The value to search for\&. 
.br
\fIidx\fP The index of the value within the list\&. Optional, pass NULL if not needed\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the value was found within the list\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_uint64 M_list_u64_first (const \fBM_list_u64_t\fP * d)"
Get the first element\&.
.PP
The element will remain a member of the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The element or NULL if there are no elements\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_u64_at\fP 
.PP
\fBM_list_u64_last\fP 
.RE
.PP

.SS "M_uint64 M_list_u64_last (const \fBM_list_u64_t\fP * d)"
Get the last element\&.
.PP
The element will remain a member of the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The element or NULL if there are no elements\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_at\fP 
.PP
\fBM_list_first\fP 
.RE
.PP

.SS "M_uint64 M_list_u64_at (const \fBM_list_u64_t\fP * d, size_t idx)"
Get the element at a given index\&.
.PP
The element will remain a member of the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIidx\fP The location to retrieve the element from\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The element or NULL if index is out range\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_u64_first\fP 
.PP
\fBM_list_u64_last\fP 
.RE
.PP

.SS "M_uint64 M_list_u64_take_first (\fBM_list_u64_t\fP * d)"
Take the first element\&.
.PP
The element will be removed from the list and returned\&. The caller is responsible for freeing the element\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The element or NULL if there are no elements\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_u64_take_at\fP 
.PP
\fBM_list_u64_last\fP 
.RE
.PP

.SS "M_uint64 M_list_u64_take_last (\fBM_list_u64_t\fP * d)"
Take the last element\&.
.PP
The element will be removed from the list and returned\&. The caller is responsible for freeing the element\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The element or NULL if there are no elements\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_u64_take_at\fP 
.PP
\fBM_list_u64_take_first\fP 
.RE
.PP

.SS "M_uint64 M_list_u64_take_at (\fBM_list_u64_t\fP * d, size_t idx)"
Take the element at a given index\&.
.PP
The element will be removed from the list and returned\&. The caller is responsible for freeing the element\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIidx\fP The location to retrieve the element from\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The element or NULL if index is out range\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_u64_take_first\fP 
.PP
\fBM_list_u64_take_last\fP 
.RE
.PP

.SS "M_bool M_list_u64_remove_first (\fBM_list_u64_t\fP * d)"
Remove the first element\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the element was removed\&. Otherwise M_FALSE\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_u64_remove_at\fP 
.PP
\fBM_list_u64_remove_last\fP 
.RE
.PP

.SS "M_bool M_list_u64_remove_last (\fBM_list_u64_t\fP * d)"
Remove the last element\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the element was removed\&. Otherwise M_FALSE\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_u64_remove_at\fP 
.PP
\fBM_list_u64_remove_first\fP 
.RE
.PP

.SS "M_bool M_list_u64_remove_at (\fBM_list_u64_t\fP * d, size_t idx)"
Remove an element at a given index from the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIidx\fP The index to remove\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the element was removed\&. Otherwise M_FALSE\&.
.RE
.PP
\\ see M_list_u64_remove_first \\ see M_list_u64_remove_last \\ see M_list_u64_remove_val \\ see M_list_u64_remove_range 
.SS "size_t M_list_u64_remove_val (\fBM_list_u64_t\fP * d, M_uint64 val, M_uint32 type)"
Remove element(s) from the list\&.
.PP
Searches the list for the occurrence of val and removes it from the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIval\fP The val to remove 
.br
\fItype\fP M_list_u64_match_type_t type of how the val should be matched\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The number of elements removed\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_u64_remove_at\fP 
.RE
.PP

.SS "M_bool M_list_u64_remove_range (\fBM_list_u64_t\fP * d, size_t start, size_t end)"
Remove a range of elements form the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIstart\fP The start index\&. Inclusive\&. 
.br
\fIend\fP The end index\&. Inclusive\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the range was removed\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "void M_list_u64_remove_duplicates (\fBM_list_u64_t\fP * d)"
Remove duplicate elements from the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.RE
.PP

.SS "size_t M_list_u64_replace_val (\fBM_list_u64_t\fP * d, M_uint64 val, M_uint64 new_val, M_uint32 type)"
Replace all matching values in the list with a different value\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIval\fP The val to be replaced\&. 
.br
\fInew_val\fP The value to be replaced with\&. 
.br
\fItype\fP M_list_u64_match_type_t type of how the val should be matched\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The number of elements replaced\&. 
.RE
.PP

.SS "M_bool M_list_u64_replace_at (\fBM_list_u64_t\fP * d, M_uint64 val, size_t idx)"
Replace a value in the list with a different value\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIval\fP The val to that will appear in the list at the given idx\&. 
.br
\fIidx\fP The index to replace\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the value was replaced\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_list_u64_swap (\fBM_list_u64_t\fP * d, size_t idx1, size_t idx2)"
Exchange the elements at the given locations\&.
.PP
This only applies to unsorted lists\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIidx1\fP The first index\&. 
.br
\fIidx2\fP The second index\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the elements were swapped\&. 
.RE
.PP

.SS "\fBM_list_u64_t\fP* M_list_u64_duplicate (const \fBM_list_u64_t\fP * d)"
Duplicate an existing list\&.
.PP
Will copy all elements of the list as well as any flags, etc\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP list to duplicate\&.
.RE
.PP
\fBReturns:\fP
.RS 4
New list\&. 
.RE
.PP

.SS "void M_list_u64_merge (\fBM_list_u64_t\fP ** dest, \fBM_list_u64_t\fP * src, M_bool include_duplicates)"
Merge two lists together\&.
.PP
The second (src) list will be destroyed automatically upon completion of this function\&. Any value pointers for the list will be directly copied over to the destination list, they will not be duplicated\&.
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP Pointer by reference to the list receiving the values\&. if this is NULL, the pointer will simply be switched out for src\&. 
.br
\fIsrc\fP Pointer to the list giving up its values\&. 
.br
\fIinclude_duplicates\fP When M_TRUE any values in 'dest' that also exist in 'src' will be included in 'dest'\&. When M_FALSE any duplicate values will not be added to 'dest'\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
