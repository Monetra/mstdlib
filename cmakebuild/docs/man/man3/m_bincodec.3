.TH "m_bincodec" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_bincodec
.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBM_BINCODEC_PEM_LINE_LEN\fP   64"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_bincodec_codec_t\fP { \fBM_BINCODEC_BASE64\fP, \fBM_BINCODEC_HEX\fP, \fBM_BINCODEC_BASE64ORHEX\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "size_t \fBM_bincodec_encode_size\fP (size_t inLen, size_t wrap, \fBM_bincodec_codec_t\fP codec)"
.br
.ti -1c
.RI "char * \fBM_bincodec_encode_alloc\fP (const M_uint8 *in, size_t inLen, size_t wrap, \fBM_bincodec_codec_t\fP codec) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "size_t \fBM_bincodec_encode\fP (char *out, size_t outLen, const M_uint8 *in, size_t inLen, size_t wrap, \fBM_bincodec_codec_t\fP codec)"
.br
.ti -1c
.RI "M_uint8 * \fBM_bincodec_decode_alloc\fP (const char *in, size_t inLen, size_t *outLen, \fBM_bincodec_codec_t\fP codec) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_bincodec_decode_str_alloc\fP (const char *in, \fBM_bincodec_codec_t\fP codec)"
.br
.ti -1c
.RI "size_t \fBM_bincodec_decode\fP (M_uint8 *out, size_t outLen, const char *in, size_t inLen, \fBM_bincodec_codec_t\fP codec)"
.br
.ti -1c
.RI "char * \fBM_bincodec_convert_alloc\fP (const char *in, size_t inLen, size_t wrap, \fBM_bincodec_codec_t\fP inCodec, \fBM_bincodec_codec_t\fP outCodec) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "size_t \fBM_bincodec_convert\fP (char *out, size_t outLen, size_t wrap, \fBM_bincodec_codec_t\fP outCodec, const char *in, size_t inLen, \fBM_bincodec_codec_t\fP inCodec)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Text to binary and binary to text conversion\&. Supports conversion of binary to or from base64 or hex\&.
.PP
Example:
.PP
.PP
.nf
const char *data = "abcd";
char       *out[16];
char       *odata;

M_bincodec_encode(out, sizeof(out), (M_uint8 *)data, M_str_len(data), 0, M_BINCODEC_HEX);
M_printf("hex='%s'\n", out);

M_bincodec_encode(out, sizeof(out), (M_uint8 *)data, M_str_len(data), 0, M_BINCODEC_BASE64);
M_printf("b64='%s'\n", out);

odata = (char *)M_bincodec_decode_alloc(out, M_str_len(out), NULL, M_BINCODEC_BASE64ORHEX);
M_printf("original='%s'\n", odata);

M_free(odata);
.fi
.PP
 
.SH "Macro Definition Documentation"
.PP 
.SS "#define M_BINCODEC_PEM_LINE_LEN   64"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_bincodec_codec_t\fP"
Binary conversion types\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_BINCODEC_BASE64 \fP\fP
Base64 encoding\&. 
.TP
\fB\fIM_BINCODEC_HEX \fP\fP
Hex encoding\&. 
.TP
\fB\fIM_BINCODEC_BASE64ORHEX \fP\fP
Auto detected between base64 and hex encoding\&. 
.SH "Function Documentation"
.PP 
.SS "size_t M_bincodec_encode_size (size_t inLen, size_t wrap, \fBM_bincodec_codec_t\fP codec)"
The maximumn number of bytes necessary to encode using the specified codec\&.
.PP
\fBParameters:\fP
.RS 4
\fIinLen\fP The length of the input to encode\&. 
.br
\fIwrap\fP The maximum length of a given line\&. Longer lines will be split with a new line\&. Pass 0 if line splitting is not desired\&. 
.br
\fIcodec\fP The binary coded used for encoding\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The maximumn number of bytes that would be used to encode the data\&. 
.RE
.PP

.SS "char* M_bincodec_encode_alloc (const M_uint8 * in, size_t inLen, size_t wrap, \fBM_bincodec_codec_t\fP codec)"
Encodes data passed into it using the specified binary codec\&.
.PP
\fBParameters:\fP
.RS 4
\fIin\fP The binary data to encode\&. 
.br
\fIinLen\fP The length of the input data\&. 
.br
\fIcodec\fP The binary codec to use for encoding\&. 
.br
\fIwrap\fP The maximum length of a given line\&. Longer lines will be split with a new line\&. Pass 0 if line splitting is not desired\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A new NULL terminated string with the encoded data\&. Otherwise NULL on error\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_free\fP 
.RE
.PP

.SS "size_t M_bincodec_encode (char * out, size_t outLen, const M_uint8 * in, size_t inLen, size_t wrap, \fBM_bincodec_codec_t\fP codec)"
Encodes data passed into it using the specified binary codec\&.
.PP
\fBParameters:\fP
.RS 4
\fIout\fP A buffer large enought to hold the encoded data\&. 
.br
\fIoutLen\fP The length of the output buffer\&. 
.br
\fIin\fP The binary data to encode\&. 
.br
\fIinLen\fP The length of the input data\&. 
.br
\fIcodec\fP The binary codec to use for encoding\&. 
.br
\fIwrap\fP The maximum length of a given line\&. Longer lines will be split with a new line\&. Pass 0 if line splitting is not desired\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The number of bytes written into the output buffer\&. 
.RE
.PP

.SS "M_uint8* M_bincodec_decode_alloc (const char * in, size_t inLen, size_t * outLen, \fBM_bincodec_codec_t\fP codec)"
Decodes data passed into it using the specified binary codec\&.
.PP
\fBParameters:\fP
.RS 4
\fIin\fP The string data to decode\&. 
.br
\fIinLen\fP The length of the input data\&. 
.br
\fIoutLen\fP The length ouf the buffer\&. 
.br
\fIcodec\fP The binary codec to use for decoding\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A new array with the decoded data\&. Otherwise NULL on error\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_free\fP 
.RE
.PP

.SS "char* M_bincodec_decode_str_alloc (const char * in, \fBM_bincodec_codec_t\fP codec)"
Convenience function for validating decoded data is a string\&. Some protocols may encode string data even if it is not necessary, so this function helps validate that data is really in string form to prevent issues\&.
.PP
\fBParameters:\fP
.RS 4
\fIin\fP The string data to decode\&. 
.br
\fIcodec\fP The binary codec to use for decoding\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
A new buffer with decoded data, otherwise NULL on error\&. 
.RE
.PP

.SS "size_t M_bincodec_decode (M_uint8 * out, size_t outLen, const char * in, size_t inLen, \fBM_bincodec_codec_t\fP codec)"
Decodes data passed into it using the specified binary codec\&.
.PP
\fBParameters:\fP
.RS 4
\fIin\fP The string data to decode\&. 
.br
\fIinLen\fP The length of the input data\&. 
.br
\fIout\fP A buffer large enought to hold the decoded data\&. 
.br
\fIoutLen\fP The length of the output buffer\&. 
.br
\fIcodec\fP The binary codec to use for decoding\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The number of bytes written into the output buffer\&. 
.RE
.PP

.SS "char* M_bincodec_convert_alloc (const char * in, size_t inLen, size_t wrap, \fBM_bincodec_codec_t\fP inCodec, \fBM_bincodec_codec_t\fP outCodec)"
Convert a string from one binary encoding to another\&.
.PP
A conversion will always be performed even when using the same input and output codecs\&.
.PP
\fBParameters:\fP
.RS 4
\fIin\fP The data to convert\&. 
.br
\fIinLen\fP The length of the input data\&. 
.br
\fIwrap\fP The maximum length of a given line\&. Longer lines will be split with a new line\&. Pass 0 if line splitting is not desired\&. 
.br
\fIinCodec\fP The format the input data is encoded using\&. 
.br
\fIoutCodec\fP The output format to convert into\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A new NULL terminated string with the converted data\&. Otherwise NULL on error\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_free\fP 
.RE
.PP

.SS "size_t M_bincodec_convert (char * out, size_t outLen, size_t wrap, \fBM_bincodec_codec_t\fP outCodec, const char * in, size_t inLen, \fBM_bincodec_codec_t\fP inCodec)"
Convert a string from one binary encoding to another\&.
.PP
A conversion will always be performed even when using the same input and output codecs\&.
.PP
\fBParameters:\fP
.RS 4
\fIout\fP A buffer large enought to hold the converted data\&. 
.br
\fIoutLen\fP The length of the output buffer\&. 
.br
\fIwrap\fP The maximum length of a given line\&. Longer lines will be split with a new line\&. Pass 0 if line splitting is not desired\&. 
.br
\fIin\fP The data to convert\&. 
.br
\fIinLen\fP The length of the input data\&. 
.br
\fIinCodec\fP The format the input data is encoded using\&. 
.br
\fIoutCodec\fP The output format to convert into\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The number of bytes written into the output buffer\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
