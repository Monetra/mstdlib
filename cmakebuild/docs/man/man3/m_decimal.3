.TH "m_decimal" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_decimal
.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBM_decimal_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_DECIMAL_RETVAL\fP { \fBM_DECIMAL_SUCCESS\fP = 0, \fBM_DECIMAL_OVERFLOW\fP = 1, \fBM_DECIMAL_TRUNCATION\fP = 2, \fBM_DECIMAL_INVALID\fP = 3 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBM_decimal_create\fP (\fBM_decimal_t\fP *dec)"
.br
.ti -1c
.RI "void \fBM_decimal_from_int\fP (\fBM_decimal_t\fP *dec, M_int64 integer, M_uint8 implied_dec)"
.br
.ti -1c
.RI "M_int64 \fBM_decimal_to_int\fP (const \fBM_decimal_t\fP *dec, M_uint8 implied_dec)"
.br
.ti -1c
.RI "enum \fBM_DECIMAL_RETVAL\fP \fBM_decimal_from_str\fP (const char *string, size_t len, \fBM_decimal_t\fP *val, const char **endptr)"
.br
.ti -1c
.RI "enum \fBM_DECIMAL_RETVAL\fP \fBM_decimal_to_str\fP (const \fBM_decimal_t\fP *dec, char *buf, size_t buf_len)"
.br
.ti -1c
.RI "M_int8 \fBM_decimal_cmp\fP (const \fBM_decimal_t\fP *dec1, const \fBM_decimal_t\fP *dec2)"
.br
.ti -1c
.RI "enum \fBM_DECIMAL_RETVAL\fP \fBM_decimal_transform\fP (\fBM_decimal_t\fP *dec, M_uint8 num_dec)"
.br
.ti -1c
.RI "void \fBM_decimal_reduce\fP (\fBM_decimal_t\fP *dec)"
.br
.ti -1c
.RI "M_uint8 \fBM_decimal_num_decimals\fP (const \fBM_decimal_t\fP *dec)"
.br
.ti -1c
.RI "void \fBM_decimal_duplicate\fP (\fBM_decimal_t\fP *dest, const \fBM_decimal_t\fP *src)"
.br
.ti -1c
.RI "enum \fBM_DECIMAL_RETVAL\fP \fBM_decimal_multiply\fP (\fBM_decimal_t\fP *dest, const \fBM_decimal_t\fP *dec1, const \fBM_decimal_t\fP *dec2)"
.br
.ti -1c
.RI "enum \fBM_DECIMAL_RETVAL\fP \fBM_decimal_divide\fP (\fBM_decimal_t\fP *dest, const \fBM_decimal_t\fP *dec1, const \fBM_decimal_t\fP *dec2)"
.br
.ti -1c
.RI "enum \fBM_DECIMAL_RETVAL\fP \fBM_decimal_subtract\fP (\fBM_decimal_t\fP *dest, const \fBM_decimal_t\fP *dec1, const \fBM_decimal_t\fP *dec2)"
.br
.ti -1c
.RI "enum \fBM_DECIMAL_RETVAL\fP \fBM_decimal_add\fP (\fBM_decimal_t\fP *dest, const \fBM_decimal_t\fP *dec1, const \fBM_decimal_t\fP *dec2)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Floating point number type\&. Used instead of double or float to elimiate rounding errors\&.
.PP
Example:
.PP
.PP
.nf
const char  *s1 = "1\&.01";
const char  *s2 = "0\&.001";
M_decimal_t  d1;
M_decimal_t  d2;
char         out[16];

M_mem_set(out, 0, sizeof(out));

M_decimal_from_str(s1, M_str_len(s1), &d1, NULL);
M_decimal_from_str(s2, M_str_len(s2), &d2, NULL);
M_decimal_add(&d1, &d1, &d2);
M_decimal_reduce(&d1);

if (M_decimal_to_str(&d1, out, sizeof(out)) != M_DECIMAL_SUCCESS) {
    M_printf("failure\n");
} else {
    M_printf("out='%s'\n", out);
}
.fi
.PP
.PP
Example output:
.PP
.PP
.nf
out='1\&.011'
.fi
.PP
 
.SH "Data Structure Documentation"
.PP 
.SH "struct M_decimal_t"
.PP 
Structure defining storage for decimal numbers\&.
.PP
This structure should never be touched directly\&. It is only made public to reduce the overhead of using this datatype (no malloc needed)\&. 
.PP
\fBData Fields:\fP
.RS 4
M_int64 \fInum\fP Number represented\&. 
.br
.PP
M_uint8 \fInum_dec\fP How many implied decimal places\&. 
.br
.PP
.RE
.PP
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_DECIMAL_RETVAL\fP"
Result/Error codes for M_decimal functions\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_DECIMAL_SUCCESS \fP\fP
Operation successful\&. 
.TP
\fB\fIM_DECIMAL_OVERFLOW \fP\fP
An overflow occurred in the operation\&. 
.TP
\fB\fIM_DECIMAL_TRUNCATION \fP\fP
The result was truncated/rounded in order to approximate the best result\&. This is true on most divide operations\&. 
.TP
\fB\fIM_DECIMAL_INVALID \fP\fP
Invalid data\&. 
.SH "Function Documentation"
.PP 
.SS "void M_decimal_create (\fBM_decimal_t\fP * dec)"
Create new zero'd out decimal number\&.
.PP
\fBParameters:\fP
.RS 4
\fIdec\fP New decimal output\&. 
.RE
.PP

.SS "void M_decimal_from_int (\fBM_decimal_t\fP * dec, M_int64 integer, M_uint8 implied_dec)"
Convert to a decimal representation from an integer
.PP
\fBParameters:\fP
.RS 4
\fIdec\fP New decimal output\&. 
.br
\fIinteger\fP Integer to convert to decimal\&. 
.br
\fIimplied_dec\fP Number of implied decimals in integer input\&. 
.RE
.PP

.SS "M_int64 M_decimal_to_int (const \fBM_decimal_t\fP * dec, M_uint8 implied_dec)"
Convert from a decimal representation to an integer with implied decimal places\&. If the conversion causes truncation, the number will be rounded\&. For example a decimal of 123\&.456, with implied decimals 2, will return 12346\&.
.PP
\fBParameters:\fP
.RS 4
\fIdec\fP Decimal type 
.br
\fIimplied_dec\fP Number of implied decimal positions\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Rounded integer representation of number\&. 
.RE
.PP

.SS "enum \fBM_DECIMAL_RETVAL\fP M_decimal_from_str (const char * string, size_t len, \fBM_decimal_t\fP * val, const char ** endptr)"
Convert to a decimal representation from a string\&.
.PP
\fBParameters:\fP
.RS 4
\fIstring\fP Buffer with decimal representation\&. 
.br
\fIlen\fP Length of bytes to evaluate from string\&. 
.br
\fIval\fP New decimal output\&. 
.br
\fIendptr\fP Pointer to end of evaluated decimal\&.
.RE
.PP
\fBReturns:\fP
.RS 4
One of the enum M_DECIMAL_RETVAL values\&. 
.RE
.PP

.SS "enum \fBM_DECIMAL_RETVAL\fP M_decimal_to_str (const \fBM_decimal_t\fP * dec, char * buf, size_t buf_len)"
Convert from a decimal representation to a string\&.
.PP
\fBParameters:\fP
.RS 4
\fIdec\fP Decimal type\&. 
.br
\fIbuf\fP Buffer to output string representation\&. 
.br
\fIbuf_len\fP Length of output buffer\&.
.RE
.PP
\fBReturns:\fP
.RS 4
One of the enum M_DECIMAL_RETVAL values\&. 
.RE
.PP

.SS "M_int8 M_decimal_cmp (const \fBM_decimal_t\fP * dec1, const \fBM_decimal_t\fP * dec2)"
Compare 2 decimals\&.
.PP
\fBParameters:\fP
.RS 4
\fIdec1\fP Decimal 1\&. 
.br
\fIdec2\fP Decimal 2\&.
.RE
.PP
\fBReturns:\fP
.RS 4
-1 if dec1 < dec2, 0 if dec1 == dec2, 1 if dec1 > dec2\&. 
.RE
.PP

.SS "enum \fBM_DECIMAL_RETVAL\fP M_decimal_transform (\fBM_decimal_t\fP * dec, M_uint8 num_dec)"
Transform decimal number representation to have the specified number of decimal places (rounding if needed)\&.
.PP
\fBParameters:\fP
.RS 4
\fIdec\fP Decimal type\&. 
.br
\fInum_dec\fP Number of decimal places number should be transformed to\&.
.RE
.PP
\fBReturns:\fP
.RS 4
One of the enum M_DECIMAL_RETVAL values\&. 
.RE
.PP

.SS "void M_decimal_reduce (\fBM_decimal_t\fP * dec)"
Reduce the decimal representation to the smallest number of decimal places possible without reducing precision (remove trailing zeros)\&.
.PP
\fBParameters:\fP
.RS 4
\fIdec\fP Decimal type\&. 
.RE
.PP

.SS "M_uint8 M_decimal_num_decimals (const \fBM_decimal_t\fP * dec)"
Number of decimal places present in the \fBM_decimal_t\fP representation\&.
.PP
\fBParameters:\fP
.RS 4
\fIdec\fP Decimal type\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Number of decimals currently represented by type\&. 
.RE
.PP

.SS "void M_decimal_duplicate (\fBM_decimal_t\fP * dest, const \fBM_decimal_t\fP * src)"
Copy the decimal object from the source into the destination
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP New decimal duplicated from src\&. 
.br
\fIsrc\fP Decimal type to copy\&. 
.RE
.PP

.SS "enum \fBM_DECIMAL_RETVAL\fP M_decimal_multiply (\fBM_decimal_t\fP * dest, const \fBM_decimal_t\fP * dec1, const \fBM_decimal_t\fP * dec2)"
Multiply the two decimals together putting the result in dest\&.
.PP
The destination and one of the sources may be the same\&. The number of resulting decimal places will be the same as the largest input\&.
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP New decimal with result\&. 
.br
\fIdec1\fP First decimal to multiply\&. 
.br
\fIdec2\fP Second decimal to multiply\&.
.RE
.PP
\fBReturns:\fP
.RS 4
One of the enum M_DECIMAL_RETVAL values\&. 
.RE
.PP

.SS "enum \fBM_DECIMAL_RETVAL\fP M_decimal_divide (\fBM_decimal_t\fP * dest, const \fBM_decimal_t\fP * dec1, const \fBM_decimal_t\fP * dec2)"
Divide the two decimals, putting the result in dest\&.
.PP
The destination and one of the sources may be the same\&. The number of resulting decimal places will be the same as the largest input\&.
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP New decimal with result\&. 
.br
\fIdec1\fP First decimal (numerator)\&. 
.br
\fIdec2\fP Second decimal (denominator)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
One of the enum M_DECIMAL_RETVAL values\&. 
.RE
.PP

.SS "enum \fBM_DECIMAL_RETVAL\fP M_decimal_subtract (\fBM_decimal_t\fP * dest, const \fBM_decimal_t\fP * dec1, const \fBM_decimal_t\fP * dec2)"
Subtract two decimals, putting the result in dest\&.
.PP
The destination and one of the sources may be the same\&. The number of resulting decimal places will be the same as the largest input\&.
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP New decimal with result\&. 
.br
\fIdec1\fP First decimal\&. 
.br
\fIdec2\fP Second decimal\&.
.RE
.PP
\fBReturns:\fP
.RS 4
One of the enum M_DECIMAL_RETVAL values\&. 
.RE
.PP

.SS "enum \fBM_DECIMAL_RETVAL\fP M_decimal_add (\fBM_decimal_t\fP * dest, const \fBM_decimal_t\fP * dec1, const \fBM_decimal_t\fP * dec2)"
Add two decimals, putting the result in dest\&.
.PP
The destination and one of the sources may be the same\&. The number of resulting decimal places will be the same as the largest input\&.
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP New decimal with result\&. 
.br
\fIdec1\fP First decimal\&. 
.br
\fIdec2\fP Second decimal\&.
.RE
.PP
\fBReturns:\fP
.RS 4
One of the enum M_DECIMAL_RETVAL values 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
