.TH "m_sql_query" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_sql_query
.SH SYNOPSIS
.br
.PP
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_sql_query_updlock_type_t\fP { \fBM_SQL_QUERY_UPDLOCK_TABLE\fP = 1, \fBM_SQL_QUERY_UPDLOCK_QUERYEND\fP = 2 }"
.br
.ti -1c
.RI "enum \fBM_sql_query_bitop_t\fP { \fBM_SQL_BITOP_AND\fP = 1, \fBM_SQL_BITOP_OR\fP = 2 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBM_sql_query_append_updlock\fP (\fBM_sql_connpool_t\fP *pool, \fBM_buf_t\fP *query, \fBM_sql_query_updlock_type_t\fP type)"
.br
.ti -1c
.RI "M_bool \fBM_sql_query_append_bitop\fP (\fBM_sql_connpool_t\fP *pool, \fBM_buf_t\fP *query, \fBM_sql_query_bitop_t\fP op, const char *exp1, const char *exp2)"
.br
.in -1c
.SH "Detailed Description"
.PP 
SQL Query Extension/Portability Helpers are used to assist in ensuring queries are portable across various database servers utilizing extensions they offer\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_sql_query_updlock_type_t\fP"
Row lock type to append to query to lock rows returned from a select statement for a future update with in a transaction\&. All values must be used within a single query 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_SQL_QUERY_UPDLOCK_TABLE \fP\fP
Apply SQL-specific lock to rows in the table being updated\&. This must be appended immediately after every referenced table name when row locking is desired\&. Must be used in conjunction with a later call for \fBM_SQL_QUERY_UPDLOCK_QUERYEND\fP 
.TP
\fB\fIM_SQL_QUERY_UPDLOCK_QUERYEND \fP\fP
Apply the SQL-specific lock to the rows referenced by query, this must always be applied at the END of a query string\&. Must be used in conjunction with an earlier call for \fBM_SQL_QUERY_UPDLOCK_TABLE\fP 
.SS "enum \fBM_sql_query_bitop_t\fP"
Type of bitwise operation to perform\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_SQL_BITOP_AND \fP\fP
Perform a bitwise AND (&) operation 
.TP
\fB\fIM_SQL_BITOP_OR \fP\fP
Perform a bitwise OR (|) operation 
.SH "Function Documentation"
.PP 
.SS "void M_sql_query_append_updlock (\fBM_sql_connpool_t\fP * pool, \fBM_buf_t\fP * query, \fBM_sql_query_updlock_type_t\fP type)"
Append the SQL-server-specific row lock method to the proper point in the query to be updated by a later call within the same transaction\&.
.PP
Row locks are intended to block conflicting select statements until the current transaction has completed\&. It is an optimization to assist in reducing deadlocks which force rollback and retry cycles\&. For some database clustering solutions, like MySQL/MariaDB with Galera, it is necessary to use to prevent lost updates since updates cross-node lack the serializable isolation level guarantees\&.
.PP
Different databases utilize different row locking methods and the methods appear at different points in the query\&. Due to the complexity of SQL queries, it is not viable to offer automatic rewrite ability for such queries, and instead we provide methods for simply inserting the locking statements in a DB-specific way into your query\&.
.PP
Locking is for the duration of an SQL transaction, so row locking can only occur within a transaction, please see \fBM_sql_trans_begin()\fP\&.
.PP
An example query that you want to lock the rows might look like: 
.PP
.nf
SELECT * FROM "foo" WHERE "bar" = ? 

.fi
.PP
 For a row lock for Microsoft SQL Server, the desired query with locks would look like: 
.PP
.nf
SELECT * FROM "foo" WITH (ROWLOCK, XLOCK, HOLDLOCK) WHERE "bar" = ? 

.fi
.PP
 For the equivalent on MySQL, it would look like this: 
.PP
.nf
SELECT * FROM "foo" WHERE "bar" = ? FOR UPDATE 

.fi
.PP
.PP
Clearly as the above example indicates, it would be undesirable to need to rewrite the query manually by detecting the database in use, using helpers makes this easier so you do not need to have SQL-server-specific logic in your own code\&. Converting that query above using the helpers could be done as the below: 
.PP
.nf
M_sql_stmt_t *stmt  = M_sql_stmt_create();
M_buf_t      *query = M_buf_create();
M_sql_error_t err;

M_buf_add_str(query, "SELECT * FROM \"foo\"");
M_sql_query_append_updlock(pool, query, M_SQL_QUERY_UPDLOCK_TABLE);
M_buf_add_str(query, " WHERE \"bar\" = ?");
M_sql_stmt_bind_int32(stmt, 1);
M_sql_query_append_updlock(pool, query, M_SQL_QUERY_UPDLOCK_QUERYEND);
M_sql_stmt_prepare_buf(stmt, query);
err = M_sql_stmt_execute(pool, stmt);
//\&.\&.\&.
M_sql_stmt_destroy(stmt);

.fi
.PP
.PP
\fBNote:\fP
.RS 4
At least one \fBM_SQL_QUERY_UPDLOCK_TABLE\fP must be appended per query\&. They will be appended immediately after each table reference (SELECT FROM \&.\&.\&. table, or JOIN table)\&. For the same query, at the end of the query, \fBM_SQL_QUERY_UPDLOCK_QUERYEND\fP must be appended\&.
.RE
.PP
\fBWarning:\fP
.RS 4
Not all databases support row-lock hints and instead rely on consistency guarantees by the underlying database for the isolation method in use\&. If you need these guarantees, please ensure you are using the \fBM_SQL_ISOLATION_SERIALIZABLE\fP isolation method as well\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIpool\fP Initialized \fBM_sql_connpool_t\fP object 
.br
\fIquery\fP A pointer to an already populated M_buf_t with a partial (or complete for \fBM_SQL_QUERY_UPDLOCK_QUERYEND\fP) request\&. 
.br
\fItype\fP Type of sql-specific lock to append to the query\&. 
.RE
.PP

.SS "M_bool M_sql_query_append_bitop (\fBM_sql_connpool_t\fP * pool, \fBM_buf_t\fP * query, \fBM_sql_query_bitop_t\fP op, const char * exp1, const char * exp2)"
Perform a bitwise operation on the database using an SQL-server-specific format\&.
.PP
A classic bitwise operation checking to see if a bit is set may look like the below: 
.PP
.nf
(exp1 & exp2) != 0 

.fi
.PP
.PP
Or a bitwise operation, setting a bit or set of bits may look like: 
.PP
.nf
exp1 = exp1 | exp2 

.fi
.PP
.PP
Some database servers take the expressions listed above exactly, however, others may require functions like BITAND() and BITOR() to accomplish the same thing\&.
.PP
Taking an example of selecting all rows where 'bar' has bit 4 (0x8) set: 
.PP
.nf
SELECT * FROM "foo" WHERE ("bar" & 8) <> 0 

.fi
.PP
 Might look like this: 
.PP
.nf
M_buf_t      *buf  = M_buf_create();
M_sql_stmt_t *stmt = M_sql_stmt_create();
M_sql_error_t err;

M_buf_add_str(buf, "SELECT * FROM \"foo\" WHERE (");
M_sql_query_append_bitop(pool, buf, M_SQL_BITOP_AND, "\"bar\"", "?");
M_sql_stmt_bind_int32(stmt, 8);
M_buf_add_str(buf, ") <> 0");
M_sql_stmt_prepare_buf(stmt, buf);
err = M_sql_stmt_execute(pool, stmt);
//\&.\&.\&.
M_sql_stmt_destroy(stmt);

.fi
.PP
.PP
Of course, more complex things are possible as well, such as unsetting bits and setting others in a single request by embedding operations within eachother\&. Take the below example that keeps bits 2 (0x2) and 3 (0x4) while clearing the rest and also sets bit 4 (0x8): 
.PP
.nf
UPDATE "foo" SET "bar" = ( "bar" & 6 ) | 8; 

.fi
.PP
 Might look like this: 
.PP
.nf
M_buf_t      *buf  = M_buf_create();
M_sql_stmt_t *stmt = M_sql_stmt_create();
M_sql_error_t err;

M_buf_add_str(buf, "UPDATE \"foo\" SET \"bar\" = ");

  // Do inner-first ( "bar" & 6 )
  M_buf_t *inner = M_buf_create();
  M_buf_add_str(inner, "( ");
  M_sql_query_append_bitop(pool, inner, M_SQL_BITOP_AND, "\"bar\"", "?");
  M_sql_stmt_bind_int32(stmt, 6);
  M_buf_add_str(inner, " )");

// Do outer, embedding inner
M_sql_query_append_bitop(pool, buf, M_SQL_BITOP_OR, M_buf_peek(inner), "?");
M_sql_stmt_bind_int32(stmt, 8);
M_buf_cancel(inner);  // We peeked, throw it away

M_sql_stmt_prepare_buf(stmt, buf);
err = M_sql_stmt_execute(pool, stmt);
//\&.\&.\&.
M_sql_stmt_destroy(stmt);

.fi
.PP
.PP
\fBWarning:\fP
.RS 4
Most databases do not allow bitwise operations to be used for 'truth' values (e\&.g as a boolean)\&. Instead, an integrator should compare the result to 0 to turn it into a boolean operation if needed\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIpool\fP Initialized \fBM_sql_connpool_t\fP object 
.br
\fIquery\fP A pointer to an already populated M_buf_t with a partial request\&. 
.br
\fIop\fP Bitwise operation to perform\&. 
.br
\fIexp1\fP Left-hand side of SQL expression\&. 
.br
\fIexp2\fP Right-hande size of SQL expression\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, M_FALSE on misuse 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
