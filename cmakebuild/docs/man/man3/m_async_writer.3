.TH "m_async_writer" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_async_writer
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef M_bool(* \fBM_async_write_cb_t\fP) (char *msg, M_uint64 cmd, void *thunk)"
.br
.ti -1c
.RI "typedef void(* \fBM_async_thunk_stop_cb_t\fP) (void *thunk)"
.br
.ti -1c
.RI "typedef void(* \fBM_async_thunk_destroy_cb_t\fP) (void *thunk)"
.br
.ti -1c
.RI "typedef struct M_async_writer \fBM_async_writer_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_async_writer_line_end_mode_t\fP { \fBM_ASYNC_WRITER_LINE_END_NATIVE\fP, \fBM_ASYNC_WRITER_LINE_END_UNIX\fP, \fBM_ASYNC_WRITER_LINE_END_WINDOWS\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_async_writer_t\fP * \fBM_async_writer_create\fP (size_t max_bytes, \fBM_async_write_cb_t\fP write_cb, void *write_thunk, \fBM_async_thunk_stop_cb_t\fP stop_cb, \fBM_async_thunk_destroy_cb_t\fP destroy_cb, \fBM_async_writer_line_end_mode_t\fP mode)"
.br
.ti -1c
.RI "void \fBM_async_writer_destroy\fP (\fBM_async_writer_t\fP *writer, M_bool flush)"
.br
.ti -1c
.RI "M_bool \fBM_async_writer_destroy_blocking\fP (\fBM_async_writer_t\fP *writer, M_bool flush, M_uint64 timeout_ms)"
.br
.ti -1c
.RI "M_bool \fBM_async_writer_start\fP (\fBM_async_writer_t\fP *writer)"
.br
.ti -1c
.RI "M_bool \fBM_async_writer_is_running\fP (\fBM_async_writer_t\fP *writer)"
.br
.ti -1c
.RI "M_bool \fBM_async_writer_is_alive\fP (\fBM_async_writer_t\fP *writer, M_uint64 timeout_ms)"
.br
.ti -1c
.RI "void \fBM_async_writer_stop\fP (\fBM_async_writer_t\fP *writer)"
.br
.ti -1c
.RI "M_bool \fBM_async_writer_set_command\fP (\fBM_async_writer_t\fP *writer, M_uint64 write_command, M_bool force)"
.br
.ti -1c
.RI "M_bool \fBM_async_writer_set_command_block\fP (\fBM_async_writer_t\fP *writer, M_uint64 write_command)"
.br
.ti -1c
.RI "void \fBM_async_writer_set_max_bytes\fP (\fBM_async_writer_t\fP *writer, size_t max_bytes)"
.br
.ti -1c
.RI "M_bool \fBM_async_writer_write\fP (\fBM_async_writer_t\fP *writer, const char *msg)"
.br
.ti -1c
.RI "void * \fBM_async_writer_get_thunk\fP (\fBM_async_writer_t\fP *writer)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Helper class that manages an internal worker thread and message queue for asynchrnous writes\&.
.PP
Used internally in various logging modules\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef M_bool(* M_async_write_cb_t) (char *msg, M_uint64 cmd, void *thunk)"
Callback that will be called to write messages\&.
.PP
If your program modifies the 'thunk' object outside the callback while the writer is running, you'll need to add your own locks inside the callback to make this reentrant\&.
.PP
The command flag allows you to pass one-off notifications to the callback\&. These notifications will be processed lazily (i\&.e\&., the next time the internal thread tries to write something)\&. Only the next write is affected; after the command flag is used once, it's reset to zero\&.
.PP
It is possible for the write callback to be called with a NULL msg and a non-zero command\&. This happens when the user sets a command with the force flag set to M_TRUE, but the message queue is empty\&. In this case, the callback should process the command, but it shouldn't write the empty message\&.
.PP
\fBParameters:\fP
.RS 4
\fImsg\fP message that needs to be written\&. Can be modified in-place\&. May be NULL, for command-only calls\&. 
.br
\fIthunk\fP object passed into \fIwrite_thunk\fP parameter of \fBM_async_writer_create()\fP\&. 
.br
\fIcmd\fP command flag passed into \fBM_async_writer_set_command()\fP\&. May be 0, if no command sent\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if message was consumed, M_FALSE if message should be returned to queue (if possible)\&. 
.RE
.PP

.SS "typedef void(* M_async_thunk_stop_cb_t) (void *thunk)"

.SS "typedef void(* M_async_thunk_destroy_cb_t) (void *thunk)"

.SS "typedef struct M_async_writer \fBM_async_writer_t\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_async_writer_line_end_mode_t\fP"
Control what type of line endings get automatically appended to error messages\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_ASYNC_WRITER_LINE_END_NATIVE \fP\fP
\fC'\\n'\fP if running on Unix, \fC'\\r\\n'\fP if running on Windows 
.TP
\fB\fIM_ASYNC_WRITER_LINE_END_UNIX \fP\fP
always use \fC'\\n'\fP 
.TP
\fB\fIM_ASYNC_WRITER_LINE_END_WINDOWS \fP\fP
always use \fC'\\r\\n'\fP 
.SH "Function Documentation"
.PP 
.SS "\fBM_async_writer_t\fP* M_async_writer_create (size_t max_bytes, \fBM_async_write_cb_t\fP write_cb, void * write_thunk, \fBM_async_thunk_stop_cb_t\fP stop_cb, \fBM_async_thunk_destroy_cb_t\fP destroy_cb, \fBM_async_writer_line_end_mode_t\fP mode)"
Create a writer object\&.
.PP
The writer does not automatically start running, you must call \fBM_async_writer_start()\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fImax_bytes\fP maximum bytes that can be queued before messages start getting dropped 
.br
\fIwrite_cb\fP callback that will be called by an internal thread to write messages 
.br
\fIwrite_thunk\fP object that can be used to preserve callback state between writes 
.br
\fIstop_cb\fP optional callback that will be called during a stop request 
.br
\fIdestroy_cb\fP callback that will be used to destroy the thunk when writer is destroyed 
.br
\fImode\fP line-end mode for internally generated error messages 
.RE
.PP

.SS "void M_async_writer_destroy (\fBM_async_writer_t\fP * writer, M_bool flush)"
Destroy the writer (non-blocking)\&.
.PP
This is a non-blocking operation - the worker thread is commanded to destroy itself, then immediately orphaned\&. The orphaned thread will still try to delete itself, if it has enough time to do so before the process ends\&. If the program exits before it has time to do this, it will show up as a memory leak (even though it's not)\&.
.PP
This call asks the internal thread to stop running at the next opportunity and then destroy the writer object once stopped\&. If the internal thread has already been stopped, the object is destroyed by the calling thread\&.
.PP
If you set \fIflush\fP to M_TRUE, the internal thread will output all messages in the queue before it destroys itself\&. Otherwise, the thread will stop itself right after it finishes the current message it's working on, and will output a message describing the number of dropped messages left in the queue before destroying itself\&.
.PP
If the internal thead is frozen, this is effectively a memory leak - the writer object won't be destroyed until the process exits\&. But the calling thread won't freeze, so this is probably preferable\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_async_writer_destroy_blocking\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIwriter\fP object we're operating on 
.br
\fIflush\fP if M_TRUE, output all messages in queue before destroying 
.RE
.PP

.SS "M_bool M_async_writer_destroy_blocking (\fBM_async_writer_t\fP * writer, M_bool flush, M_uint64 timeout_ms)"
Destroy the writer (blocking, with timeout)\&.
.PP
\fBWarning:\fP
.RS 4
This is a BLOCKING operation, it will wait for the worker thread to finish before returning, or for the given timeout to expire (whichever comes first)\&.
.RE
.PP
This call asks the internal thread to stop running at the next opportunity and then destroy the writer object once stopped\&. If the internal thread has already been stopped, the object is destroyed by the calling thread\&.
.PP
If you set \fIflush\fP to M_TRUE, the internal thread will output all messages in the queue before it destroys itself\&. Otherwise, the thread will stop itself right after it finishes the current message it's working on, and will output a message describing the number of dropped messages left in the queue before destroying itself\&.
.PP
If the timeout expires before the worker thread is done, the worker thread will be orphaned and control will return to the caller (just like in \fBM_async_writer_destroy()\fP)\&. The orphaned thread will still try to delete itself, if it has enough time to do so before the process ends\&. If the program exits before it has time to do this, it will show up as a memory leak (even though it's not)\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_async_writer_destroy\fP 
.PP
\fBM_async_writer_stop\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIwriter\fP object we're operating on 
.br
\fIflush\fP if M_TRUE, output all messages in queue before destroying 
.br
\fItimeout_ms\fP length of time (in milliseconds) to wait until orphaning the worker thread, or 0 for no timeout 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if worker thread finished within timeout, false if it did not and was orphaned 
.RE
.PP

.SS "M_bool M_async_writer_start (\fBM_async_writer_t\fP * writer)"
Start writing messages from the queue\&.
.PP
This starts an internal worker thread that pulls messages off of the message queue and writes them\&.
.PP
You can stop the worker thread with \fBM_async_writer_stop()\fP and then restart it with this function, and messages will still be accepted into the message queue the entire time\&. Start and stop only affect whether messages are being pulled off of the queue and written\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_async_writer_stop\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIwriter\fP object we're operating on 
.RE
.PP

.SS "M_bool M_async_writer_is_running (\fBM_async_writer_t\fP * writer)"
Check to see if writer has been started and is accepting messages\&.
.PP
This is non-blocking, we're just checking whether the writer has been started and not stopped\&. If you need to check if a running writer is frozen or not, use \fBM_async_writer_is_alive()\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIwriter\fP object we're checking 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if writer has been started, M_FALSE if writer is stopped 
.RE
.PP

.SS "M_bool M_async_writer_is_alive (\fBM_async_writer_t\fP * writer, M_uint64 timeout_ms)"
Check to see if writer is frozen or not (blocking)\&.
.PP
Blocks until either the internal worker thread responds, or the timeout is reached\&.
.PP
If you just want to check if the writer has been started or not, use \fBM_async_writer_is_running()\fP instead, it's non-blocking\&.
.PP
Thread should respond after it finishes with the message that it's currently working on\&. So, the timeout should be chosen based on the time it takes for the write_cb to execute once (worst case)\&.
.PP
\fBParameters:\fP
.RS 4
\fIwriter\fP object we're checking 
.br
\fItimeout_ms\fP amount of time to wait for thread to respond (in milliseconds) 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if thread responded to liveness check, M_FALSE if thread didn't respond within timeout 
.RE
.PP

.SS "void M_async_writer_stop (\fBM_async_writer_t\fP * writer)"
Stop internal worker thread\&.
.PP
\fBWarning:\fP
.RS 4
This is a BLOCKING operation, it will wait for the worker thread to finish before returning\&. The worker thread will stop immediately after it finishes the current message it's working on (if any), so it shouldn't block for long\&.
.RE
.PP
This is used when you need to stop the internal worker thread temporarily, and then restart it with a new thread later\&. Messages are still accepted into the message queue while the writer is stopped, it just doesn't write anything until \fBM_async_writer_start()\fP is called again\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_async_writer_start\fP 
.PP
\fBM_async_writer_destroy_blocking\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIwriter\fP object we're operating on 
.RE
.PP

.SS "M_bool M_async_writer_set_command (\fBM_async_writer_t\fP * writer, M_uint64 write_command, M_bool force)"
Set a command flag that will be passed to the write callback the next time it's called\&.
.PP
This can be used to notify the write callback of a condition change (like a request to rotate logs, etc\&.)\&.
.PP
The command will be passed on the next call to the write callback, then reset immediately afterwards\&.
.PP
If multiple calls to this command occur before the next write, the commands will be OR'd together into one value\&.
.PP
You can force the write callback to always be called after the command is set by setting the \fIforce\fP flag to M_TRUE\&. If not set, the command will be processed the next time the internal worker thread pulls a message off the queue (which might not be until the next call to \fBM_async_writer_write()\fP, if the queue is currently empty)\&.
.PP
\fBParameters:\fP
.RS 4
\fIwriter\fP object we're operating on 
.br
\fIwrite_command\fP flag to pass to write_callback on next write (must be a power of two, or several flags OR'd together) 
.br
\fIforce\fP if M_TRUE, wakes up writer thread even if message queue is empty\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
M_FALSE if command rejected due to writer being in the middle of a flush-stop\&. 
.RE
.PP

.SS "M_bool M_async_writer_set_command_block (\fBM_async_writer_t\fP * writer, M_uint64 write_command)"
Set a command flag, and block until that command is processed\&.
.PP
Same as \fBM_async_writer_set_command()\fP, except that it blocks until the internal worker thread is done processing the command\&.
.PP
Note that this function always sets the force flag for the command - even if the message queue is empty, the internal worker thread will be awakened and the command will be processed\&. If the message queue is not empty, the command will be processed when the next message is pulled off of the queue\&.
.PP
\fBWarning:\fP
.RS 4
If this function is called from multiple threads on the same async_writer object, execution of the requested commands will be serialized - the command from the second thread won't even start until after the command from the first thread has finished\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIwriter\fP object we're operating on 
.br
\fIwrite_command\fP flag to pass to write_callback on next write (must be a power of two, or several flags OR'd together) 
.RE
.PP
\fBReturns:\fP
.RS 4
M_FALSE if command rejected due to writer being in the middle of a flush-stop\&. 
.RE
.PP

.SS "void M_async_writer_set_max_bytes (\fBM_async_writer_t\fP * writer, size_t max_bytes)"
Change the maximum buffer size\&.
.PP
If the writer is running, the new maximum buffer size will not actually be enforced until the next time a message is written to the writer\&.
.PP
\fBParameters:\fP
.RS 4
\fIwriter\fP object we're operating on 
.br
\fImax_bytes\fP new maximum number of bytes that can be queued before messages start getting dropped 
.RE
.PP

.SS "M_bool M_async_writer_write (\fBM_async_writer_t\fP * writer, const char * msg)"
Write a message to the writer (non-blocking)\&.
.PP
The message will be added to a work queue, to be passed later to write_callback by an internal worker thread\&.
.PP
If the message can't be added (empty message, message itself is larger than queue, alloc error, or writer is in the middle of a flush-stop) the message is dropped without modifying the internal queue\&.
.PP
If the queue doesn't have enough empty space to fit the message, messages in the queue are dropped until there is enough room\&. The oldest message is dropped first, then the next oldest, and so on, until there's enough room in the queue to add the new message\&.
.PP
Note that an async writer will still accept messages passed with this function when stopped - it will just add them to the message queue, and wait until the writer is started again to write them\&.
.PP
\fBParameters:\fP
.RS 4
\fIwriter\fP object we're operating on 
.br
\fImsg\fP message to add to write queue 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if message was added to queue, M_FALSE if it couldn't be added 
.RE
.PP

.SS "void* M_async_writer_get_thunk (\fBM_async_writer_t\fP * writer)"
Return the internal writer callback thunk\&.
.PP
\fBWarning:\fP
.RS 4
If the writer is running, don't modify the thunk from external code unless you've implemented your own locking scheme between the writer callback and the external code, using locks stored in the thunk\&.
.PP
Ownership of the returned thunk remains with the M_async_writer_t object, so this pointer is only valid until \fBM_async_writer_destroy()\fP is called\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIwriter\fP object we're operating on 
.RE
.PP
\fBReturns:\fP
.RS 4
pointer to internal 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
