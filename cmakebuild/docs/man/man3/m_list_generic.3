.TH "m_list_generic" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_list_generic
.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBM_list_callbacks\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct M_list \fBM_list_t\fP"
.br
.ti -1c
.RI "typedef void *(* \fBM_list_duplicate_func\fP) (const void *)"
.br
.ti -1c
.RI "typedef void(* \fBM_list_free_func\fP) (void *)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_list_flags_t\fP { \fBM_LIST_NONE\fP = 0, \fBM_LIST_SORTED\fP = 1 << 0, \fBM_LIST_STABLE\fP = 1 << 1, \fBM_LIST_STACK\fP = 1 << 2, \fBM_LIST_SET_VAL\fP = 1 << 3, \fBM_LIST_SET_PTR\fP = 1 << 4, \fBM_LIST_NEVERSHRINK\fP = 1 << 5 }"
.br
.ti -1c
.RI "enum \fBM_list_match_type_t\fP { \fBM_LIST_MATCH_VAL\fP = 0, \fBM_LIST_MATCH_PTR\fP = 1 << 0, \fBM_LIST_MATCH_ALL\fP = 1 << 1 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_list_t\fP * \fBM_list_create\fP (const struct \fBM_list_callbacks\fP *callbacks, M_uint32 flags) M_MALLOC"
.br
.ti -1c
.RI "void \fBM_list_destroy\fP (\fBM_list_t\fP *d, M_bool destroy_vals) M_FREE(1)"
.br
.ti -1c
.RI "void \fBM_list_change_sorting\fP (\fBM_list_t\fP *d, \fBM_sort_compar_t\fP equality, M_uint32 sorted_flags, void *thunk)"
.br
.ti -1c
.RI "M_bool \fBM_list_insert\fP (\fBM_list_t\fP *d, const void *val)"
.br
.ti -1c
.RI "size_t \fBM_list_insert_idx\fP (const \fBM_list_t\fP *d, const void *val)"
.br
.ti -1c
.RI "M_bool \fBM_list_insert_at\fP (\fBM_list_t\fP *d, const void *val, size_t idx)"
.br
.ti -1c
.RI "void \fBM_list_insert_begin\fP (\fBM_list_t\fP *d)"
.br
.ti -1c
.RI "void \fBM_list_insert_end\fP (\fBM_list_t\fP *d)"
.br
.ti -1c
.RI "size_t \fBM_list_len\fP (const \fBM_list_t\fP *d)"
.br
.ti -1c
.RI "size_t \fBM_list_count\fP (const \fBM_list_t\fP *d, const void *val, M_uint32 type)"
.br
.ti -1c
.RI "M_bool \fBM_list_index_of\fP (const \fBM_list_t\fP *d, const void *val, M_uint32 type, size_t *idx)"
.br
.ti -1c
.RI "const void * \fBM_list_first\fP (const \fBM_list_t\fP *d)"
.br
.ti -1c
.RI "const void * \fBM_list_last\fP (const \fBM_list_t\fP *d)"
.br
.ti -1c
.RI "const void * \fBM_list_at\fP (const \fBM_list_t\fP *d, size_t idx)"
.br
.ti -1c
.RI "void * \fBM_list_take_first\fP (\fBM_list_t\fP *d)"
.br
.ti -1c
.RI "void * \fBM_list_take_last\fP (\fBM_list_t\fP *d)"
.br
.ti -1c
.RI "void * \fBM_list_take_at\fP (\fBM_list_t\fP *d, size_t idx)"
.br
.ti -1c
.RI "M_bool \fBM_list_remove_first\fP (\fBM_list_t\fP *d)"
.br
.ti -1c
.RI "M_bool \fBM_list_remove_last\fP (\fBM_list_t\fP *d)"
.br
.ti -1c
.RI "M_bool \fBM_list_remove_at\fP (\fBM_list_t\fP *d, size_t idx)"
.br
.ti -1c
.RI "size_t \fBM_list_remove_val\fP (\fBM_list_t\fP *d, const void *val, M_uint32 type)"
.br
.ti -1c
.RI "M_bool \fBM_list_remove_range\fP (\fBM_list_t\fP *d, size_t start, size_t end)"
.br
.ti -1c
.RI "void \fBM_list_remove_duplicates\fP (\fBM_list_t\fP *d, M_uint32 type)"
.br
.ti -1c
.RI "size_t \fBM_list_replace_val\fP (\fBM_list_t\fP *d, const void *val, const void *new_val, M_uint32 type)"
.br
.ti -1c
.RI "M_bool \fBM_list_replace_at\fP (\fBM_list_t\fP *d, const void *val, size_t idx)"
.br
.ti -1c
.RI "M_bool \fBM_list_swap\fP (\fBM_list_t\fP *d, size_t idx1, size_t idx2)"
.br
.ti -1c
.RI "\fBM_list_t\fP * \fBM_list_duplicate\fP (const \fBM_list_t\fP *d) M_MALLOC"
.br
.ti -1c
.RI "void \fBM_list_merge\fP (\fBM_list_t\fP **dest, \fBM_list_t\fP *src, M_bool include_duplicates, M_uint32 type) M_FREE(2)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Dynamic list (array) for storing values\&.
.PP
This should not be used directly\&. It is a base implementation that should be used by a type safe wrapper\&. For example: M_list_str\&.
.PP
The list can uses a set of callback functions to determine behavior\&. Such as if it should duplicate or free values\&.
.PP
The list can be used in multiple ways:
.IP "\(bu" 2
Unsorted\&.
.IP "\(bu" 2
Sorted\&.
.IP "\(bu" 2
Queue (FIFO) (really just unsorted)\&.
.IP "\(bu" 2
Priority Queue (really just sorted)\&.
.IP "\(bu" 2
Stack (LIFO) (which cannot be sorted)\&.
.IP "\(bu" 2
Set\&.
.PP
.PP
A list is indexable\&. Find is also supported\&.
.PP
Indexes in the list are 0 at head to len-1 at end (head \&.\&.\&. end)\&. Functions like M_list_first will return head and M_list_last will return end\&.
.PP
The index start changes in STACK mode\&. In STACK mode indexing is opposite\&. Head is len-1 and end is 0 (head \&.\&.\&. end)\&. Entries are still added to end\&. Functions like M_list_first will return end and M_list_last will return head\&. This is to accommodate STACKS where entries are inserted and removed from the same end\&.
.PP
The list is designed for efficient head removal\&. A value removed from head will not cause a memmove\&. Instead a start offset will be noted\&. If there is space before head (due to removals) then additions at head will be efficient as the empty space will be used and a memmove will be avoided\&. memmoves will occur when the size (not necessarly number of elements) of the list changes (expand and shrink) and for removals in the middle of the list\&.
.PP
Sorted notes:
.IP "\(bu" 2
Sorting can be set as stable\&. Insert will also be stable\&.
.IP "\(bu" 2
Sorting on insert and find (\fBM_list_index_of()\fP) is done using binary insert/search\&.
.IP "\(bu" 2
When \fBM_list_insert_end()\fP is called after \fBM_list_insert_begin()\fP mergesort/qsort will be used to sort the list\&.
.IP "\(bu" 2
Sorting can use an optional thunk parameter but it can only be set by using \fBM_list_change_sorting()\fP\&. 
.PP

.SH "Data Structure Documentation"
.PP 
.SH "struct M_list_callbacks"
.PP 
Structure of callbacks that can be registered to override default behavior for list implementation\&. 
.PP
\fBData Fields:\fP
.RS 4
\fBM_sort_compar_t\fP \fIequality\fP Callback to check if two items in the list are equal\&. If NULL unsorted list 
.br
.PP
\fBM_list_duplicate_func\fP \fIduplicate_insert\fP Callback to duplicate a value on insert\&. If NULL is pass-thru pointer 
.br
.PP
\fBM_list_duplicate_func\fP \fIduplicate_copy\fP Callback to duplicate a value on copy\&. If NULL is pass-thru pointer 
.br
.PP
\fBM_list_free_func\fP \fIvalue_free\fP Callback to free a value\&. If NULL is pass-thru pointer 
.br
.PP
.RE
.PP
.SH "Typedef Documentation"
.PP 
.SS "typedef struct M_list \fBM_list_t\fP"

.SS "typedef void*(* M_list_duplicate_func) (const void *)"
Function definition to duplicate a value\&. 
.SS "typedef void(* M_list_free_func) (void *)"
Function definition to free a value\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_list_flags_t\fP"
Flags for controlling the behavior of the list\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_LIST_NONE \fP\fP
List (array) mode\&. Default unless M_LIST_STACK is specified\&. 
.TP
\fB\fIM_LIST_SORTED \fP\fP
Whether the data in the list should be kept in sorted order\&. callbacks cannot be NULL and the equality function must be set if this is M_TRUE\&. Sorting cannot be combined with M_LIST_STACK\&. 
.TP
\fB\fIM_LIST_STABLE \fP\fP
Make insert, search and sort stable\&. 
.TP
\fB\fIM_LIST_STACK \fP\fP
Last in First out mode\&. 
.TP
\fB\fIM_LIST_SET_VAL \fP\fP
All elements are unique based on their value\&. Insert is increased by an additional O(n) operation (on top of the insert itself) in order to determine if a value is a duplicate for unsorted\&. Insert is increased by an additional O(log(n)) operation (on top of the insert itself) in order to determine if a value is a duplicate for sorted\&. 
.TP
\fB\fIM_LIST_SET_PTR \fP\fP
All elements are unique based on their pointer\&. Insert is increased by an additional O(n) operation (on top of the insert itself) in order to determine if a value is a duplicate for unsorted\&. Insert is increased by an additional O(log(n)) operation (on top of the insert itself) in order to determine if a value is a duplicate for sorted\&. 
.TP
\fB\fIM_LIST_NEVERSHRINK \fP\fP
Never allow the list to shrink\&. 
.SS "enum \fBM_list_match_type_t\fP"
Type of matching that should be used when searching/modifying a value in the list\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_LIST_MATCH_VAL \fP\fP
Match based on the value (equality function)\&. 
.TP
\fB\fIM_LIST_MATCH_PTR \fP\fP
Math the pointer itself\&. 
.TP
\fB\fIM_LIST_MATCH_ALL \fP\fP
Include all instances\&. 
.SH "Function Documentation"
.PP 
.SS "\fBM_list_t\fP* M_list_create (const struct \fBM_list_callbacks\fP * callbacks, M_uint32 flags)"
Create a new dynamic list\&.
.PP
A dynamic list is a dynamically expanding array\&. Meaning the array will expand to accommodate new elements\&. The list can be, optionally, kept in sorted order\&. The sorted order is determined by the equality callback function if sorting is enabled\&.
.PP
\fBParameters:\fP
.RS 4
\fIcallbacks\fP Register callbacks for overriding default behavior\&. May pass NULL if not overriding default behavior\&. 
.br
\fIflags\fP M_list_flags_t flags controlling behavior\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Allocated dynamic list\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_destroy\fP 
.RE
.PP

.SS "void M_list_destroy (\fBM_list_t\fP * d, M_bool destroy_vals)"
Destroy the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list to destory\&. 
.br
\fIdestroy_vals\fP Whether the values held in the list should be destroyed\&. If the list is not duplicating the values it holds then destroying values may not be desirable\&. 
.RE
.PP

.SS "void M_list_change_sorting (\fBM_list_t\fP * d, \fBM_sort_compar_t\fP equality, M_uint32 sorted_flags, void * thunk)"
Change the sorting behavior of the list\&.
.PP
The list cannot have been created as a queue\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIequality\fP The equality function to use\&. Can be NULL to remove the equality function\&. 
.br
\fIsorted_flags\fP M_list_flags_t to specify how sorting should be handled\&. Allows the following:
.IP "\(bu" 2
M_LIST_SORTED
.IP "\(bu" 2
M_LIST_STACK Omitting one of these flags will disable it\&. 
.PP
.br
\fIthunk\fP Thunk passed to equality function\&. 
.RE
.PP

.SS "M_bool M_list_insert (\fBM_list_t\fP * d, const void * val)"
Insert a value into the list\&.
.PP
If sorted the value will be inserted in sorted order\&. Otherwise it will be appended to the end of the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIval\fP The value to insert\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success otherwise M_FALSE\&. 
.RE
.PP

.SS "size_t M_list_insert_idx (const \fBM_list_t\fP * d, const void * val)"
Get the index a value would be insert into the list at\&.
.PP
This does not actually insert the value into the list it only gets the position the value would be insert into the list if/when insert is called\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIval\fP The value to get the insertion index for\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The insertion index\&. 
.RE
.PP

.SS "M_bool M_list_insert_at (\fBM_list_t\fP * d, const void * val, size_t idx)"
Insert a value into the list at a specific position\&.
.PP
This is only supported for non-sorted lists\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIval\fP The value to insert\&. 
.br
\fIidx\fP The position to insert at\&. An index larger than the number of elements in the list will result in the item being inserted at the end\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success otherwise M_FALSE\&. 
.RE
.PP

.SS "void M_list_insert_begin (\fBM_list_t\fP * d)"
Start a grouped insertion\&.
.PP
This is only useful for sorted lists\&. This will defer sorting until \fBM_list_insert_end()\fP is called\&. This is to allow many items to be inserted at once without the sorting overhead being called for every insertion\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_insert_end\fP 
.RE
.PP

.SS "void M_list_insert_end (\fBM_list_t\fP * d)"
End a grouped insertion\&.
.PP
This is only useful for sorted lists\&. Cause all elements in the list (if sorting is enabled) to be sorted\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_insert_begin\fP 
.RE
.PP

.SS "size_t M_list_len (const \fBM_list_t\fP * d)"
The length of the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBReturns:\fP
.RS 4
the length of the list\&. 
.RE
.PP

.SS "size_t M_list_count (const \fBM_list_t\fP * d, const void * val, M_uint32 type)"
Count the number of times a value occurs in the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIval\fP The value to search for\&. 
.br
\fItype\fP M_list_match_type_t type of how the val should be matched\&. valid values are:
.IP "\(bu" 2
M_LIST_MATCH_VAL
.IP "\(bu" 2
M_LIST_MATCH_PTR
.PP
.RE
.PP
\fBReturns:\fP
.RS 4
The number of times val appears in the list\&. 
.RE
.PP

.SS "M_bool M_list_index_of (const \fBM_list_t\fP * d, const void * val, M_uint32 type, size_t * idx)"
Get the location of a value within the list\&.
.PP
This will return a location in the list which may not be the first occurrence in the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIval\fP The value to search for\&. 
.br
\fItype\fP M_list_match_type_t type of how the val should be matched\&. valid values are:
.IP "\(bu" 2
M_LIST_MATCH_VAL
.IP "\(bu" 2
M_LIST_MATCH_PTR 
.PP
.br
\fIidx\fP The index of the value within the list\&. Optional, pass NULL if not needed\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the value was found within the list\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "const void* M_list_first (const \fBM_list_t\fP * d)"
Get the first element\&.
.PP
The element will remain a member of the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The element or NULL if there are no elements\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_at\fP 
.PP
\fBM_list_last\fP 
.RE
.PP

.SS "const void* M_list_last (const \fBM_list_t\fP * d)"
Get the last element\&.
.PP
The element will remain a member of the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The element or NULL if there are no elements\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_at\fP 
.PP
\fBM_list_first\fP 
.RE
.PP

.SS "const void* M_list_at (const \fBM_list_t\fP * d, size_t idx)"
Get the element at a given index\&.
.PP
The element will remain a member of the list\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIidx\fP The location to retrieve the element from\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The element or NULL if index is out range\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_first\fP 
.PP
\fBM_list_last\fP 
.RE
.PP

.SS "void* M_list_take_first (\fBM_list_t\fP * d)"
Take the first element\&.
.PP
The element will be removed from the list and returned\&. The caller is responsible for freeing the element\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The element or NULL if there are no elements\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_take_at\fP 
.PP
\fBM_list_last\fP 
.RE
.PP

.SS "void* M_list_take_last (\fBM_list_t\fP * d)"
Take the last element\&.
.PP
The element will be removed from the list and returned\&. The caller is responsible for freeing the element\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The element or NULL if there are no elements\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_take_at\fP 
.PP
\fBM_list_take_first\fP 
.RE
.PP

.SS "void* M_list_take_at (\fBM_list_t\fP * d, size_t idx)"
Take the element at a given index\&.
.PP
The element will be removed from the list and returned\&. The caller is responsible for freeing the element\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIidx\fP The location to retrieve the element from\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The element or NULL if index is out range\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_take_first\fP 
.PP
\fBM_list_take_last\fP 
.RE
.PP

.SS "M_bool M_list_remove_first (\fBM_list_t\fP * d)"
Remove the first element\&.
.PP
The value will be free'd using the value_free callback\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the element was removed\&. Otherwise M_FALSE\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_remove_at\fP 
.PP
\fBM_list_remove_last\fP 
.RE
.PP

.SS "M_bool M_list_remove_last (\fBM_list_t\fP * d)"
Remove the last element\&.
.PP
The value will be free'd using the value_free callback\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the element was removed\&. Otherwise M_FALSE\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_remove_at\fP 
.PP
\fBM_list_remove_first\fP 
.RE
.PP

.SS "M_bool M_list_remove_at (\fBM_list_t\fP * d, size_t idx)"
Remove an element at a given index from the list\&.
.PP
The value will be free'd using the value_free callback\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIidx\fP The index to remove\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the element was removed\&. Otherwise M_FALSE\&.
.RE
.PP
\\ see M_list_remove_first \\ see M_list_remove_last \\ see M_list_remove_val \\ see M_list_remove_range 
.SS "size_t M_list_remove_val (\fBM_list_t\fP * d, const void * val, M_uint32 type)"
Remove element(s) from the list\&.
.PP
Searches the list for the occurrence of val and removes it from the list\&. The value will be free'd using the value_free callback\&.
.PP
Requires the equality callback to be set\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIval\fP The val to remove 
.br
\fItype\fP M_list_match_type_t type of how the val should be matched\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The number of elements removed\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_remove_at\fP 
.RE
.PP

.SS "M_bool M_list_remove_range (\fBM_list_t\fP * d, size_t start, size_t end)"
Remove a range of elements form the list\&.
.PP
The values will be free'd using the value_free callback\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIstart\fP The start index\&. Inclusive\&. 
.br
\fIend\fP The end index\&. Inclusive\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the range was removed\&. Otherwise M_FALSE\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_list_remove_at\fP 
.RE
.PP

.SS "void M_list_remove_duplicates (\fBM_list_t\fP * d, M_uint32 type)"
Remove duplicate elements from the list\&.
.PP
Requires the equality callback to be set\&. The values will be free'd using the value_free callback\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fItype\fP M_list_match_type_t type of how the val should be matched\&. valid values are:
.IP "\(bu" 2
M_LIST_MATCH_VAL
.IP "\(bu" 2
M_LIST_MATCH_PTR 
.PP
.RE
.PP

.SS "size_t M_list_replace_val (\fBM_list_t\fP * d, const void * val, const void * new_val, M_uint32 type)"
Replace all matching values in the list with a different value\&.
.PP
The replaced values in the list will be free'd using the value_free callback\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIval\fP The val to be replaced\&. 
.br
\fInew_val\fP The value to be replaced with\&. 
.br
\fItype\fP M_list_match_type_t type of how the val should be matched\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The number of elements replaced\&. 
.RE
.PP

.SS "M_bool M_list_replace_at (\fBM_list_t\fP * d, const void * val, size_t idx)"
Replace a value in the list with a different value\&.
.PP
The replaced value in the list will be free'd using the value_free callback\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIval\fP The val to that will appear in the list at the given idx\&. 
.br
\fIidx\fP The index to replace\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the value was replaced\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_list_swap (\fBM_list_t\fP * d, size_t idx1, size_t idx2)"
Exchange the elements at the given locations\&.
.PP
This only applies to unsorted lists\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP The list\&. 
.br
\fIidx1\fP The first index\&. 
.br
\fIidx2\fP The second index\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the elements were swapped\&. 
.RE
.PP

.SS "\fBM_list_t\fP* M_list_duplicate (const \fBM_list_t\fP * d)"
Duplicate an existing list\&.
.PP
Will copy all elements of the list as well as any callbacks, etc\&.
.PP
\fBParameters:\fP
.RS 4
\fId\fP list to duplicate\&.
.RE
.PP
\fBReturns:\fP
.RS 4
New list\&. 
.RE
.PP

.SS "void M_list_merge (\fBM_list_t\fP ** dest, \fBM_list_t\fP * src, M_bool include_duplicates, M_uint32 type)"
Merge two lists together\&.
.PP
The second (src) list will be destroyed automatically upon completion of this function\&. Any value pointers for the list will be directly copied over to the destination list, they will not be duplicated\&.
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP Pointer by reference to the list receiving the values\&. if this is NULL, the pointer will simply be switched out for src\&. 
.br
\fIsrc\fP Pointer to the list giving up its values\&. 
.br
\fIinclude_duplicates\fP When M_TRUE any values in 'dest' that also exist in 'src' will be included in 'dest'\&. When M_FALSE any duplicate values will not be added to 'dest'\&. 
.br
\fItype\fP M_list_match_type_t type of how the val should be matched\&. valid values are:
.IP "\(bu" 2
M_LIST_MATCH_VAL
.IP "\(bu" 2
M_LIST_MATCH_PTR 
.PP
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
