.TH "m_tls_certs" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_tls_certs
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct M_tls_x509 \fBM_tls_x509_t\fP"
.br
.ti -1c
.RI "typedef enum \fBM_tls_x509_san_type\fP \fBM_tls_x509_san_type_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_tls_x509_txt_t\fP { \fBM_TLS_X509_TXT_COMMONNAME\fP = 1, \fBM_TLS_X509_TXT_ORGANIZATION\fP = 2, \fBM_TLS_X509_TXT_COUNTRY\fP = 3, \fBM_TLS_X509_TXT_STATE\fP = 4, \fBM_TLS_X509_TXT_ORGANIZATIONALUNIT\fP = 5, \fBM_TLS_X509_TXT_LOCALITY\fP = 6 }"
.br
.ti -1c
.RI "enum \fBM_tls_x509_sig_alg_t\fP { \fBM_TLS_X509_SIG_ALG_SHA1\fP = 1, \fBM_TLS_X509_SIG_ALG_SHA256\fP = 2 }"
.br
.ti -1c
.RI "enum \fBM_tls_x509_san_type\fP { \fBM_TLS_X509_SAN_TYPE_DNS\fP = 1, \fBM_TLS_X509_SAN_TYPE_IP\fP = 2 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "char * \fBM_tls_rsa_generate_key\fP (size_t bits)"
.br
.ti -1c
.RI "\fBM_tls_x509_t\fP * \fBM_tls_x509_new\fP (const char *rsa_privkey)"
.br
.ti -1c
.RI "void \fBM_tls_x509_destroy\fP (\fBM_tls_x509_t\fP *x509)"
.br
.ti -1c
.RI "M_bool \fBM_tls_x509_txt_add\fP (\fBM_tls_x509_t\fP *x509, \fBM_tls_x509_txt_t\fP type, const char *text, M_bool append)"
.br
.ti -1c
.RI "M_bool \fBM_tls_x509_txt_SAN_add\fP (\fBM_tls_x509_t\fP *x509, \fBM_tls_x509_san_type_t\fP type, const char *text, M_bool append)"
.br
.ti -1c
.RI "char * \fBM_tls_x509_write_csr\fP (\fBM_tls_x509_t\fP *x509)"
.br
.ti -1c
.RI "\fBM_tls_x509_t\fP * \fBM_tls_x509_read_csr\fP (const char *csr)"
.br
.ti -1c
.RI "\fBM_tls_x509_t\fP * \fBM_tls_x509_read_crt\fP (const char *crt)"
.br
.ti -1c
.RI "char * \fBM_tls_x509_selfsign\fP (\fBM_tls_x509_t\fP *x509, M_uint64 valid_secs)"
.br
.ti -1c
.RI "char * \fBM_tls_x509_sign\fP (\fBM_tls_x509_t\fP *x509, const char *cacert, const char *caprivkey, M_uint64 valid_secs)"
.br
.ti -1c
.RI "\fBM_time_t\fP \fBM_tls_x509_time_start\fP (\fBM_tls_x509_t\fP *x509)"
.br
.ti -1c
.RI "\fBM_time_t\fP \fBM_tls_x509_time_end\fP (\fBM_tls_x509_t\fP *x509)"
.br
.ti -1c
.RI "char * \fBM_tls_x509_subject_name\fP (\fBM_tls_x509_t\fP *x509)"
.br
.ti -1c
.RI "char * \fBM_tls_x509_issuer_name\fP (\fBM_tls_x509_t\fP *x509)"
.br
.ti -1c
.RI "char * \fBM_tls_x509_signature\fP (\fBM_tls_x509_t\fP *x509, \fBM_tls_x509_sig_alg_t\fP alg)"
.br
.ti -1c
.RI "unsigned char * \fBM_tls_dhparam_generate\fP (size_t bits, size_t *out_len)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Basic TLS certificate functionality\&. This is primary used to aid in generating self signed certificates programmatically\&.
.PP
\fBWarning:\fP
.RS 4
These functions are experimental and unstable\&. They should not be used in production at this time\&.
.RE
.PP
Example generating a CA, server certificate and signing the certificate with the CA\&.
.PP
.PP
.nf
#include <mstdlib/mstdlib\&.h>
#include <mstdlib/mstdlib_tls\&.h>

#define VALID_SEC (5*365*24*60*60)

int main(int argc, char **argv)
{
    char         *CA_privkey;
    M_tls_x509_t *CA_x509;
    char         *CA_crt;
    char         *Server_privkey;
    M_tls_x509_t *Server_x509;
    M_tls_x509_t *Server_csr_x509;
    char         *Server_crt;
    char         *Server_csr;

    // Generate our certificate authority\&. 
    CA_privkey = M_tls_rsa_generate_key(2048);
    CA_x509    = M_tls_x509_new(CA_privkey);
    M_tls_x509_txt_add(CA_x509, M_TLS_X509_TXT_COMMONNAME, "MY CA", M_FALSE);
    M_tls_x509_txt_add(CA_x509, M_TLS_X509_TXT_ORGANIZATION, "MY ORG", M_FALSE);
    M_tls_x509_txt_SAN_add(CA_x509, M_TLS_X509_SAN_TYPE_DNS, "ca\&.myorg\&.local", M_FALSE);
    CA_crt = M_tls_x509_selfsign(CA_x509, VALID_SEC);

    // Generate the server x509
    Server_privkey = M_tls_rsa_generate_key(2048);
    Server_x509    = M_tls_x509_new(Server_privkey);
    M_tls_x509_txt_add(Server_x509, M_TLS_X509_TXT_COMMONNAME, "MY Server", M_FALSE);
    M_tls_x509_txt_add(Server_x509, M_TLS_X509_TXT_ORGANIZATION, "MY ORG", M_FALSE);
    M_tls_x509_txt_SAN_add(Server_x509, M_TLS_X509_SAN_TYPE_DNS, "server\&.myorg\&.local", M_FALSE);

    // Generate a server CSR from the server x509\&.
    // Sign the CSR creating a server certificate\&.
    Server_csr      = M_tls_x509_write_csr(Server_x509);
    Server_csr_x509 = M_tls_x509_read_csr(Server_csr);
    Server_crt      = M_tls_x509_sign(Server_csr_x509, CA_crt, CA_privkey, VALID_SEC);

    M_printf("CA Priv Key:\n%s\n", CA_privkey);
    M_printf("CA CRT:\n%s\n", CA_crt);
    M_printf("Server Priv Key:\n%s\n", Server_privkey);
    M_printf("Server CSR:\n%s\n", Server_csr);
    M_printf("Server CRT:\n%s\n", Server_crt);

    M_free(Server_csr);
    M_free(Server_crt);
    M_free(Server_privkey);
    M_free(CA_crt);
    M_free(CA_privkey);
    M_tls_x509_destroy(CA_x509);
    M_tls_x509_destroy(Server_csr_x509);
    M_tls_x509_destroy(Server_x509);
}
.fi
.PP
 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct M_tls_x509 \fBM_tls_x509_t\fP"

.SS "typedef enum \fBM_tls_x509_san_type\fP \fBM_tls_x509_san_type_t\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_tls_x509_txt_t\fP"
X509 certificate text attributes\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_TLS_X509_TXT_COMMONNAME \fP\fP
(CN) Name of certificate\&. 
.TP
\fB\fIM_TLS_X509_TXT_ORGANIZATION \fP\fP
(O) Organization owning certificate\&. 
.TP
\fB\fIM_TLS_X509_TXT_COUNTRY \fP\fP
(C) County where the organization is located\&. 
.TP
\fB\fIM_TLS_X509_TXT_STATE \fP\fP
(S) State or providence where the organization is located\&. 
.TP
\fB\fIM_TLS_X509_TXT_ORGANIZATIONALUNIT \fP\fP
(OU) Group within the organization owning the certificate\&. 
.TP
\fB\fIM_TLS_X509_TXT_LOCALITY \fP\fP
(L) State, township, county, etc\&. where the organizational unit is located\&. 
.SS "enum \fBM_tls_x509_sig_alg_t\fP"
Certificate hash algorithm\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_TLS_X509_SIG_ALG_SHA1 \fP\fP
SHA 1\&. 
.TP
\fB\fIM_TLS_X509_SIG_ALG_SHA256 \fP\fP
SHA 256\&. 
.SS "enum \fBM_tls_x509_san_type\fP"
Type of subject alternative name\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_TLS_X509_SAN_TYPE_DNS \fP\fP
Name is a host name that can be retrieved by DNS\&. 
.TP
\fB\fIM_TLS_X509_SAN_TYPE_IP \fP\fP
Name is an ip address\&. 
.SH "Function Documentation"
.PP 
.SS "char* M_tls_rsa_generate_key (size_t bits)"
Generate an RSA private key
.PP
\fBParameters:\fP
.RS 4
\fIbits\fP Bit size of the key\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Buffer containing private key 
.RE
.PP

.SS "\fBM_tls_x509_t\fP* M_tls_x509_new (const char * rsa_privkey)"
Create a new x509 certificate\&.
.PP
\fBParameters:\fP
.RS 4
\fIrsa_privkey\fP RSA private key\&.
.RE
.PP
\fBReturns:\fP
.RS 4
X509 certificate\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_tls_rsa_generate_key\fP 
.RE
.PP

.SS "void M_tls_x509_destroy (\fBM_tls_x509_t\fP * x509)"
Destroy an x509 certificate\&.
.PP
\fBParameters:\fP
.RS 4
\fIx509\fP Certificate\&. 
.RE
.PP

.SS "M_bool M_tls_x509_txt_add (\fBM_tls_x509_t\fP * x509, \fBM_tls_x509_txt_t\fP type, const char * text, M_bool append)"
Add a text entry to the certificate of the requested type\&.
.PP
\fBParameters:\fP
.RS 4
\fIx509\fP Certificate\&. 
.br
\fItype\fP Type of attribute\&. 
.br
\fItext\fP Text to put in attribute\&. 
.br
\fIappend\fP M_TRUE to append\&. M_FALSE to replace if the attribute already exists\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "M_bool M_tls_x509_txt_SAN_add (\fBM_tls_x509_t\fP * x509, \fBM_tls_x509_san_type_t\fP type, const char * text, M_bool append)"
Add subject alternative name to a certificate\&.
.PP
\fBParameters:\fP
.RS 4
\fIx509\fP Certificate\&. 
.br
\fItype\fP Type of attribute\&. 
.br
\fItext\fP Text to put in attribute\&. 
.br
\fIappend\fP M_TRUE to append\&. M_FALSE to replace if the attribute already exists\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "char* M_tls_x509_write_csr (\fBM_tls_x509_t\fP * x509)"
Generate a CSR from an x509 certificate\&.
.PP
\fBParameters:\fP
.RS 4
\fIx509\fP Certificate\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String on success, otherwise NULL on error\&. 
.RE
.PP

.SS "\fBM_tls_x509_t\fP* M_tls_x509_read_csr (const char * csr)"
Read a CSR request\&.
.PP
\fBParameters:\fP
.RS 4
\fIcsr\fP CSR requested\&.
.RE
.PP
\fBReturns:\fP
.RS 4
x509 certificate on success, otherwise NULL on error\&. 
.RE
.PP

.SS "\fBM_tls_x509_t\fP* M_tls_x509_read_crt (const char * crt)"
Read a PEM-encoded certificate\&.
.PP
\fBParameters:\fP
.RS 4
\fIcrt\fP Certificate\&.
.RE
.PP
\fBReturns:\fP
.RS 4
x509 certificate on success, otherwise NULL on error\&. 
.RE
.PP

.SS "char* M_tls_x509_selfsign (\fBM_tls_x509_t\fP * x509, M_uint64 valid_secs)"
Self-sign the certificate\&.
.PP
Signs using SHA 256 algorithm\&.
.PP
\fBParameters:\fP
.RS 4
\fIx509\fP Certificate\&. 
.br
\fIvalid_secs\fP The validity period for the certificate in seconds\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Buffer containing x509 certificate\&. 
.RE
.PP

.SS "char* M_tls_x509_sign (\fBM_tls_x509_t\fP * x509, const char * cacert, const char * caprivkey, M_uint64 valid_secs)"
Sign the certificate
.PP
Signs using SHA 256 algorithm\&.
.PP
\fBParameters:\fP
.RS 4
\fIx509\fP Certificate\&. 
.br
\fIcacert\fP CA certificate to use for signing\&. 
.br
\fIcaprivkey\fP CA certificate private key\&. 
.br
\fIvalid_secs\fP The validity period for the certificate in seconds\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Buffer containing signed x509 certificate\&. 
.RE
.PP

.SS "\fBM_time_t\fP M_tls_x509_time_start (\fBM_tls_x509_t\fP * x509)"
Get the start time (not before) of a certificate\&.
.PP
\fBParameters:\fP
.RS 4
\fIx509\fP Certificate\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Time\&. 
.RE
.PP

.SS "\fBM_time_t\fP M_tls_x509_time_end (\fBM_tls_x509_t\fP * x509)"
Get the end time (not after) of a certificate\&.
.PP
\fBParameters:\fP
.RS 4
\fIx509\fP Certificate\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Time\&. 
.RE
.PP

.SS "char* M_tls_x509_subject_name (\fBM_tls_x509_t\fP * x509)"
Get the subject name of a certificate\&.
.PP
\fBParameters:\fP
.RS 4
\fIx509\fP Certificate\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "char* M_tls_x509_issuer_name (\fBM_tls_x509_t\fP * x509)"
Get the issuer name of a certificate\&.
.PP
\fBParameters:\fP
.RS 4
\fIx509\fP Certificate\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "char* M_tls_x509_signature (\fBM_tls_x509_t\fP * x509, \fBM_tls_x509_sig_alg_t\fP alg)"
Retrieves the signature/digest of the x509 certificate\&.
.PP
Useful for matching clients to certificates
.PP
\fBParameters:\fP
.RS 4
\fIx509\fP Certificate\&. 
.br
\fIalg\fP Algorithm to use for signature calculation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "unsigned char* M_tls_dhparam_generate (size_t bits, size_t * out_len)"
Generate DH parameters\&.
.PP
Could take a very long time, should probably occur in its own thread to not block program execution\&.
.PP
\fBParameters:\fP
.RS 4
\fIbits\fP Bit size of the parameters\&. 
.br
\fIout_len\fP Length of the output\&.
.RE
.PP
\fBReturns:\fP
.RS 4
dhparams\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
