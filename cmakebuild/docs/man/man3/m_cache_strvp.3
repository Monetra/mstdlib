.TH "m_cache_strvp" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_cache_strvp
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct M_cache_strvp \fBM_cache_strvp_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_cache_strvp_flags_t\fP { \fBM_CACHE_STRVP_NONE\fP = 0, \fBM_CACHE_STRVP_CASECMP\fP = 1 << 0 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_cache_strvp_t\fP * \fBM_cache_strvp_create\fP (size_t max_size, M_uint32 flags, void(*destroy_func)(void *)) M_MALLOC_ALIASED"
.br
.ti -1c
.RI "void \fBM_cache_strvp_destroy\fP (\fBM_cache_strvp_t\fP *c)"
.br
.ti -1c
.RI "M_bool \fBM_cache_strvp_insert\fP (\fBM_cache_strvp_t\fP *c, const char *key, const void *value)"
.br
.ti -1c
.RI "M_bool \fBM_cache_strvp_remove\fP (\fBM_cache_strvp_t\fP *c, const char *key)"
.br
.ti -1c
.RI "M_bool \fBM_cache_strvp_get\fP (const \fBM_cache_strvp_t\fP *c, const char *key, void **value)"
.br
.ti -1c
.RI "void * \fBM_cache_strvp_get_direct\fP (const \fBM_cache_strvp_t\fP *c, const char *key)"
.br
.ti -1c
.RI "size_t \fBM_cache_strvp_size\fP (const \fBM_cache_strvp_t\fP *c)"
.br
.ti -1c
.RI "size_t \fBM_cache_strvp_max_size\fP (const \fBM_cache_strvp_t\fP *c)"
.br
.ti -1c
.RI "M_bool \fBM_cache_strvp_set_max_size\fP (\fBM_cache_strvp_t\fP *c, size_t max_size)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Hot cache meant for storing string keys and void pointer values\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct M_cache_strvp \fBM_cache_strvp_t\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_cache_strvp_flags_t\fP"
Flags for controlling the behavior of the hash 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_CACHE_STRVP_NONE \fP\fP
Default\&. 
.TP
\fB\fIM_CACHE_STRVP_CASECMP \fP\fP
Compare keys case insensitive\&. 
.SH "Function Documentation"
.PP 
.SS "\fBM_cache_strvp_t\fP* M_cache_strvp_create (size_t max_size, M_uint32 flags, void(*)(void *) destroy_func)"
Create a cache\&.
.PP
\fBParameters:\fP
.RS 4
\fImax_size\fP Maximum number of entries in the cache\&. 
.br
\fIflags\fP M_hash_strvp_flags_t flags for modifying behavior\&. 
.br
\fIdestroy_func\fP The function to be called to destroy value when removed\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Allocated cache\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_cache_strvp_destroy\fP 
.RE
.PP

.SS "void M_cache_strvp_destroy (\fBM_cache_strvp_t\fP * c)"
Destroy the cache\&.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP Cache to destroy 
.RE
.PP

.SS "M_bool M_cache_strvp_insert (\fBM_cache_strvp_t\fP * c, const char * key, const void * value)"
Insert an entry into the cache\&.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP Cache being referenced\&. 
.br
\fIkey\fP Key to insert\&. 
.br
\fIvalue\fP Value to insert into h\&. The c will take ownership of the value\&. Maybe NULL\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, or M_FALSE on failure\&. 
.RE
.PP

.SS "M_bool M_cache_strvp_remove (\fBM_cache_strvp_t\fP * c, const char * key)"
Remove an entry from the cache\&.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP Cache being referenced\&. 
.br
\fIkey\fP Key to remove from the h\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, or M_FALSE if key does not exist\&. 
.RE
.PP

.SS "M_bool M_cache_strvp_get (const \fBM_cache_strvp_t\fP * c, const char * key, void ** value)"
Retrieve the value for a key from the cache\&.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP Cache being referenced\&. 
.br
\fIkey\fP Key for value\&. 
.br
\fIvalue\fP Pointer to value stored in the h\&. Optional, pass NULL if not needed\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if value retrieved, M_FALSE if key does not exist\&. 
.RE
.PP

.SS "void* M_cache_strvp_get_direct (const \fBM_cache_strvp_t\fP * c, const char * key)"
Retrieve the value for a key from the cache, and return it directly as the return value\&.
.PP
This cannot be used if you need to differentiate between a key that doesn't exist vs a key with a NULL value\&.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP Cache being referenced\&. 
.br
\fIkey\fP Key for value to retrieve from the hashtable\&. A NULL or empty string is explicitly disallowed\&.
.RE
.PP
\fBReturns:\fP
.RS 4
NULL if key doesn't exist or NULL value on file, otherwise the value\&. 
.RE
.PP

.SS "size_t M_cache_strvp_size (const \fBM_cache_strvp_t\fP * c)"
Get the number of items in the cache\&.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP Cache being referenced\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Count\&. 
.RE
.PP

.SS "size_t M_cache_strvp_max_size (const \fBM_cache_strvp_t\fP * c)"
Get the maximum number of items allowed in the cache\&.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP Cache being referenced\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Max\&. 
.RE
.PP

.SS "M_bool M_cache_strvp_set_max_size (\fBM_cache_strvp_t\fP * c, size_t max_size)"
Set the maximum number of items allowed in the cache\&.
.PP
This can be used to increase or decrease the maximum size of the cache\&. If the max size is smaller than the number of items in the cache, older items will be removed\&.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP Cache being referenced\&. 
.br
\fImax_size\fP Maximum size\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the max size was changed, otherwise M_FALSE on error\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
