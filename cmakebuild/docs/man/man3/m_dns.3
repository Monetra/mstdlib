.TH "m_dns" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_dns
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct M_dns \fBM_dns_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_dns_t\fP * \fBM_dns_create\fP (void)"
.br
.ti -1c
.RI "M_bool \fBM_dns_destroy\fP (\fBM_dns_t\fP *dns)"
.br
.ti -1c
.RI "M_bool \fBM_dns_set_query_timeout\fP (\fBM_dns_t\fP *dns, M_uint64 timeout_ms)"
.br
.ti -1c
.RI "M_bool \fBM_dns_set_cache_timeout\fP (\fBM_dns_t\fP *dns, M_uint64 timeout_s, M_uint64 max_timeout_s)"
.br
.in -1c
.SH "Detailed Description"
.PP 
It's intended that a single global DNS object will be created to allow for caching\&. Aiding with caching, Happy eyeballs is used to aid in choosing the best server when DNS resolves multiple addresses\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct M_dns \fBM_dns_t\fP"

.SH "Function Documentation"
.PP 
.SS "\fBM_dns_t\fP* M_dns_create (void)"
Create a DNS resolver handle\&.
.PP
This resolver handle is responsible for caching DNS results as well as tracking which associated IP addresses resulted in successful or failed connections for optimizing future connection attempts\&. This DNS handle will be passed into functions that require DNS resolution like \fBM_io_net_client_create()\fP\&.
.PP
It is recommended to create a single DNS resolver handle at startup and pass the same handle to all functions which need it, and destroy the handle at shutdown\&.
.PP
\fBReturns:\fP
.RS 4
Initialized DNS handle 
.RE
.PP

.SS "M_bool M_dns_destroy (\fBM_dns_t\fP * dns)"
Destroys the memory associated with a DNS handle\&.
.PP
DNS uses reference counters, and will delay destruction until after last consumer is destroyed\&.
.PP
\fBParameters:\fP
.RS 4
\fIdns\fP Handle initialized via \fBM_dns_create()\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, M_FALSE if handle is actively being used\&. 
.RE
.PP

.SS "M_bool M_dns_set_query_timeout (\fBM_dns_t\fP * dns, M_uint64 timeout_ms)"
Set the maximum query time before a timeout is returned\&.
.PP
In some cases, if a prior result is cached, the query may still return success rather than a timeout failure at the end of a timeout, but the result will be stale\&. If set to 0, will use the internal default of 5000ms (5s)
.PP
\fBParameters:\fP
.RS 4
\fIdns\fP Initialized DNS object 
.br
\fItimeout_ms\fP Timeout specified in milliseconds\&. If provided as 0, will use the default of 5000ms (5s)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if set successfully, M_FALSE otherwise 
.RE
.PP

.SS "M_bool M_dns_set_cache_timeout (\fBM_dns_t\fP * dns, M_uint64 timeout_s, M_uint64 max_timeout_s)"
Set the maximum amount of time a DNS query can be cached for where results are served out of the cache rather than querying a remote DNS server\&.
.PP
\fBParameters:\fP
.RS 4
\fIdns\fP Initialized DNS object 
.br
\fItimeout_s\fP Timeout in seconds of cache before another DNS query attempt will be made to refresh the cache\&. If 0 is specified, will use the default of 300s (5 minutes)\&. 
.br
\fImax_timeout_s\fP Specify the maximum timeout of the cached results, even if no DNS server is reachable\&. Stale results can no longer be delivered after this timeframe and will result in DNS errors being returned\&. If 0 is specified, will use the default of 3600s (1 hr)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if set successfully, M_FALSE otherwise 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
