.TH "m_thread_common_mutex" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_thread_common_mutex
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct M_thread_mutex \fBM_thread_mutex_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_thread_mutexattr_t\fP { \fBM_THREAD_MUTEXATTR_NONE\fP = 0, \fBM_THREAD_MUTEXATTR_RECURSIVE\fP = 1 << 0 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_thread_mutex_t\fP * \fBM_thread_mutex_create\fP (M_uint32 attr)"
.br
.ti -1c
.RI "void \fBM_thread_mutex_destroy\fP (\fBM_thread_mutex_t\fP *mutex)"
.br
.ti -1c
.RI "M_bool \fBM_thread_mutex_lock\fP (\fBM_thread_mutex_t\fP *mutex)"
.br
.ti -1c
.RI "M_bool \fBM_thread_mutex_trylock\fP (\fBM_thread_mutex_t\fP *mutex)"
.br
.ti -1c
.RI "M_bool \fBM_thread_mutex_unlock\fP (\fBM_thread_mutex_t\fP *mutex)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Thread Mutexes (Locks/Critical Sections) 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct M_thread_mutex \fBM_thread_mutex_t\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_thread_mutexattr_t\fP"
Mutex attributes\&. Used for mutex creation\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_THREAD_MUTEXATTR_NONE \fP\fP
None\&. 
.TP
\fB\fIM_THREAD_MUTEXATTR_RECURSIVE \fP\fP
Mutex is recursive\&. 
.SH "Function Documentation"
.PP 
.SS "\fBM_thread_mutex_t\fP* M_thread_mutex_create (M_uint32 attr)"
Mutex create\&.
.PP
\fBParameters:\fP
.RS 4
\fIattr\fP M_thread_mutexattr_t attributes which control how the mutex should behave\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Mutex on success otherwise NULL on error\&. 
.RE
.PP

.SS "void M_thread_mutex_destroy (\fBM_thread_mutex_t\fP * mutex)"
Destroy a mutex\&.
.PP
\fBParameters:\fP
.RS 4
\fImutex\fP The mutex\&. 
.RE
.PP

.SS "M_bool M_thread_mutex_lock (\fBM_thread_mutex_t\fP * mutex)"
Lock a mutex\&.
.PP
This will block until the mutex can be locked\&.
.PP
\fBParameters:\fP
.RS 4
\fImutex\fP The mutex\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the function returns due to a successful mutex lock\&. Otherwise M_FALSE on error\&. This can fail for a number of reasons, for example:
.IP "\(bu" 2
The mutex was already locked by this thread\&.
.IP "\(bu" 2
The mutex is invalid\&.
.IP "\(bu" 2
The mutex has exceeded the maximum number of recursive locks\&. 
.PP
.RE
.PP

.SS "M_bool M_thread_mutex_trylock (\fBM_thread_mutex_t\fP * mutex)"
Try to lock the mutex\&.
.PP
Does not block waiting to lock the mutex\&.
.PP
\fBParameters:\fP
.RS 4
\fImutex\fP The mutex\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the mutex was locked\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_thread_mutex_unlock (\fBM_thread_mutex_t\fP * mutex)"
Unlock a locked mutex\&.
.PP
\fBParameters:\fP
.RS 4
\fImutex\fP The mutex\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the mutex was unlocked\&. Otherwise M_FALSE\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
