.TH "m_str_mutate" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_str_mutate
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "char * \fBM_str_lower\fP (char *s)"
.br
.ti -1c
.RI "char * \fBM_str_lower_max\fP (char *s, size_t max)"
.br
.ti -1c
.RI "char * \fBM_str_upper\fP (char *s)"
.br
.ti -1c
.RI "char * \fBM_str_upper_max\fP (char *s, size_t max)"
.br
.ti -1c
.RI "char * \fBM_str_trim\fP (char *s)"
.br
.ti -1c
.RI "char * \fBM_str_trim_max\fP (char *s, size_t max)"
.br
.ti -1c
.RI "char * \fBM_str_remove_bracketed\fP (const char *src, char open, char close) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_str_remove_bracketed_quoted\fP (const char *src, char open, char close, char quote, char escape) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_str_keep_bracketed\fP (const char *src, char open, char close) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_str_keep_bracketed_quoted\fP (const char *src, char open, char close, char quote, char escape) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_str_remove_quoted\fP (const char *src, char quote_char, char escape_char) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_str_keep_quoted\fP (const char *src, char quote_char, char escape_char) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_str_unquote\fP (char *s, unsigned char quote, unsigned char escape)"
.br
.ti -1c
.RI "char * \fBM_str_unquote_max\fP (char *s, unsigned char quote, unsigned char escape, size_t max)"
.br
.ti -1c
.RI "char * \fBM_str_quote\fP (const char *s, unsigned char quote, unsigned char escape) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_str_quote_max\fP (const char *s, unsigned char quote, unsigned char escape, size_t max) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "M_bool \fBM_str_quote_if_necessary\fP (char **out, const char *s, unsigned char quote, unsigned char escape, unsigned char delim)"
.br
.ti -1c
.RI "char * \fBM_str_delete_spaces\fP (char *s)"
.br
.ti -1c
.RI "char * \fBM_str_delete_newlines\fP (char *s)"
.br
.ti -1c
.RI "char * \fBM_str_replace_chr\fP (char *s, char b, char a)"
.br
.ti -1c
.RI "size_t \fBM_str_justify\fP (char *dest, size_t destlen, const char *src, \fBM_str_justify_type_t\fP justtype, unsigned char justchar, size_t justlen)"
.br
.ti -1c
.RI "size_t \fBM_str_justify_max\fP (char *dest, size_t destlen, const char *src, size_t srclen, \fBM_str_justify_type_t\fP justtype, unsigned char justchar, size_t justlen)"
.br
.ti -1c
.RI "M_bool \fBM_str_cpy\fP (char *dest, size_t dest_len, const char *src)"
.br
.ti -1c
.RI "M_bool \fBM_str_cpy_max\fP (char *dest, size_t dest_len, const char *src, size_t src_len)"
.br
.ti -1c
.RI "M_bool \fBM_str_cat\fP (char *dest, size_t dest_len, const char *src)"
.br
.in -1c
.SH "Detailed Description"
.PP 
String Manipulation (in-place)) Functions 
.SH "Function Documentation"
.PP 
.SS "char* M_str_lower (char * s)"
Convert all characters in place to lower case\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
pointer to string on success\&. Otherwise NULL\&. 
.RE
.PP

.SS "char* M_str_lower_max (char * s, size_t max)"
Convert all characters in place to lower case up to a maximum length\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fImax\fP Max length to convert\&.
.RE
.PP
\fBReturns:\fP
.RS 4
pointer to string on success\&. Otherwise NULL\&. 
.RE
.PP

.SS "char* M_str_upper (char * s)"
Convert all characters in place to upper case\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to string on success\&. Otherwise NULL\&. 
.RE
.PP

.SS "char* M_str_upper_max (char * s, size_t max)"
Convert all characters in place to upper case up to a maximum length\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fImax\fP max Max length to convert\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to string on success\&. Otherwise NULL\&. 
.RE
.PP

.SS "char* M_str_trim (char * s)"
Remove whitespace from the beginning and end of the string in place\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Start of the string without whitespace\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_chr_isspace\fP 
.RE
.PP

.SS "char* M_str_trim_max (char * s, size_t max)"
Remove whitespace from the beginning and end of the string in place up to a maximum length\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fImax\fP Max length to trim\&.
.RE
.PP
\fBReturns:\fP
.RS 4
the start of the string without whitespace\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_chr_isspace\fP 
.RE
.PP

.SS "char* M_str_remove_bracketed (const char * src, char open, char close)"
Return a copy of the given string with bracketed expressions removed\&.
.PP
You must use different characters for \fIopen\fP and \fIclose\fP\&. If you pass the same character for both, this function will return NULL\&.
.PP
For example, the string 'abc (asd(e))?' becomes 'abc ?' after calling this function with '(' as the \fIopen\fP bracket and ')' as the \fIclose\fP bracket\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_str_remove_bracketed_quoted\fP 
.PP
\fBM_str_keep_bracketed\fP 
.PP
\fBM_str_remove_quoted\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP string to copy 
.br
\fIopen\fP character that represents the start of a bracketed expression 
.br
\fIclose\fP character that represents the end of a bracketed expression 
.RE
.PP
\fBReturns:\fP
.RS 4
copy of input string, with bracketed expressions removed 
.RE
.PP

.SS "char* M_str_remove_bracketed_quoted (const char * src, char open, char close, char quote, char escape)"
Return a copy of the given string with bracketed expressions removed\&.
.PP
Brackets inside quoted expressions are ignored\&.
.PP
You must use different characters for \fIopen\fP and \fIclose\fP\&. If you pass the same character for both, this function will return NULL\&.
.PP
For example, the string 'abc (asd(e))?' becomes 'abc ?' after calling this function with '(' as the \fIopen\fP bracket and ')' as the \fIclose\fP bracket\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_str_remove_bracketed_quoted\fP 
.PP
\fBM_str_keep_bracketed\fP 
.PP
\fBM_str_remove_quoted\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP string to copy 
.br
\fIopen\fP character that represents the start of a bracketed expression 
.br
\fIclose\fP character that represents the end of a bracketed expression 
.br
\fIquote\fP character that represents open/close of quoted string 
.br
\fIescape\fP character that can be used to escape a quote char 
.RE
.PP
\fBReturns:\fP
.RS 4
copy of input string, with bracketed expressions removed 
.RE
.PP

.SS "char* M_str_keep_bracketed (const char * src, char open, char close)"
Return a copy of the given string with everything outside bracketed expressions removed\&.
.PP
You must use different characters for \fIopen\fP and \fIclose\fP\&. If you pass the same character for both, this function will return NULL\&.
.PP
For example, the string 'abc (asd(e))?' becomes 'asd(e)' after calling this function with '(' as the \fIopen\fP bracket and ')' as the \fIclose\fP bracket\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_str_keep_bracketed_quoted\fP 
.PP
\fBM_str_remove_bracketed\fP 
.PP
\fBM_str_keep_quoted\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP string to copy 
.br
\fIopen\fP character that represents the start of a bracketed expression 
.br
\fIclose\fP character that represents the end of a bracketed expression 
.RE
.PP
\fBReturns:\fP
.RS 4
copy of input string, containing only the contents of bracketed expressions 
.RE
.PP

.SS "char* M_str_keep_bracketed_quoted (const char * src, char open, char close, char quote, char escape)"
Return a copy of the given string with everything outside bracketed expressions removed (quote aware)\&.
.PP
Brackets inside quoted expressions are ignored\&.
.PP
You must use different characters for \fIopen\fP and \fIclose\fP\&. If you pass the same character for both, this function will return NULL\&.
.PP
For example, the string 'abc (asd(e))?' becomes 'asd(e)' after calling this function with '(' as the \fIopen\fP bracket and ')' as the \fIclose\fP bracket\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_str_keep_bracketed\fP 
.PP
\fBM_str_remove_bracketed\fP 
.PP
\fBM_str_keep_quoted\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP string to copy 
.br
\fIopen\fP character that represents the start of a bracketed expression 
.br
\fIclose\fP character that represents the end of a bracketed expression 
.br
\fIquote\fP character that represents open/close of quoted string 
.br
\fIescape\fP character that can be used to escape a quote char 
.RE
.PP
\fBReturns:\fP
.RS 4
copy of input string, containing only the contents of bracketed expressions 
.RE
.PP

.SS "char* M_str_remove_quoted (const char * src, char quote_char, char escape_char)"
Return a copy of the given string with quoted expressions removed\&.
.PP
Quote characters that are preceded by the escape character are not processed as quotes\&. If you don't wish to specify an escape character, pass '\\0' for that argument\&.
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP string to copy 
.br
\fIquote_char\fP character that represents begin/end of a quoted section 
.br
\fIescape_char\fP character that can be used to escape a quote char 
.RE
.PP
\fBReturns:\fP
.RS 4
copy of input string, with quoted expressions removed 
.RE
.PP

.SS "char* M_str_keep_quoted (const char * src, char quote_char, char escape_char)"
Return a copy of the given string with everything outside quoted expressions removed\&.
.PP
Quote characters that are preceded by the escape character are not processed as quotes\&. If you don't wish to specify an escape character, pass '\\0' for that argument\&.
.PP
Any escape character sequences ([escape][escape] or [escape][quote]) inside the quoted content are replaced by the characters they represent ([escape] or [quote], respectively)\&.
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP string to copy 
.br
\fIquote_char\fP character that represents begin/end of a quoted section 
.br
\fIescape_char\fP character that can be added 
.RE
.PP
\fBReturns:\fP
.RS 4
copy of input string, containing only the contents of quoted expressions 
.RE
.PP

.SS "char* M_str_unquote (char * s, unsigned char quote, unsigned char escape)"
Remove quotes from a string and unescape escaped quotes in place\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fIquote\fP Quote character\&. 
.br
\fIescape\fP Escape character\&. Removed from other escape characters and quotes\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Start of unquoted string\&. 
.RE
.PP

.SS "char* M_str_unquote_max (char * s, unsigned char quote, unsigned char escape, size_t max)"
Remove quotes from a string and unescape escaped quotes in place up to a maximum length\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fIquote\fP Quote character\&. 
.br
\fIescape\fP Escape character\&. Removed from other escape characters and quotes\&. 
.br
\fImax\fP Max length\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Start of unquoted string\&. 
.RE
.PP

.SS "char* M_str_quote (const char * s, unsigned char quote, unsigned char escape)"
Quote a string
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fIquote\fP Quote character\&. 
.br
\fIescape\fP Escape character\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Start of quoted string 
.RE
.PP

.SS "char* M_str_quote_max (const char * s, unsigned char quote, unsigned char escape, size_t max)"
Quote a string up to a maximum length\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fIquote\fP Quote character\&. 
.br
\fIescape\fP Escape character\&. 
.br
\fImax\fP Max length\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Start of quoted string\&. 
.RE
.PP

.SS "M_bool M_str_quote_if_necessary (char ** out, const char * s, unsigned char quote, unsigned char escape, unsigned char delim)"
Quote a string only if necessary\&.
.PP
Quotes if the string starts or ends with a space\&. Or if the delimiter is found in the string\&.
.PP
\fBParameters:\fP
.RS 4
\fIout\fP Quoted string\&. 
.br
\fIs\fP NULL-terminated string\&. 
.br
\fIquote\fP Quote character\&. 
.br
\fIescape\fP Escape character\&. 
.br
\fIdelim\fP Delimiter\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the string was quoted and out was set\&. Otherwise M_FALSE\&. 
.RE
.PP

.SS "char* M_str_delete_spaces (char * s)"
Delete all whitespace characters from the string\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Start of string with whitespace removed\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_chr_isspace\fP 
.RE
.PP

.SS "char* M_str_delete_newlines (char * s)"
Delete all newline characters (\\r and \\n) from the string\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Start of string with newlines removed\&. 
.RE
.PP

.SS "char* M_str_replace_chr (char * s, char b, char a)"
Replace a character within a string with another character in place\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fIb\fP Character to replace\&. 
.br
\fIa\fP Character to replace with\&. b is replaced with a\&.
.RE
.PP
\fBReturns:\fP
.RS 4
start of string with character replaced\&. Does not make a duplicate\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_strdup_replace_charset\fP 
.PP
\fBM_strdup_replace_str\fP 
.RE
.PP

.SS "size_t M_str_justify (char * dest, size_t destlen, const char * src, \fBM_str_justify_type_t\fP justtype, unsigned char justchar, size_t justlen)"
Justifies the input source as specified by the parameters and writes it to the destination buffer\&. Source and Destination buffers may overlap\&.
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP Destination buffer where the output is placed\&. 
.br
\fIdestlen\fP Length of destination buffer\&. 
.br
\fIsrc\fP Input buffer to be justified\&. 
.br
\fIjusttype\fP Type of justification to be performed\&. 
.br
\fIjustchar\fP Character to use as padding/filler for justification (ignored if M_JUSTIFY_TRUNC_RIGHT or M_JUSTIFY_TRUNC_LEFT) 
.br
\fIjustlen\fP Length requested for justification (or truncation)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on error (such as if it would truncate when requested not to, or invalid use)\&. Length of justified output on success (typically same as justlen, unless using M_JUSTIFY_TRUNC_RIGHT or M_JUSTIFY_TRUNC_LEFT)\&. 
.RE
.PP

.SS "size_t M_str_justify_max (char * dest, size_t destlen, const char * src, size_t srclen, \fBM_str_justify_type_t\fP justtype, unsigned char justchar, size_t justlen)"
Justifies the input source as specified by the parameters and writes it to the destination buffer\&. Source and destination buffers may overlap\&.
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP Destination buffer where the output is placed\&. 
.br
\fIdestlen\fP Length of destination buffer\&. 
.br
\fIsrc\fP Input buffer to be justified\&. 
.br
\fIsrclen\fP Length of input source\&. 
.br
\fIjusttype\fP Type of justification to be performed\&. 
.br
\fIjustchar\fP Character to use as padding/filler for justification\&. (ignored if M_JUSTIFY_TRUNC_RIGHT or M_JUSTIFY_TRUNC_LEFT) 
.br
\fIjustlen\fP Length requested for justification (or truncation)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on error (such as if it would truncate when requested not to, or invalid use)\&. Length of justified output on success (typically same as justlen, unless using M_JUSTIFY_TRUNC_RIGHT or M_JUSTIFY_TRUNC_LEFT)\&. 
.RE
.PP

.SS "M_bool M_str_cpy (char * dest, size_t dest_len, const char * src)"
Copy a string from one location to another\&.
.PP
This guarantees NULL termination of dest\&.
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP Destination buffer where the output is placed\&. 
.br
\fIdest_len\fP Length of destination buffer\&. 
.br
\fIsrc\fP Input buffer to be justified\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_cpy_max (char * dest, size_t dest_len, const char * src, size_t src_len)"
Copy a given length of a string from one location to another\&.
.PP
This guarantees NULL termination of dest\&.
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP Destination buffer where the output is placed\&. 
.br
\fIdest_len\fP Length of destination buffer\&. 
.br
\fIsrc\fP Input buffer to be justified\&. 
.br
\fIsrc_len\fP Length of source string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_str_cat (char * dest, size_t dest_len, const char * src)"
Append a string on to another\&.
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP String to be appended to\&. 
.br
\fIdest_len\fP The length of dest\&. 
.br
\fIsrc\fP String to be appended\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if src was appended to dest\&. Otherwise M_FALSE\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
