.TH "m_hash_u64str" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_hash_u64str
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct M_hash_u64str \fBM_hash_u64str_t\fP"
.br
.ti -1c
.RI "typedef struct M_hash_u64str_enum \fBM_hash_u64str_enum_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_hash_u64str_flags_t\fP { \fBM_HASH_U64STR_NONE\fP = 0, \fBM_HASH_U64STR_KEYS_ORDERED\fP = 1 << 0, \fBM_HASH_U64STR_KEYS_SORTASC\fP = 1 << 1, \fBM_HASH_U64STR_KEYS_SORTDESC\fP = 1 << 2, \fBM_HASH_U64STR_MULTI_VALUE\fP = 1 << 3, \fBM_HASH_U64STR_MULTI_SORTASC\fP = 1 << 4, \fBM_HASH_U64STR_MULTI_SORTDESC\fP = 1 << 5, \fBM_HASH_U64STR_MULTI_GETLAST\fP = 1 << 6, \fBM_HASH_U64STR_MULTI_CASECMP\fP = 1 << 7 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_hash_u64str_t\fP * \fBM_hash_u64str_create\fP (size_t size, M_uint8 fillpct, M_uint32 flags) M_MALLOC"
.br
.ti -1c
.RI "void \fBM_hash_u64str_destroy\fP (\fBM_hash_u64str_t\fP *h) M_FREE(1)"
.br
.ti -1c
.RI "M_bool \fBM_hash_u64str_insert\fP (\fBM_hash_u64str_t\fP *h, M_uint64 key, const char *value)"
.br
.ti -1c
.RI "M_bool \fBM_hash_u64str_remove\fP (\fBM_hash_u64str_t\fP *h, M_uint64 key)"
.br
.ti -1c
.RI "M_bool \fBM_hash_u64str_get\fP (const \fBM_hash_u64str_t\fP *h, M_uint64 key, const char **value)"
.br
.ti -1c
.RI "const char * \fBM_hash_u64str_get_direct\fP (const \fBM_hash_u64str_t\fP *h, M_uint64 key)"
.br
.ti -1c
.RI "M_bool \fBM_hash_u64str_multi_len\fP (const \fBM_hash_u64str_t\fP *h, M_uint64 key, size_t *len)"
.br
.ti -1c
.RI "M_bool \fBM_hash_u64str_multi_get\fP (const \fBM_hash_u64str_t\fP *h, M_uint64 key, size_t idx, const char **value)"
.br
.ti -1c
.RI "const char * \fBM_hash_u64str_multi_get_direct\fP (const \fBM_hash_u64str_t\fP *h, M_uint64 key, size_t idx)"
.br
.ti -1c
.RI "M_bool \fBM_hash_u64str_multi_remove\fP (\fBM_hash_u64str_t\fP *h, M_uint64 key, size_t idx)"
.br
.ti -1c
.RI "M_uint32 \fBM_hash_u64str_size\fP (const \fBM_hash_u64str_t\fP *h)"
.br
.ti -1c
.RI "size_t \fBM_hash_u64str_num_collisions\fP (const \fBM_hash_u64str_t\fP *h)"
.br
.ti -1c
.RI "size_t \fBM_hash_u64str_num_expansions\fP (const \fBM_hash_u64str_t\fP *h)"
.br
.ti -1c
.RI "size_t \fBM_hash_u64str_num_keys\fP (const \fBM_hash_u64str_t\fP *h)"
.br
.ti -1c
.RI "size_t \fBM_hash_u64str_enumerate\fP (const \fBM_hash_u64str_t\fP *h, \fBM_hash_u64str_enum_t\fP **hashenum)"
.br
.ti -1c
.RI "M_bool \fBM_hash_u64str_enumerate_next\fP (const \fBM_hash_u64str_t\fP *h, \fBM_hash_u64str_enum_t\fP *hashenum, M_uint64 *key, const char **value)"
.br
.ti -1c
.RI "void \fBM_hash_u64str_enumerate_free\fP (\fBM_hash_u64str_enum_t\fP *hashenum)"
.br
.ti -1c
.RI "void \fBM_hash_u64str_merge\fP (\fBM_hash_u64str_t\fP **dest, \fBM_hash_u64str_t\fP *src) M_FREE(2)"
.br
.ti -1c
.RI "\fBM_hash_u64str_t\fP * \fBM_hash_u64str_duplicate\fP (const \fBM_hash_u64str_t\fP *h) M_MALLOC"
.br
.in -1c
.SH "Detailed Description"
.PP 
Hashtable, meant for storing uint64 keys and string values\&.
.PP
References to the data will always be read-only\&. All keys and values will be duplicated by the hashtable\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct M_hash_u64str \fBM_hash_u64str_t\fP"

.SS "typedef struct M_hash_u64str_enum \fBM_hash_u64str_enum_t\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_hash_u64str_flags_t\fP"
Flags for controlling the behavior of the hashtable 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_HASH_U64STR_NONE \fP\fP
Case sensitive single value (new values replace)\&. 
.TP
\fB\fIM_HASH_U64STR_KEYS_ORDERED \fP\fP
Keys should be ordered\&. Default is insertion order unless the sorted option is specified\&. 
.TP
\fB\fIM_HASH_U64STR_KEYS_SORTASC \fP\fP
When the keys are ordered sort them using the key_equality function\&. 
.TP
\fB\fIM_HASH_U64STR_KEYS_SORTDESC \fP\fP
When the keys are ordered sort them using the key_equality function\&. 
.TP
\fB\fIM_HASH_U64STR_MULTI_VALUE \fP\fP
Allow keys to contain multiple values\&. Sorted in insertion order another sorting is specified\&. 
.TP
\fB\fIM_HASH_U64STR_MULTI_SORTASC \fP\fP
Allow keys to contain multiple values sorted in ascending order 
.TP
\fB\fIM_HASH_U64STR_MULTI_SORTDESC \fP\fP
Allow keys to contain multiple values sorted in descending order 
.TP
\fB\fIM_HASH_U64STR_MULTI_GETLAST \fP\fP
When using get and get_direct function get the last value from the list when allowing multiple values\&. The default is to get the first value\&. 
.TP
\fB\fIM_HASH_U64STR_MULTI_CASECMP \fP\fP
Value compare is case insensitive\&. 
.SH "Function Documentation"
.PP 
.SS "\fBM_hash_u64str_t\fP* M_hash_u64str_create (size_t size, M_uint8 fillpct, M_uint32 flags)"
Create a new hashtable\&.
.PP
The hashtable will pre-allocate an array of buckets based on the rounded up size specified\&. Any hash collisions will result in those collisions being chained together via a linked list\&. The hashtable will auto-expand by a power of 2 when the fill percentage specified is reached\&. All key entries are compared in a case-insensitive fashion, and are duplicated internally\&. Values are duplicated\&. Case is preserved for both keys and values\&.
.PP
\fBParameters:\fP
.RS 4
\fIsize\fP Size of the hash table\&. If not specified as a power of 2, will be rounded up to the nearest power of 2\&. 
.br
\fIfillpct\fP The maximum fill percentage before the hash table is expanded\&. If 0 is specified, the hashtable will never expand, otherwise the value must be between 1 and 99 (recommended: 75)\&. 
.br
\fIflags\fP M_hash_u64str_flags_t flags for modifying behavior\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Allocated hashtable\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_hash_u64str_destroy\fP 
.RE
.PP

.SS "void M_hash_u64str_destroy (\fBM_hash_u64str_t\fP * h)"
Destroy the hashtable\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP Hashtable to destroy 
.RE
.PP

.SS "M_bool M_hash_u64str_insert (\fBM_hash_u64str_t\fP * h, M_uint64 key, const char * value)"
Insert an entry into the hashtable\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP Hashtable being referenced\&. 
.br
\fIkey\fP Key to insert\&. 
.br
\fIvalue\fP Value to insert into hashtable\&. Value will be duplicated, and case will be preserved\&. May be NULL\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, or M_FALSE on failure\&. 
.RE
.PP

.SS "M_bool M_hash_u64str_remove (\fBM_hash_u64str_t\fP * h, M_uint64 key)"
Remove an entry from the hashtable\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP Hashtable being referenced\&. 
.br
\fIkey\fP Key to remove from the hashtable\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, or M_FALSE if key does not exist\&. 
.RE
.PP

.SS "M_bool M_hash_u64str_get (const \fBM_hash_u64str_t\fP * h, M_uint64 key, const char ** value)"
Retrieve the value for a key from the hashtable\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP Hashtable being referenced\&. 
.br
\fIkey\fP Key for value\&. A NULL or empty string is explicitly disallowed\&. 
.br
\fIvalue\fP Pointer to value stored in the hashtable\&. Optional, pass NULL if not needed\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if value retrieved, M_FALSE if key does not exist\&. 
.RE
.PP

.SS "const char* M_hash_u64str_get_direct (const \fBM_hash_u64str_t\fP * h, M_uint64 key)"
Retrieve the value for a key from the hashtable, and return it directly as the return value\&.
.PP
This cannot be used if you need to differentiate between a key that doesn't exist vs a key with a NULL value\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP Hashtable being referenced\&. 
.br
\fIkey\fP Key for value to retrieve from the hashtable\&. A NULL or empty string is explicitly disallowed\&.
.RE
.PP
\fBReturns:\fP
.RS 4
NULL if key doesn't exist or NULL value on file, otherwise the value\&. 
.RE
.PP

.SS "M_bool M_hash_u64str_multi_len (const \fBM_hash_u64str_t\fP * h, M_uint64 key, size_t * len)"
Get the number of values for a given key\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP Hashtable being referenced\&. 
.br
\fIkey\fP Key for value to retrieve\&. 
.br
\fIlen\fP The number of values\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if length is retrieved, M_FALSE if key does not exist\&. 
.RE
.PP

.SS "M_bool M_hash_u64str_multi_get (const \fBM_hash_u64str_t\fP * h, M_uint64 key, size_t idx, const char ** value)"
Retrieve the value for a key from the given index when supporting muli-values\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP Hashtable being referenced\&. 
.br
\fIkey\fP Key for value to retrieve\&. 
.br
\fIidx\fP The index the value resides at\&. 
.br
\fIvalue\fP Pointer to value stored\&. Optional, pass NULL if not needed\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if value retrieved, M_FALSE if key does not exist 
.RE
.PP

.SS "const char* M_hash_u64str_multi_get_direct (const \fBM_hash_u64str_t\fP * h, M_uint64 key, size_t idx)"
Retrieve the value for a key from the given index when supporting muli-values\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP Hashtable being referenced\&. 
.br
\fIkey\fP Key for value to retrieve\&. 
.br
\fIidx\fP The index the value resides at\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if value retrieved, M_FALSE if key does not exist\&. 
.RE
.PP

.SS "M_bool M_hash_u64str_multi_remove (\fBM_hash_u64str_t\fP * h, M_uint64 key, size_t idx)"
Remove a value from the hashtable when supporting muli-values\&.
.PP
If all values have been removed then the key will be removed\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP Hashtable being referenced 
.br
\fIkey\fP Key for value to retrieve\&. 
.br
\fIidx\fP The index the value resides at\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the value was removed, M_FALSE if key does not exist\&. 
.RE
.PP

.SS "M_uint32 M_hash_u64str_size (const \fBM_hash_u64str_t\fP * h)"
Retrieve the current size (number of buckets/slots, not necessarily used)\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP Hashtable being referenced\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Size of the hashtable\&. 
.RE
.PP

.SS "size_t M_hash_u64str_num_collisions (const \fBM_hash_u64str_t\fP * h)"
Retrieve the number of collisions for hashtable entries that has occurred since creation\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP Hashtable being referenced\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Number of collisions\&. 
.RE
.PP

.SS "size_t M_hash_u64str_num_expansions (const \fBM_hash_u64str_t\fP * h)"
Retrieve the number of expansions/rehashes since creation\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP Hashtable being referenced\&.
.RE
.PP
\fBReturns:\fP
.RS 4
number of expansions/rehashes\&. 
.RE
.PP

.SS "size_t M_hash_u64str_num_keys (const \fBM_hash_u64str_t\fP * h)"
Retrieve the number of entries in the hashtable\&.
.PP
This is the number of keys stored\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP Hashtable being referenced\&.
.RE
.PP
\fBReturns:\fP
.RS 4
number of entries in the hashtable\&. 
.RE
.PP

.SS "size_t M_hash_u64str_enumerate (const \fBM_hash_u64str_t\fP * h, \fBM_hash_u64str_enum_t\fP ** hashenum)"
Start an enumeration of the keys within the hashtable\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP Hashtable being referenced\&. 
.br
\fIhashenum\fP Outputs an initialized state variable for starting an enumeration\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Number of values in the hashtable\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_hash_u64str_enumerate_free\fP 
.RE
.PP

.SS "M_bool M_hash_u64str_enumerate_next (const \fBM_hash_u64str_t\fP * h, \fBM_hash_u64str_enum_t\fP * hashenum, M_uint64 * key, const char ** value)"
Retrieve the next item from a hashtable enumeration\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP Hashtable being referenced\&. 
.br
\fIhashenum\fP State variable for tracking the enumeration process\&. 
.br
\fIkey\fP Value of next enumerated key\&. Optional, pass NULL if not needed\&. 
.br
\fIvalue\fP Value of next enumerated value\&. Optional, pass NULL if not needed\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if enumeration succeeded, M_FALSE if no more keys\&. 
.RE
.PP

.SS "void M_hash_u64str_enumerate_free (\fBM_hash_u64str_enum_t\fP * hashenum)"
Destroy an enumeration state\&.
.PP
\fBParameters:\fP
.RS 4
\fIhashenum\fP Enumeration to destroy\&. 
.RE
.PP

.SS "void M_hash_u64str_merge (\fBM_hash_u64str_t\fP ** dest, \fBM_hash_u64str_t\fP * src)"
Merge two hashtables together\&.
.PP
The second (src) hashtable will be destroyed automatically upon completion of this function\&. Any key/value pointers for the hashtable will be directly copied over to the destination hashtable, they will not be duplicated\&. Any keys which exist in 'dest' that also exist in 'src' will be overwritten by the 'src' value\&.
.PP
\fBParameters:\fP
.RS 4
\fIdest\fP Pointer by reference to the hashtable receiving the key/value pairs\&. if dest is NULL, the src address will simply be copied to dest\&. 
.br
\fIsrc\fP Pointer to the hashtable giving up its key/value pairs\&. 
.RE
.PP

.SS "\fBM_hash_u64str_t\fP* M_hash_u64str_duplicate (const \fBM_hash_u64str_t\fP * h)"
Duplicate an existing hashtable\&.
.PP
Copying all keys and values\&.
.PP
\fBParameters:\fP
.RS 4
\fIh\fP Hashtable to be copied\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Duplicated hashtable\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
