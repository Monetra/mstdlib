.TH "m_bit_buf" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_bit_buf
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct M_bit_buf \fBM_bit_buf_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_bit_buf_pad_t\fP { \fBM_BIT_BUF_PAD_NONE\fP = 0, \fBM_BIT_BUF_PAD_BEFORE\fP, \fBM_BIT_BUF_PAD_AFTER\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_bit_buf_t\fP * \fBM_bit_buf_create\fP (void) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "void \fBM_bit_buf_destroy\fP (\fBM_bit_buf_t\fP *bbuf) M_FREE(1)"
.br
.ti -1c
.RI "M_uint8 * \fBM_bit_buf_finish\fP (\fBM_bit_buf_t\fP *bbuf, size_t *nbytes) M_FREE(1) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "\fBM_buf_t\fP * \fBM_bit_buf_finish_buf\fP (\fBM_bit_buf_t\fP *bbuf) M_FREE(1) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "size_t \fBM_bit_buf_len\fP (\fBM_bit_buf_t\fP *bbuf)"
.br
.ti -1c
.RI "size_t \fBM_bit_buf_len_bytes\fP (\fBM_bit_buf_t\fP *bbuf)"
.br
.ti -1c
.RI "const M_uint8 * \fBM_bit_buf_peek\fP (\fBM_bit_buf_t\fP *bbuf)"
.br
.ti -1c
.RI "void \fBM_bit_buf_truncate\fP (\fBM_bit_buf_t\fP *bbuf, size_t len_bits)"
.br
.ti -1c
.RI "void \fBM_bit_buf_fill\fP (\fBM_bit_buf_t\fP *bbuf, M_uint8 bit, size_t len_bits)"
.br
.ti -1c
.RI "void \fBM_bit_buf_add_bit\fP (\fBM_bit_buf_t\fP *bbuf, M_uint8 bit)"
.br
.ti -1c
.RI "void \fBM_bit_buf_add_bytes\fP (\fBM_bit_buf_t\fP *bbuf, const void *bytes, size_t nbits)"
.br
.ti -1c
.RI "void \fBM_bit_buf_add\fP (\fBM_bit_buf_t\fP *bbuf, M_uint64 bits, size_t nbits, \fBM_bit_buf_pad_t\fP pad)"
.br
.ti -1c
.RI "M_bool \fBM_bit_buf_add_bitstr\fP (\fBM_bit_buf_t\fP *bbuf, const char *bitstr, \fBM_bit_buf_pad_t\fP pad)"
.br
.ti -1c
.RI "void \fBM_bit_buf_reserve\fP (\fBM_bit_buf_t\fP *bbuf, size_t nbits)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Allows for buffered writing of data that's organized per-bit, instead of per-byte\&.
.PP
When done adding data the contents of the buffer can be output as a continuous byte-array, either raw as an (M_uint8 *), or inside a regular per-byte M_buf_t\&.
.PP
Example (creating a buffer, adding data, finishing the buffer):
.PP
.PP
.nf
M_bit_buf_t *bbuf;
M_uint8     *out;
size_t       out_nbytes;

bbuf = M_bit_buf_create();
M_bbuf_add_bit(bbuf, 1);
M_bbuf_add(bbuf, 0xA2C4, 14);   // adds least-significant 14 bits of 0xA2C4
M_bbuf_add_str(bbuf, "100010000"); // adds 9 bits from binary-ASCII

out = M_bit_buf_finish(bbuf, &out_nbytes);

// out now points to a byte buffer containing 3 bytes\&. Now can output to disk, do further processing, etc\&.

M_free(out);
.fi
.PP
 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct M_bit_buf \fBM_bit_buf_t\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_bit_buf_pad_t\fP"
Enumeration for byte-alignment padding mode for \fBM_bit_buf_add()\fP\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_BIT_BUF_PAD_NONE \fP\fP
Don't add any padding\&. 
.TP
\fB\fIM_BIT_BUF_PAD_BEFORE \fP\fP
Pad with zero bits before new value, so that bit stream after add is byte-aligned 
.TP
\fB\fIM_BIT_BUF_PAD_AFTER \fP\fP
Pad with zero bits after new value, so that bit stream after add is byte-aligned 
.SH "Function Documentation"
.PP 
.SS "\fBM_bit_buf_t\fP* M_bit_buf_create (void)"
Create a new bit buffer\&.
.PP
\fBReturns:\fP
.RS 4
allocated buffer\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_bit_buf_destroy\fP 
.PP
\fBM_bit_buf_finish\fP 
.PP
\fBM_bit_buf_finish_buf\fP 
.RE
.PP

.SS "void M_bit_buf_destroy (\fBM_bit_buf_t\fP * bbuf)"
Free a bit buffer, discarding its data\&.
.PP
\fBParameters:\fP
.RS 4
\fIbbuf\fP bit buffer to destroy 
.RE
.PP

.SS "M_uint8* M_bit_buf_finish (\fBM_bit_buf_t\fP * bbuf, size_t * nbytes)"
Free a buffer, saving its data\&.
.PP
The caller is responsible for freeing the data\&.
.PP
\fBParameters:\fP
.RS 4
\fIbbuf\fP Bit buffer 
.br
\fInbytes\fP Data length (in bytes) 
.RE
.PP
\fBReturns:\fP
.RS 4
The buffered data\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_free\fP 
.RE
.PP

.SS "\fBM_buf_t\fP* M_bit_buf_finish_buf (\fBM_bit_buf_t\fP * bbuf)"
Free a buffer, saving its data in a per-byte buffer\&.
.PP
The caller is responsible for freeing the data\&.
.PP
\fBParameters:\fP
.RS 4
\fIbbuf\fP Bit buffer
.RE
.PP
\fBReturns:\fP
.RS 4
The buffered data\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_free\fP 
.RE
.PP

.SS "size_t M_bit_buf_len (\fBM_bit_buf_t\fP * bbuf)"
Return the length of the data held by a buffer, in bits\&.
.PP
\fBParameters:\fP
.RS 4
\fIbbuf\fP Bit buffer 
.RE
.PP
\fBReturns:\fP
.RS 4
Data length (in bits) 
.RE
.PP

.SS "size_t M_bit_buf_len_bytes (\fBM_bit_buf_t\fP * bbuf)"
Return the length of the data held by a buffer, in bytes\&.
.PP
Partial bytes will be rounded up (i\&.e\&., 9 bits stored == 2 bytes)\&.
.PP
\fBParameters:\fP
.RS 4
\fIbbuf\fP Bit buffer 
.RE
.PP
\fBReturns:\fP
.RS 4
Data length (in bytes) 
.RE
.PP

.SS "const M_uint8* M_bit_buf_peek (\fBM_bit_buf_t\fP * bbuf)"
Return pointer to internal buffer data\&.
.PP
The internal data is stored as an array of bytes\&. The first bit in the buffer is always guaranteed to be the highest bit in the first byte, second bit in the buffer is the next highest bit, and so on\&. The implementation guarantees this will always be the case, regardless of what operations you may have done on the bit buffer\&.
.PP
\fBWarning:\fP
.RS 4
The returned pointer may be invalidated when you add data to the buffer\&. For safety, it should be used immediately after you call \fBM_bit_buf_peek()\fP, and then discarded\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIbbuf\fP Bit buffer 
.RE
.PP
\fBReturns:\fP
.RS 4
pointer to current internal buffer data 
.RE
.PP

.SS "void M_bit_buf_truncate (\fBM_bit_buf_t\fP * bbuf, size_t len_bits)"
Truncate the length of the data to the specified size (in bits)\&.
.PP
Removes data from the end of the buffer\&.
.PP
\fBParameters:\fP
.RS 4
\fIbbuf\fP Bit buffer 
.br
\fIlen_bits\fP Length (in bits) to truncate buffer to 
.RE
.PP

.SS "void M_bit_buf_fill (\fBM_bit_buf_t\fP * bbuf, M_uint8 bit, size_t len_bits)"
Add a number of repetitions of the same bit to the buffer\&.
.PP
\fBParameters:\fP
.RS 4
\fIbbuf\fP Bit buffer 
.br
\fIbit\fP 1 (to add a set bit) or 0 (to add an unset bit) 
.br
\fIlen_bits\fP Number of bits to add 
.RE
.PP

.SS "void M_bit_buf_add_bit (\fBM_bit_buf_t\fP * bbuf, M_uint8 bit)"
Add the given bit to the buffer\&.
.PP
\fBParameters:\fP
.RS 4
\fIbbuf\fP Bit buffer 
.br
\fIbit\fP 1 (to add a set bit) or 0 (to add an unset bit) 
.RE
.PP

.SS "void M_bit_buf_add_bytes (\fBM_bit_buf_t\fP * bbuf, const void * bytes, size_t nbits)"
Add bits from the given variable-length chunk of data\&.
.PP
\fBParameters:\fP
.RS 4
\fIbbuf\fP Bit buffer 
.br
\fIbytes\fP data to add 
.br
\fInbits\fP number of bits to add from the given data 
.RE
.PP

.SS "void M_bit_buf_add (\fBM_bit_buf_t\fP * bbuf, M_uint64 bits, size_t nbits, \fBM_bit_buf_pad_t\fP pad)"
Add bits from a given integer to the buffer\&.
.PP
Note that the bit region being read is assumed to be justified against the least-significant end of the integer, though the bits within that region are read from most-significant to least-significant\&.
.PP
For example, if bits == 0x8F == (10001011)b, and nbits == 4, the bits '1011' will be added to the buffer\&.
.PP
\fBParameters:\fP
.RS 4
\fIbbuf\fP Bit buffer 
.br
\fIbits\fP Value to draw bits from 
.br
\fInbits\fP Number of bits to use (counted from least-significant end, right-to-left) 
.br
\fIpad\fP Should any bits be added to force the result to end on a byte-boundary 
.RE
.PP

.SS "M_bool M_bit_buf_add_bitstr (\fBM_bit_buf_t\fP * bbuf, const char * bitstr, \fBM_bit_buf_pad_t\fP pad)"
Add bits from a given binary-ascii string to the buffer\&.
.PP
A binary-ascii string is a list of 1 and 0 characters (e\&.g\&., '100010')\&.
.PP
Any whitespace in the string will be silently ignored\&. So, ' 1000  1 0' will add the same data as '100010'\&.
.PP
\fBParameters:\fP
.RS 4
\fIbbuf\fP Bit buffer 
.br
\fIbitstr\fP String to draw bits from 
.br
\fIpad\fP Should any bits be added to force the result to end on a byte-boundary
.RE
.PP
\fBReturns:\fP
.RS 4
M_FALSE on error (given bitstr had characters other than '0', '1', or whitespace)\&. 
.RE
.PP

.SS "void M_bit_buf_reserve (\fBM_bit_buf_t\fP * bbuf, size_t nbits)"
Provide hint to buffer about how many bits we're going to add\&.
.PP
If you know ahead of time how many bits are going to get added to the buffer, you can use this function to grow the buffer all at once ahead of time, instead of on-demand as the buffer runs out of internal space\&.
.PP
This is provided purely as a performance hint\&.
.PP
\fBParameters:\fP
.RS 4
\fIbbuf\fP Bit buffer 
.br
\fInbits\fP Number of bits that we expect to add in the future 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
