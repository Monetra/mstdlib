.TH "m_io_layer" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_io_layer
.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBM_EVENT_HANDLE\fP   int"
.br
.ti -1c
.RI "#define \fBM_EVENT_INVALID_HANDLE\fP   \-1"
.br
.ti -1c
.RI "#define \fBM_EVENT_SOCKET\fP   int"
.br
.ti -1c
.RI "#define \fBM_EVENT_INVALID_SOCKET\fP   \-1"
.br
.ti -1c
.RI "#define \fBM_IO_LAYERS_MAX\fP   16"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct M_io_layer \fBM_io_layer_t\fP"
.br
.ti -1c
.RI "typedef struct M_io_handle \fBM_io_handle_t\fP"
.br
.ti -1c
.RI "typedef struct M_io_callbacks \fBM_io_callbacks_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_io_layer_t\fP * \fBM_io_layer_acquire\fP (\fBM_io_t\fP *io, size_t layer_id, const char *name)"
.br
.ti -1c
.RI "void \fBM_io_layer_release\fP (\fBM_io_layer_t\fP *layer)"
.br
.ti -1c
.RI "\fBM_io_t\fP * \fBM_io_init\fP (\fBM_io_type_t\fP type)"
.br
.ti -1c
.RI "\fBM_io_type_t\fP \fBM_io_get_type\fP (\fBM_io_t\fP *io)"
.br
.ti -1c
.RI "\fBM_event_t\fP * \fBM_io_get_event\fP (\fBM_io_t\fP *io)"
.br
.ti -1c
.RI "\fBM_io_callbacks_t\fP * \fBM_io_callbacks_create\fP (void)"
.br
.ti -1c
.RI "M_bool \fBM_io_callbacks_reg_init\fP (\fBM_io_callbacks_t\fP *callbacks, M_bool(*cb_init)(\fBM_io_layer_t\fP *layer))"
.br
.ti -1c
.RI "M_bool \fBM_io_callbacks_reg_accept\fP (\fBM_io_callbacks_t\fP *callbacks, \fBM_io_error_t\fP(*cb_accept)(\fBM_io_t\fP *new_conn, \fBM_io_layer_t\fP *orig_layer))"
.br
.ti -1c
.RI "M_bool \fBM_io_callbacks_reg_read\fP (\fBM_io_callbacks_t\fP *callbacks, \fBM_io_error_t\fP(*cb_read)(\fBM_io_layer_t\fP *layer, unsigned char *buf, size_t *read_len, \fBM_io_meta_t\fP *meta))"
.br
.ti -1c
.RI "M_bool \fBM_io_callbacks_reg_write\fP (\fBM_io_callbacks_t\fP *callbacks, \fBM_io_error_t\fP(*cb_write)(\fBM_io_layer_t\fP *layer, const unsigned char *buf, size_t *write_len, \fBM_io_meta_t\fP *meta))"
.br
.ti -1c
.RI "M_bool \fBM_io_callbacks_reg_processevent\fP (\fBM_io_callbacks_t\fP *callbacks, M_bool(*cb_process_event)(\fBM_io_layer_t\fP *layer, \fBM_event_type_t\fP *type))"
.br
.ti -1c
.RI "M_bool \fBM_io_callbacks_reg_unregister\fP (\fBM_io_callbacks_t\fP *callbacks, void(*cb_unregister)(\fBM_io_layer_t\fP *layer))"
.br
.ti -1c
.RI "M_bool \fBM_io_callbacks_reg_disconnect\fP (\fBM_io_callbacks_t\fP *callbacks, M_bool(*cb_disconnect)(\fBM_io_layer_t\fP *layer))"
.br
.ti -1c
.RI "M_bool \fBM_io_callbacks_reg_destroy\fP (\fBM_io_callbacks_t\fP *callbacks, void(*cb_destroy)(\fBM_io_layer_t\fP *layer))"
.br
.ti -1c
.RI "M_bool \fBM_io_callbacks_reg_state\fP (\fBM_io_callbacks_t\fP *callbacks, \fBM_io_state_t\fP(*cb_state)(\fBM_io_layer_t\fP *layer))"
.br
.ti -1c
.RI "M_bool \fBM_io_callbacks_reg_errormsg\fP (\fBM_io_callbacks_t\fP *callbacks, M_bool(*cb_errormsg)(\fBM_io_layer_t\fP *layer, char *error, size_t err_len))"
.br
.ti -1c
.RI "void \fBM_io_callbacks_destroy\fP (\fBM_io_callbacks_t\fP *callbacks)"
.br
.ti -1c
.RI "\fBM_io_layer_t\fP * \fBM_io_layer_add\fP (\fBM_io_t\fP *io, const char *layer_name, \fBM_io_handle_t\fP *handle, const \fBM_io_callbacks_t\fP *callbacks)"
.br
.ti -1c
.RI "\fBM_io_t\fP * \fBM_io_layer_get_io\fP (\fBM_io_layer_t\fP *layer)"
.br
.ti -1c
.RI "const char * \fBM_io_layer_get_name\fP (\fBM_io_layer_t\fP *layer)"
.br
.ti -1c
.RI "\fBM_io_handle_t\fP * \fBM_io_layer_get_handle\fP (\fBM_io_layer_t\fP *layer)"
.br
.ti -1c
.RI "size_t \fBM_io_layer_get_index\fP (\fBM_io_layer_t\fP *layer)"
.br
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_layer_read\fP (\fBM_io_t\fP *io, size_t layer_id, unsigned char *buf, size_t *read_len, \fBM_io_meta_t\fP *meta)"
.br
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_layer_write\fP (\fBM_io_t\fP *io, size_t layer_id, const unsigned char *buf, size_t *write_len, \fBM_io_meta_t\fP *meta)"
.br
.ti -1c
.RI "M_bool \fBM_io_error_is_critical\fP (\fBM_io_error_t\fP err)"
.br
.ti -1c
.RI "void \fBM_io_layer_softevent_add\fP (\fBM_io_layer_t\fP *layer, M_bool sibling_only, \fBM_event_type_t\fP type)"
.br
.ti -1c
.RI "void \fBM_io_layer_softevent_clear\fP (\fBM_io_layer_t\fP *layer)"
.br
.ti -1c
.RI "void \fBM_io_layer_softevent_del\fP (\fBM_io_layer_t\fP *layer, M_bool sibling_only, \fBM_event_type_t\fP type)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Included using the semi-public header of <\fBmstdlib/io/m_io_layer\&.h\fP>
.PP
This is a semi-public header meant for those writing their own io layers\&. Unlike the normal public-facing API, these may change at any time\&. 
.SH "Macro Definition Documentation"
.PP 
.SS "#define M_EVENT_HANDLE   int"

.SS "#define M_EVENT_INVALID_HANDLE   \-1"

.SS "#define M_EVENT_SOCKET   int"

.SS "#define M_EVENT_INVALID_SOCKET   \-1"

.SS "#define M_IO_LAYERS_MAX   16"
Maximum number of layers for an I/O object\&. One reserved for the user layer 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct M_io_layer \fBM_io_layer_t\fP"

.SS "typedef struct M_io_handle \fBM_io_handle_t\fP"

.SS "typedef struct M_io_callbacks \fBM_io_callbacks_t\fP"

.SH "Function Documentation"
.PP 
.SS "\fBM_io_layer_t\fP* M_io_layer_acquire (\fBM_io_t\fP * io, size_t layer_id, const char * name)"
Find the appropriate layer and grab the handle and lock it\&. 
.PP
\fBParameters:\fP
.RS 4
\fIio\fP Pointer to io object 
.br
\fIlayer_id\fP id of layer to lock, or M_IO_LAYER_FIND_FIRST_ID to search for layer\&. 
.br
\fIname\fP Name of layer to lock\&. This can be used as a sanity check to ensure the layer id really matches the layer type\&. Use NULL if name matching is not required\&. If M_IO_LAYER_FIND_FIRST_ID is used for the layer_id, this parameter cannot be NULL\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
locked io layer, or NULL on failure 
.RE
.PP

.SS "void M_io_layer_release (\fBM_io_layer_t\fP * layer)"
Release the lock on the layer 
.SS "\fBM_io_t\fP* M_io_init (\fBM_io_type_t\fP type)"
Initialize a new io object of given type 
.SS "\fBM_io_type_t\fP M_io_get_type (\fBM_io_t\fP * io)"
Get the type of the io object 
.SS "\fBM_event_t\fP* M_io_get_event (\fBM_io_t\fP * io)"
Get the registered event handle for the io object 
.SS "\fBM_io_callbacks_t\fP* M_io_callbacks_create (void)"
Create M_io_callbacks_t object that can be passed to M_io_layer_add 
.SS "M_bool M_io_callbacks_reg_init (\fBM_io_callbacks_t\fP * callbacks, M_bool(*)(\fBM_io_layer_t\fP *layer) cb_init)"
Register callback to initialize/begin\&. Is called when the io object is attached to an event\&. Mandatory\&. 
.SS "M_bool M_io_callbacks_reg_accept (\fBM_io_callbacks_t\fP * callbacks, \fBM_io_error_t\fP(*)(\fBM_io_t\fP *new_conn, \fBM_io_layer_t\fP *orig_layer) cb_accept)"
Register callback to accept a new connection\&. Conditional\&. 
.SS "M_bool M_io_callbacks_reg_read (\fBM_io_callbacks_t\fP * callbacks, \fBM_io_error_t\fP(*)(\fBM_io_layer_t\fP *layer, unsigned char *buf, size_t *read_len, \fBM_io_meta_t\fP *meta) cb_read)"
Register callback to read from the connection\&. Optional if not base layer, required if base layer 
.SS "M_bool M_io_callbacks_reg_write (\fBM_io_callbacks_t\fP * callbacks, \fBM_io_error_t\fP(*)(\fBM_io_layer_t\fP *layer, const unsigned char *buf, size_t *write_len, \fBM_io_meta_t\fP *meta) cb_write)"
Register callback to write to the connection\&. Optional if not base layer, required if base layer 
.SS "M_bool M_io_callbacks_reg_processevent (\fBM_io_callbacks_t\fP * callbacks, M_bool(*)(\fBM_io_layer_t\fP *layer, \fBM_event_type_t\fP *type) cb_process_event)"
Register callback to process events\&. Optional\&. 
.SS "M_bool M_io_callbacks_reg_unregister (\fBM_io_callbacks_t\fP * callbacks, void(*)(\fBM_io_layer_t\fP *layer) cb_unregister)"
Register callback that is called when io object is removed from event object\&. Mandatory 
.SS "M_bool M_io_callbacks_reg_disconnect (\fBM_io_callbacks_t\fP * callbacks, M_bool(*)(\fBM_io_layer_t\fP *layer) cb_disconnect)"
Register callback to start a graceful disconnect sequence\&. Optional\&. 
.SS "M_bool M_io_callbacks_reg_destroy (\fBM_io_callbacks_t\fP * callbacks, void(*)(\fBM_io_layer_t\fP *layer) cb_destroy)"
Register callback to destroy any state (M_io_handle_t *)\&. Mandatory\&. 
.SS "M_bool M_io_callbacks_reg_state (\fBM_io_callbacks_t\fP * callbacks, \fBM_io_state_t\fP(*)(\fBM_io_layer_t\fP *layer) cb_state)"
Register callback to get the layer state\&. Optional if not base layer, required if base layer\&. 
.SS "M_bool M_io_callbacks_reg_errormsg (\fBM_io_callbacks_t\fP * callbacks, M_bool(*)(\fBM_io_layer_t\fP *layer, char *error, size_t err_len) cb_errormsg)"
Register callback to get the error message, will be called if cb_state returns M_IO_STATE_ERROR\&. If registered, cb_state must also be registered 
.SS "void M_io_callbacks_destroy (\fBM_io_callbacks_t\fP * callbacks)"
Destroy M_io_callbacks_t object 
.SS "\fBM_io_layer_t\fP* M_io_layer_add (\fBM_io_t\fP * io, const char * layer_name, \fBM_io_handle_t\fP * handle, const \fBM_io_callbacks_t\fP * callbacks)"
Add a layer to an io object 
.SS "\fBM_io_t\fP* M_io_layer_get_io (\fBM_io_layer_t\fP * layer)"
Given a layer object, retrieve the M_io_t reference 
.SS "const char* M_io_layer_get_name (\fBM_io_layer_t\fP * layer)"
Given a layer object, retrieve the name of the layer 
.SS "\fBM_io_handle_t\fP* M_io_layer_get_handle (\fBM_io_layer_t\fP * layer)"
Given a layer object, retrieve the implementation-specific handle 
.SS "size_t M_io_layer_get_index (\fBM_io_layer_t\fP * layer)"
Given a layer object, retrieve the index of the layer in the parent M_io_t object 
.SS "\fBM_io_error_t\fP M_io_layer_read (\fBM_io_t\fP * io, size_t layer_id, unsigned char * buf, size_t * read_len, \fBM_io_meta_t\fP * meta)"
Perform a read operation at the given layer index 
.SS "\fBM_io_error_t\fP M_io_layer_write (\fBM_io_t\fP * io, size_t layer_id, const unsigned char * buf, size_t * write_len, \fBM_io_meta_t\fP * meta)"
Perform a write operation at the given layer index 
.SS "M_bool M_io_error_is_critical (\fBM_io_error_t\fP err)"

.SS "void M_io_layer_softevent_add (\fBM_io_layer_t\fP * layer, M_bool sibling_only, \fBM_event_type_t\fP type)"
Add a soft-event\&. If sibling_only is true, will only notify next layer and not self\&. 
.SS "void M_io_layer_softevent_clear (\fBM_io_layer_t\fP * layer)"
Clear all soft events for the current layer 
.SS "void M_io_layer_softevent_del (\fBM_io_layer_t\fP * layer, M_bool sibling_only, \fBM_event_type_t\fP type)"
Add a soft-event\&. If sibling_only is true, will only delete the soft event for the next layer up and not self\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
