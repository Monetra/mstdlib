.TH "m_io_net" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_io_net
.SH SYNOPSIS
.br
.PP
.SS "Modules"

.in +1c
.ti -1c
.RI "\fBDNS Functions\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef enum \fBM_io_net_type\fP \fBM_io_net_type_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_io_net_type\fP { \fBM_IO_NET_ANY\fP = 1, \fBM_IO_NET_IPV4\fP = 2, \fBM_IO_NET_IPV6\fP = 3 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_net_server_create\fP (\fBM_io_t\fP **io_out, unsigned short port, const char *bind_ip, \fBM_io_net_type_t\fP type)"
.br
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_net_client_create\fP (\fBM_io_t\fP **io_out, \fBM_dns_t\fP *dns, const char *host, unsigned short port, \fBM_io_net_type_t\fP type)"
.br
.ti -1c
.RI "M_bool \fBM_io_net_set_keepalives\fP (\fBM_io_t\fP *io, M_uint64 idle_time_s, M_uint64 retry_time_s, M_uint64 retry_cnt)"
.br
.ti -1c
.RI "M_bool \fBM_io_net_set_nagle\fP (\fBM_io_t\fP *io, M_bool nagle_enabled)"
.br
.ti -1c
.RI "M_bool \fBM_io_net_set_connect_timeout_ms\fP (\fBM_io_t\fP *io, M_uint64 timeout_ms)"
.br
.ti -1c
.RI "char * \fBM_io_net_get_fqdn\fP (void)"
.br
.ti -1c
.RI "const char * \fBM_io_net_get_host\fP (\fBM_io_t\fP *io)"
.br
.ti -1c
.RI "const char * \fBM_io_net_get_ipaddr\fP (\fBM_io_t\fP *io)"
.br
.ti -1c
.RI "unsigned short \fBM_io_net_get_port\fP (\fBM_io_t\fP *io)"
.br
.ti -1c
.RI "unsigned short \fBM_io_net_get_ephemeral_port\fP (\fBM_io_t\fP *io)"
.br
.ti -1c
.RI "enum \fBM_io_net_type\fP \fBM_io_net_get_type\fP (\fBM_io_t\fP *io)"
.br
.ti -1c
.RI "M_uint64 \fBM_io_net_time_dns_ms\fP (\fBM_io_t\fP *io)"
.br
.ti -1c
.RI "M_uint64 \fBM_io_net_time_connect_ms\fP (\fBM_io_t\fP *io)"
.br
.ti -1c
.RI "M_bool \fBM_io_net_ipaddr_to_bin\fP (unsigned char *ipaddr_bin, size_t ipaddr_bin_size, const char *ipaddr_str, size_t *ipaddr_bin_len)"
.br
.ti -1c
.RI "M_bool \fBM_io_net_bin_to_ipaddr\fP (char *ipaddr_str, size_t ipaddr_str_size, const unsigned char *ipaddr_bin, size_t ipaddr_bin_len)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Network I/O functions
.PP
Capable of functioning as a network server and client\&.
.PP
.SH "Examples "
.PP
.PP
.SS "Client "
.PP
Example network client which downloads google\&.com's home page\&. This uses a network client connection wrapped in TLS\&. A trace layer is provided and is commented out\&.
.PP
.PP
.nf
#include <mstdlib/mstdlib\&.h>
#include <mstdlib/mstdlib_io\&.h>
#include <mstdlib/mstdlib_tls\&.h>

static void do_trace(void *cb_arg, M_io_trace_type_t type, M_event_type_t event_type, const unsigned char *data, size_t data_len)
{
    char *out;

    switch (type) {
        case M_IO_TRACE_TYPE_READ:
            M_printf("READ:\n");
            break;
        case M_IO_TRACE_TYPE_WRITE:
            M_printf("WRITE:\n");
            break;
        default:
            return;
    }
    out = M_str_hexdump(M_STR_HEXDUMP_HEADER, 0, "\t", data, data_len);
    M_printf("%s\n", out);
    M_free(out);
}

static void run_cb(M_event_t *el, M_event_type_t etype, M_io_t *io, void *thunk)
{
    M_buf_t *connected_buf = thunk;
    char     buf[128]      = { 0 };
    size_t   len_written   = 0;

    switch (etype) {
        case M_EVENT_TYPE_CONNECTED:
            M_printf("CONNECTED: %s%s%s:%d (%s: %s - session%sreused)\n",
                    M_io_net_get_type(io)==M_IO_NET_IPV6?"[":"",
                    M_io_net_get_ipaddr(io),
                    M_io_net_get_type(io)==M_IO_NET_IPV6?"]":"",
                    M_io_net_get_port(io),
                    M_tls_protocols_to_str(M_tls_get_protocol(io, M_IO_LAYER_FIND_FIRST_ID)),
                    M_tls_get_cipher(io, M_IO_LAYER_FIND_FIRST_ID),
                    M_tls_get_sessionreused(io, M_IO_LAYER_FIND_FIRST_ID)?"":" not ");

            M_io_write_from_buf(io, connected_buf);
            break;
        case M_EVENT_TYPE_READ:
            M_io_read(io, (unsigned char *)buf, sizeof(buf), &len_written);
            if (len_written > 0) {
                M_printf("%\&.*s", (int)len_written, buf);
            }
            break;
        case M_EVENT_TYPE_WRITE:
            M_io_write_from_buf(io, connected_buf);
            break;
        case M_EVENT_TYPE_DISCONNECTED:
        case M_EVENT_TYPE_ERROR:
            M_event_done_with_disconnect(el, 1000);
            break;
        case M_EVENT_TYPE_ACCEPT:
        case M_EVENT_TYPE_OTHER:
            M_event_done(el);
            break;
    }
}

int main(int argc, char *argv)
{
    M_event_t *el;
    M_dns_t   *dns;
    M_buf_t   *buf;
    M_io_t    *io;
    M_tls_clientctx_t *ctx;
    size_t     layer_id;


    dns = M_dns_create();
    el  = M_event_create(M_EVENT_FLAG_NONE);
    buf = M_buf_create();
    M_buf_add_str(buf, "GET / HTTP/1\&.1\r\n");
    M_buf_add_str(buf, "Host: www\&.google\&.com\r\n");
    M_buf_add_str(buf, "Connection: close\r\n");
    M_buf_add_str(buf, "\r\n");

    M_io_net_client_create(&io, dns, "google\&.com", 443, M_IO_NET_ANY);
    ctx = M_tls_clientctx_create();
    M_tls_clientctx_set_default_trust(ctx);
    M_io_tls_client_add(io, ctx, NULL, &layer_id);
    M_tls_clientctx_destroy(ctx);
    //M_io_add_trace(io, &layer_id, do_trace, NULL, NULL, NULL);

    M_event_add(el, io, run_cb, buf);
    M_event_loop(el, M_TIMEOUT_INF);

    M_io_destroy(io);
    M_buf_cancel(buf);
    M_event_destroy(el);
    M_dns_destroy(dns);
    return 0;
}
.fi
.PP
.PP
.SS "Server "
.PP
Example network sever\&. This is an echo server which uses a state machine to determine what operation it should perform\&.
.PP
.PP
.nf
#include <mstdlib/mstdlib\&.h>
#include <mstdlib/mstdlib_io\&.h>

typedef enum {
    STATE_CHECK = 1,
    STATE_ECHO,
    STATE_EXIT
} states_t;

typedef struct {
    M_buf_t           *write_buf;
    M_parser_t        *read_parser;
    M_io_t            *io;
    M_event_t         *el;
    M_state_machine_t *sm;
} ldata_t;

static M_state_machine_status_t state_check(void *data, M_uint64 *next)
{
    ldata_t *ldata = data;

    (void)next;

    M_parser_mark(ldata->read_parser);
    if (M_parser_len(ldata->read_parser) == 0 || M_parser_consume_until(ldata->read_parser, (const unsigned char *)"\n", 1, M_TRUE) == 0) {
        M_parser_mark_rewind(ldata->read_parser);
        return M_STATE_MACHINE_STATUS_WAIT;
    }

    return M_STATE_MACHINE_STATUS_NEXT;
}

static M_state_machine_status_t state_echo(void *data, M_uint64 *next)
{
    ldata_t *ldata = data;
    char    *out;

    out = M_parser_read_strdup_mark(ldata->read_parser);
    M_buf_add_str(ldata->write_buf, out);
    M_io_write_from_buf(ldata->io, ldata->write_buf);

    if (!M_str_eq(out, "EXIT\r\n") && !M_str_eq(out, "EXIT\n"))
        *next = STATE_CHECK;

    M_free(out);
    return M_STATE_MACHINE_STATUS_NEXT;
}

static M_state_machine_status_t state_exit(void *data, M_uint64 *next)
{
    ldata_t *ldata = data;
    (void)next;
    M_event_done_with_disconnect(ldata->el, 1000);
}

static void connection_cb(M_event_t *el, M_event_type_t etype, M_io_t *io, void *thunk)
{
    ldata_t                  *ldata      = thunk;
    char                      error[256] = { 0 };
    M_bool                    clean      = M_FALSE;
    M_state_machine_status_t  status;

    switch (etype) {
        case M_EVENT_TYPE_CONNECTED:
            M_printf("CLIENT CONNECTED: %s%s%s:%d\n",
                    M_io_net_get_type(io)==M_IO_NET_IPV6?"[":"",
                    M_io_net_get_ipaddr(io),
                    M_io_net_get_type(io)==M_IO_NET_IPV6?"]":"",
                    M_io_net_get_port(io));
            break;
        case M_EVENT_TYPE_READ:
            if (M_io_read_into_parser(io, ldata->read_parser) == M_IO_ERROR_SUCCESS) {
                status = M_state_machine_run(ldata->sm, ldata);
                if (status != M_STATE_MACHINE_STATUS_WAIT) {
                    M_io_disconnect(io);
                }
            }
            break;
        case M_EVENT_TYPE_WRITE:
            if (M_buf_len(ldata->write_buf) > 0) {
                M_io_write_from_buf(io, ldata->write_buf);
            }
            break;
        case M_EVENT_TYPE_DISCONNECTED:
            clean = M_TRUE;
        case M_EVENT_TYPE_ACCEPT:
        case M_EVENT_TYPE_ERROR:
        case M_EVENT_TYPE_OTHER:
            if (!clean) {
                M_io_get_error_string(io, error, sizeof(error));
            }
            M_printf("CLIENT DISCONNECTED: %s%s%s:%d (%s%s%s)\n",
                    M_io_net_get_type(io)==M_IO_NET_IPV6?"[":"",
                    M_io_net_get_ipaddr(io),
                    M_io_net_get_type(io)==M_IO_NET_IPV6?"]":"",
                    M_io_net_get_port(io),
                    clean?"clean":"unclean", clean?"":" - ", clean?"":error);

            M_io_destroy(io);
            M_state_machine_destroy(ldata->sm);
            M_buf_cancel(ldata->write_buf);
            M_parser_destroy(ldata->read_parser);
            M_free(ldata);
            break;
    }
}

static void listen_cb(M_event_t *el, M_event_type_t etype, M_io_t *io, void *thunk)
{
    M_io_t       *io_out     = NULL;
    ldata_t      *ldata;
    M_io_error_t  ioerr;
    char          error[256] = { 0 };

    (void)thunk;

    switch (etype) {
        case M_EVENT_TYPE_ACCEPT:
            ioerr = M_io_accept(&io_out, io);
            if (ioerr == M_IO_ERROR_WOULDBLOCK) {
                return;
            } else if (ioerr != M_IO_ERROR_SUCCESS || io_out == NULL) {
                M_io_get_error_string(io, error, sizeof(error));
                M_printf("ACCEPT FAILURE: %s\n", error);
                M_io_destroy(io_out);
            }

            ldata = M_malloc_zero(sizeof(*ldata));
            ldata->el          = el;
            ldata->write_buf   = M_buf_create();
            ldata->read_parser = M_parser_create(M_PARSER_FLAG_NONE);
            ldata->io          = io_out;
            ldata->sm          = M_state_machine_create(0, NULL, M_STATE_MACHINE_NONE);
            M_state_machine_insert_state(ldata->sm, STATE_CHECK, 0, NULL, state_check, NULL, NULL);
            M_state_machine_insert_state(ldata->sm, STATE_ECHO, 0, NULL, state_echo, NULL, NULL);
            M_state_machine_insert_state(ldata->sm, STATE_EXIT, 0, NULL, state_exit, NULL, NULL);

            M_event_add(el, io_out, connection_cb, ldata);
            break;
        case M_EVENT_TYPE_CONNECTED:
        case M_EVENT_TYPE_READ:
        case M_EVENT_TYPE_WRITE:
            break;
        case M_EVENT_TYPE_DISCONNECTED:
        case M_EVENT_TYPE_ERROR:
        case M_EVENT_TYPE_OTHER:
            M_io_destroy(io);
            break;
    }
}

int main(int argc, char *argv)
{
    M_event_t    *el;
    M_io_t       *io = NULL;
    M_io_error_t  ioerr;


    ioerr = M_io_net_server_create(&io, 8999, NULL, M_IO_NET_IPV4);
    if (ioerr != M_IO_ERROR_SUCCESS) {
        M_printf("Could not start server: %s\n", M_io_error_string(ioerr));
        return 0;
    }

    el = M_event_create(M_EVENT_FLAG_NONE);

    M_event_add(el, io, listen_cb, NULL);
    M_event_loop(el, M_TIMEOUT_INF);

    M_event_destroy(el);
    return 0;
}
.fi
.PP
 
.SH "Typedef Documentation"
.PP 
.SS "typedef enum \fBM_io_net_type\fP \fBM_io_net_type_t\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_io_net_type\fP"
IP connection type\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_IO_NET_ANY \fP\fP
Either ipv4 or ipv6 
.TP
\fB\fIM_IO_NET_IPV4 \fP\fP
ipv4 only 
.TP
\fB\fIM_IO_NET_IPV6 \fP\fP
ipv6 only 
.SH "Function Documentation"
.PP 
.SS "\fBM_io_error_t\fP M_io_net_server_create (\fBM_io_t\fP ** io_out, unsigned short port, const char * bind_ip, \fBM_io_net_type_t\fP type)"
Create a server listener net object\&.
.PP
\fBParameters:\fP
.RS 4
\fIio_out\fP io object for communication\&. 
.br
\fIport\fP Port to listen on\&. 
.br
\fIbind_ip\fP NULL to listen on all interfaces, or an explicit ip address to listen on\&. Note that listening on localhost ::1 will be ipv6 only, or localhost 127\&.0\&.0\&.1 will be ipv4 only\&. 
.br
\fItype\fP Connection type\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SS "\fBM_io_error_t\fP M_io_net_client_create (\fBM_io_t\fP ** io_out, \fBM_dns_t\fP * dns, const char * host, unsigned short port, \fBM_io_net_type_t\fP type)"
Create a client net object\&.
.PP
\fBParameters:\fP
.RS 4
\fIio_out\fP io object for communication\&. 
.br
\fIdns\fP DNS object for host name lookup\&. Required\&. It will be reference counted allowing it to be destroyed while still in use by the io object\&. 
.br
\fIhost\fP Host to connect to\&. Can be a host name or ip address\&. 
.br
\fIport\fP Port to connect to\&. 
.br
\fItype\fP Connection type\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SS "M_bool M_io_net_set_keepalives (\fBM_io_t\fP * io, M_uint64 idle_time_s, M_uint64 retry_time_s, M_uint64 retry_cnt)"
Set keep alive\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIidle_time_s\fP Idle time in seconds\&. 
.br
\fIretry_time_s\fP Retry time in seconds\&. 
.br
\fIretry_cnt\fP Retry count\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on failure\&. 
.RE
.PP

.SS "M_bool M_io_net_set_nagle (\fBM_io_t\fP * io, M_bool nagle_enabled)"
Enable/disable Nagle algorithm\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fInagle_enabled\fP M_TRUE to enable, M_FALSE to disable\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. Will return M_TRUE if state being set is the same as already set\&. Meaning, enabling on an io that already has it enabled will return success\&. 
.RE
.PP

.SS "M_bool M_io_net_set_connect_timeout_ms (\fBM_io_t\fP * io, M_uint64 timeout_ms)"
Set connect timeout\&.
.PP
This is the timeout to wait for a connection to finish\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fItimeout_ms\fP Timeout in milliseconds\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "char* M_io_net_get_fqdn (void)"
Get the Fully Qualified Domain Name\&.
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "const char* M_io_net_get_host (\fBM_io_t\fP * io)"
Get the hostname of the connected endpoint\&.
.PP
This may return an IP address for inbound connections, or for outbound connections where an ip address was passed\&. This will not do a reverse hostname lookup\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "const char* M_io_net_get_ipaddr (\fBM_io_t\fP * io)"
Get the IP address of the connected endpoint\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "unsigned short M_io_net_get_port (\fBM_io_t\fP * io)"
Get the port of the connected endpoint\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Port\&. 
.RE
.PP

.SS "unsigned short M_io_net_get_ephemeral_port (\fBM_io_t\fP * io)"
Get the ephemeral (dynamic) port of the connected endpoint
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Port\&. 
.RE
.PP

.SS "enum \fBM_io_net_type\fP M_io_net_get_type (\fBM_io_t\fP * io)"
Get connection type
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Type\&. 
.RE
.PP

.SS "M_uint64 M_io_net_time_dns_ms (\fBM_io_t\fP * io)"
Amount of time DNS query took
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Time in milliseconds\&. 
.RE
.PP

.SS "M_uint64 M_io_net_time_connect_ms (\fBM_io_t\fP * io)"
Amount of time connection establishment took, not including DNS resolution time
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Time in milliseconds\&. 
.RE
.PP

.SS "M_bool M_io_net_ipaddr_to_bin (unsigned char * ipaddr_bin, size_t ipaddr_bin_size, const char * ipaddr_str, size_t * ipaddr_bin_len)"
Convert an ip address in string form into its binary network byte order representation\&.
.PP
\fBParameters:\fP
.RS 4
\fIipaddr_bin\fP User-supplied buffer of at least 16 bytes to store result\&. 
.br
\fIipaddr_bin_size\fP Size of user-supplied buffer\&. 
.br
\fIipaddr_str\fP IPv4 or IPv6 address in string form\&. 
.br
\fIipaddr_bin_len\fP Pointer to hold length of ip address in binary form\&. Result will be 4 or 16 depending on the address type\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if conversion was possible, M_FALSE otherwise 
.RE
.PP

.SS "M_bool M_io_net_bin_to_ipaddr (char * ipaddr_str, size_t ipaddr_str_size, const unsigned char * ipaddr_bin, size_t ipaddr_bin_len)"
Convert an ip address in its binary network byte order representation to string form\&.
.PP
\fBParameters:\fP
.RS 4
\fIipaddr_str\fP User-supplied buffer of at least 40 bytes to store IPv6 address, or 16 bytes to store IPv4 address\&. 
.br
\fIipaddr_str_size\fP Size of user-supplied buffer\&. 
.br
\fIipaddr_bin\fP IPv4 or IPv6 address in binary form\&. 
.br
\fIipaddr_bin_len\fP Length of ip address in binary form (must be 4 or 16)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if conversion was possible, M_FALSE otherwise 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
