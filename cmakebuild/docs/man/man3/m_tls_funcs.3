.TH "m_tls_funcs" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_tls_funcs
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct M_tls_clientctx \fBM_tls_clientctx_t\fP"
.br
.ti -1c
.RI "typedef struct M_tls_serverctx \fBM_tls_serverctx_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_tls_protocols_t\fP { \fBM_TLS_PROTOCOL_DEFAULT\fP = 0, \fBM_TLS_PROTOCOL_TLSv1_0\fP = 1 << 0, \fBM_TLS_PROTOCOL_TLSv1_1\fP = 1 << 1, \fBM_TLS_PROTOCOL_TLSv1_2\fP = 1 << 2 }"
.br
.ti -1c
.RI "enum \fBM_tls_verify_level_t\fP { \fBM_TLS_VERIFY_NONE\fP = 0, \fBM_TLS_VERIFY_CERT_ONLY\fP = 1, \fBM_TLS_VERIFY_CERT_FUZZY\fP = 2, \fBM_TLS_VERIFY_FULL\fP = 3 }"
.br
.ti -1c
.RI "enum \fBM_tls_init_t\fP { \fBM_TLS_INIT_NORMAL\fP = 1, \fBM_TLS_INIT_EXTERNAL\fP = 2 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBM_tls_init\fP (\fBM_tls_init_t\fP type)"
.br
.ti -1c
.RI "\fBM_tls_clientctx_t\fP * \fBM_tls_clientctx_create\fP (void)"
.br
.ti -1c
.RI "M_bool \fBM_tls_clientctx_upref\fP (\fBM_tls_clientctx_t\fP *ctx)"
.br
.ti -1c
.RI "void \fBM_tls_clientctx_destroy\fP (\fBM_tls_clientctx_t\fP *ctx)"
.br
.ti -1c
.RI "M_bool \fBM_tls_clientctx_set_protocols\fP (\fBM_tls_clientctx_t\fP *ctx, int protocols)"
.br
.ti -1c
.RI "M_bool \fBM_tls_clientctx_set_ciphers\fP (\fBM_tls_clientctx_t\fP *ctx, const char *ciphers)"
.br
.ti -1c
.RI "M_bool \fBM_tls_clientctx_set_cert\fP (\fBM_tls_clientctx_t\fP *ctx, const unsigned char *key, size_t key_len, const unsigned char *crt, size_t crt_len, const unsigned char *intermediate, size_t intermediate_len)"
.br
.ti -1c
.RI "M_bool \fBM_tls_clientctx_set_cert_files\fP (\fBM_tls_clientctx_t\fP *ctx, const char *keypath, const char *crtpath, const char *intermediatepath)"
.br
.ti -1c
.RI "M_bool \fBM_tls_clientctx_set_default_trust\fP (\fBM_tls_clientctx_t\fP *ctx)"
.br
.ti -1c
.RI "M_bool \fBM_tls_clientctx_set_trust_ca\fP (\fBM_tls_clientctx_t\fP *ctx, const unsigned char *ca, size_t len)"
.br
.ti -1c
.RI "M_bool \fBM_tls_clientctx_set_trust_ca_file\fP (\fBM_tls_clientctx_t\fP *ctx, const char *path)"
.br
.ti -1c
.RI "M_bool \fBM_tls_clientctx_set_trust_ca_dir\fP (\fBM_tls_clientctx_t\fP *ctx, const char *path)"
.br
.ti -1c
.RI "M_bool \fBM_tls_clientctx_set_trust_cert\fP (\fBM_tls_clientctx_t\fP *ctx, const unsigned char *crt, size_t len)"
.br
.ti -1c
.RI "M_bool \fBM_tls_clientctx_set_trust_cert_file\fP (\fBM_tls_clientctx_t\fP *ctx, const char *path)"
.br
.ti -1c
.RI "M_bool \fBM_tls_clientctx_set_verify_level\fP (\fBM_tls_clientctx_t\fP *ctx, \fBM_tls_verify_level_t\fP level)"
.br
.ti -1c
.RI "M_bool \fBM_tls_clientctx_set_session_resumption\fP (\fBM_tls_clientctx_t\fP *ctx, M_bool enable)"
.br
.ti -1c
.RI "char * \fBM_tls_clientctx_get_cipherlist\fP (\fBM_tls_clientctx_t\fP *ctx)"
.br
.ti -1c
.RI "M_bool \fBM_tls_clientctx_set_applications\fP (\fBM_tls_clientctx_t\fP *ctx, \fBM_list_str_t\fP *applications)"
.br
.ti -1c
.RI "M_bool \fBM_tls_clientctx_set_negotiation_timeout_ms\fP (\fBM_tls_clientctx_t\fP *ctx, M_uint64 timeout_ms)"
.br
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_tls_client_add\fP (\fBM_io_t\fP *io, \fBM_tls_clientctx_t\fP *ctx, const char *hostname, size_t *layer_id)"
.br
.ti -1c
.RI "\fBM_tls_serverctx_t\fP * \fBM_tls_serverctx_create\fP (const unsigned char *key, size_t key_len, const unsigned char *crt, size_t crt_len, const unsigned char *intermediate, size_t intermediate_len)"
.br
.ti -1c
.RI "\fBM_tls_serverctx_t\fP * \fBM_tls_serverctx_create_from_files\fP (const char *keypath, const char *crtpath, const char *intermediatepath)"
.br
.ti -1c
.RI "M_bool \fBM_tls_serverctx_upref\fP (\fBM_tls_serverctx_t\fP *ctx)"
.br
.ti -1c
.RI "void \fBM_tls_serverctx_destroy\fP (\fBM_tls_serverctx_t\fP *ctx)"
.br
.ti -1c
.RI "M_bool \fBM_tls_serverctx_SNI_ctx_add\fP (\fBM_tls_serverctx_t\fP *ctx, \fBM_tls_serverctx_t\fP *child)"
.br
.ti -1c
.RI "size_t \fBM_tls_serverctx_SNI_count\fP (\fBM_tls_serverctx_t\fP *ctx)"
.br
.ti -1c
.RI "\fBM_tls_serverctx_t\fP * \fBM_tls_serverctx_SNI_lookup\fP (\fBM_tls_serverctx_t\fP *ctx, const char *hostname)"
.br
.ti -1c
.RI "\fBM_tls_serverctx_t\fP * \fBM_tls_serverctx_SNI_at\fP (\fBM_tls_serverctx_t\fP *ctx, size_t idx)"
.br
.ti -1c
.RI "char * \fBM_tls_serverctx_get_cert\fP (\fBM_tls_serverctx_t\fP *ctx)"
.br
.ti -1c
.RI "M_bool \fBM_tls_serverctx_set_protocols\fP (\fBM_tls_serverctx_t\fP *ctx, int protocols)"
.br
.ti -1c
.RI "M_bool \fBM_tls_serverctx_set_ciphers\fP (\fBM_tls_serverctx_t\fP *ctx, const char *ciphers)"
.br
.ti -1c
.RI "M_bool \fBM_tls_serverctx_set_trust_ca\fP (\fBM_tls_serverctx_t\fP *ctx, const unsigned char *ca, size_t len)"
.br
.ti -1c
.RI "M_bool \fBM_tls_serverctx_set_trust_ca_file\fP (\fBM_tls_serverctx_t\fP *ctx, const char *path)"
.br
.ti -1c
.RI "M_bool \fBM_tls_serverctx_set_trust_ca_dir\fP (\fBM_tls_serverctx_t\fP *ctx, const char *path)"
.br
.ti -1c
.RI "M_bool \fBM_tls_serverctx_set_trust_cert\fP (\fBM_tls_serverctx_t\fP *ctx, const unsigned char *crt, size_t len)"
.br
.ti -1c
.RI "M_bool \fBM_tls_serverctx_set_trust_cert_file\fP (\fBM_tls_serverctx_t\fP *ctx, const char *path)"
.br
.ti -1c
.RI "M_bool \fBM_tls_serverctx_add_trust_crl\fP (\fBM_tls_serverctx_t\fP *ctx, const unsigned char *crl, size_t len)"
.br
.ti -1c
.RI "M_bool \fBM_tls_serverctx_add_trust_crl_file\fP (\fBM_tls_serverctx_t\fP *ctx, const char *path)"
.br
.ti -1c
.RI "M_bool \fBM_tls_serverctx_set_dhparam\fP (\fBM_tls_serverctx_t\fP *ctx, const unsigned char *dhparam, size_t dhparam_len)"
.br
.ti -1c
.RI "M_bool \fBM_tls_serverctx_set_dhparam_file\fP (\fBM_tls_serverctx_t\fP *ctx, const char *dhparam_path)"
.br
.ti -1c
.RI "M_bool \fBM_tls_serverctx_set_session_resumption\fP (\fBM_tls_serverctx_t\fP *ctx, M_bool enable)"
.br
.ti -1c
.RI "char * \fBM_tls_serverctx_get_cipherlist\fP (\fBM_tls_serverctx_t\fP *ctx)"
.br
.ti -1c
.RI "M_bool \fBM_tls_serverctx_set_applications\fP (\fBM_tls_serverctx_t\fP *ctx, \fBM_list_str_t\fP *applications)"
.br
.ti -1c
.RI "M_bool \fBM_tls_serverctx_set_negotiation_timeout_ms\fP (\fBM_tls_serverctx_t\fP *ctx, M_uint64 timeout_ms)"
.br
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_tls_server_add\fP (\fBM_io_t\fP *io, \fBM_tls_serverctx_t\fP *ctx, size_t *layer_id)"
.br
.ti -1c
.RI "const char * \fBM_tls_server_get_hostname\fP (\fBM_io_t\fP *io, size_t id)"
.br
.ti -1c
.RI "\fBM_tls_protocols_t\fP \fBM_tls_get_protocol\fP (\fBM_io_t\fP *io, size_t id)"
.br
.ti -1c
.RI "M_bool \fBM_tls_get_sessionreused\fP (\fBM_io_t\fP *io, size_t id)"
.br
.ti -1c
.RI "const char * \fBM_tls_get_cipher\fP (\fBM_io_t\fP *io, size_t id)"
.br
.ti -1c
.RI "char * \fBM_tls_get_application\fP (\fBM_io_t\fP *io, size_t id)"
.br
.ti -1c
.RI "char * \fBM_tls_get_peer_cert\fP (\fBM_io_t\fP *io, size_t id)"
.br
.ti -1c
.RI "M_uint64 \fBM_tls_get_negotiation_time_ms\fP (\fBM_io_t\fP *io, size_t id)"
.br
.ti -1c
.RI "const char * \fBM_tls_protocols_to_str\fP (\fBM_tls_protocols_t\fP protocol)"
.br
.in -1c
.SH "Detailed Description"
.PP 
TLS functions 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct M_tls_clientctx \fBM_tls_clientctx_t\fP"

.SS "typedef struct M_tls_serverctx \fBM_tls_serverctx_t\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_tls_protocols_t\fP"
Supported TLS protocols\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_TLS_PROTOCOL_DEFAULT \fP\fP
Default is TLSv1\&.0+ 
.TP
\fB\fIM_TLS_PROTOCOL_TLSv1_0 \fP\fP
.TP
\fB\fIM_TLS_PROTOCOL_TLSv1_1 \fP\fP
.TP
\fB\fIM_TLS_PROTOCOL_TLSv1_2 \fP\fP
.SS "enum \fBM_tls_verify_level_t\fP"
Certificate verification level\&.
.PP
Used by client connections to control how they decide to trust the certificate presented by the server\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_TLS_VERIFY_NONE \fP\fP
Do not verify the certificate or hostname\&. 
.TP
\fB\fIM_TLS_VERIFY_CERT_ONLY \fP\fP
Only verify the certificate\&. The domain name is not checked\&. 
.TP
\fB\fIM_TLS_VERIFY_CERT_FUZZY \fP\fP
Verify the certificate and that the base domain name matches\&. Use this for servers that don't properly have a wild card cert but still use a sub domain\&. 
.TP
\fB\fIM_TLS_VERIFY_FULL \fP\fP
Default\&. Verify the certificate and full domain name matches 
.SS "enum \fBM_tls_init_t\fP"
How the TLS stack was/is initialized\&.
.PP
The TLS system uses OpenSSL as its back ends\&. It has global initialization and can only be initialized once\&. Inform the TLS system if it has already been initialized\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_TLS_INIT_NORMAL \fP\fP
Fully initialize the TLS (OpenSSL stack) 
.TP
\fB\fIM_TLS_INIT_EXTERNAL \fP\fP
TLS initialization is handled externally (use with caution) 
.SH "Function Documentation"
.PP 
.SS "void M_tls_init (\fBM_tls_init_t\fP type)"
Initialize the TLS library\&.
.PP
If a TLS function is used without calling this function it will be auto initialized using the NORMAL type\&.
.PP
\fBParameters:\fP
.RS 4
\fItype\fP Type of initialization\&. 
.RE
.PP

.SS "\fBM_tls_clientctx_t\fP* M_tls_clientctx_create (void)"
Create a client TLS context\&.
.PP
\fBReturns:\fP
.RS 4
Client context\&. 
.RE
.PP

.SS "M_bool M_tls_clientctx_upref (\fBM_tls_clientctx_t\fP * ctx)"
Increment reference counters\&.
.PP
Intended for APIs that might take ownership\&. Can only be Dereferenced via \fBM_tls_clientctx_destroy()\fP
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Client context\&. 
.RE
.PP

.SS "void M_tls_clientctx_destroy (\fBM_tls_clientctx_t\fP * ctx)"
Destroy a client context\&.
.PP
Client CTXs use reference counters, and will delay destruction until after last consumer is destroyed\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Client context\&. 
.RE
.PP

.SS "M_bool M_tls_clientctx_set_protocols (\fBM_tls_clientctx_t\fP * ctx, int protocols)"
Set the TLS protocols that the context should use\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Client context\&. 
.br
\fIprotocols\fP M_tls_protocols_t bitmap of TLS protocols that should be supported\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "M_bool M_tls_clientctx_set_ciphers (\fBM_tls_clientctx_t\fP * ctx, const char * ciphers)"
Set the ciphers that the context should support\&.
.PP
A default list of secure ciphers is used if it is not explicitly changed by this function\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Client context\&. 
.br
\fIciphers\fP OpenSSL cipher string\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_tls_clientctx_get_cipherlist\fP 
.RE
.PP

.SS "M_bool M_tls_clientctx_set_cert (\fBM_tls_clientctx_t\fP * ctx, const unsigned char * key, size_t key_len, const unsigned char * crt, size_t crt_len, const unsigned char * intermediate, size_t intermediate_len)"

.SS "M_bool M_tls_clientctx_set_cert_files (\fBM_tls_clientctx_t\fP * ctx, const char * keypath, const char * crtpath, const char * intermediatepath)"

.SS "M_bool M_tls_clientctx_set_default_trust (\fBM_tls_clientctx_t\fP * ctx)"
Load the OS CA trust list for validating the certificate presented by the server\&.
.PP
This will not clear existing CAs that were already loaded\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Client context\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "M_bool M_tls_clientctx_set_trust_ca (\fBM_tls_clientctx_t\fP * ctx, const unsigned char * ca, size_t len)"
Load a CA certificate for validating the certificate presented by the server\&.
.PP
This will not clear existing CAs that were already loaded\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Client context\&. 
.br
\fIca\fP CA data\&. 
.br
\fIlen\fP CA length\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "M_bool M_tls_clientctx_set_trust_ca_file (\fBM_tls_clientctx_t\fP * ctx, const char * path)"
Load a CA certificate from a file for validating the certificate presented by the server\&.
.PP
This will not clear existing CAs that were already loaded\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Client context\&. 
.br
\fIpath\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "M_bool M_tls_clientctx_set_trust_ca_dir (\fBM_tls_clientctx_t\fP * ctx, const char * path)"
Load CA certificates found in a directory for validating the certificate presented by the server\&.
.PP
Files must be PEM encoded and use the '\&.pem' extension\&.
.PP
This will not clear existing CAs that were already loaded\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Client context\&. 
.br
\fIpath\fP Path to CA file\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_tls_clientctx_set_trust_ca\fP 
.RE
.PP

.SS "M_bool M_tls_clientctx_set_trust_cert (\fBM_tls_clientctx_t\fP * ctx, const unsigned char * crt, size_t len)"
Load a certificate for validation of the certificate presented by the server\&.
.PP
This is for loading intermediate certificate used as part of the trust chain\&.
.PP
This will not clear existing certificates that were already loaded\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Client context\&. 
.br
\fIcrt\fP Certificate\&. 
.br
\fIlen\fP Certificate length\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "M_bool M_tls_clientctx_set_trust_cert_file (\fBM_tls_clientctx_t\fP * ctx, const char * path)"
Load a certificate from a file for validation of the certificate presented by the server\&.
.PP
This is for loading intermediate certificate used as part of the trust chain\&.
.PP
This will not clear existing certificates that were already loaded\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Client context\&. 
.br
\fIpath\fP Path to certificate file\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_tls_clientctx_set_trust_cert\fP 
.RE
.PP

.SS "M_bool M_tls_clientctx_set_verify_level (\fBM_tls_clientctx_t\fP * ctx, \fBM_tls_verify_level_t\fP level)"

.SS "M_bool M_tls_clientctx_set_session_resumption (\fBM_tls_clientctx_t\fP * ctx, M_bool enable)"
Enable or disable session resumption\&.
.PP
Session resumption is enabled by default\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Client context\&. 
.br
\fIenable\fP M_TRUE to enable\&. M_FALSE to disable\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "char* M_tls_clientctx_get_cipherlist (\fBM_tls_clientctx_t\fP * ctx)"
Retrieves a colon separated list of ciphers that are enabled\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Client context\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "M_bool M_tls_clientctx_set_applications (\fBM_tls_clientctx_t\fP * ctx, \fBM_list_str_t\fP * applications)"
Set ALPN supported applications\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Client context\&. 
.br
\fIapplications\fP List of supported applications\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "M_bool M_tls_clientctx_set_negotiation_timeout_ms (\fBM_tls_clientctx_t\fP * ctx, M_uint64 timeout_ms)"
Set the negotiation timeout\&.
.PP
How long the client should wait to establish a connection\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Client context\&. 
.br
\fItimeout_ms\fP Time in milliseconds\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "\fBM_io_error_t\fP M_io_tls_client_add (\fBM_io_t\fP * io, \fBM_tls_clientctx_t\fP * ctx, const char * hostname, size_t * layer_id)"
Wrap existing IO channel with TLS\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIctx\fP Client context\&. 
.br
\fIhostname\fP Hostname is optional if wrapping an outbound network connection where it can be retrieved from the lower layer 
.br
\fIlayer_id\fP Layer id this is added at\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SS "\fBM_tls_serverctx_t\fP* M_tls_serverctx_create (const unsigned char * key, size_t key_len, const unsigned char * crt, size_t crt_len, const unsigned char * intermediate, size_t intermediate_len)"
Create a server TLS context\&.
.PP
\fBParameters:\fP
.RS 4
\fIkey\fP Private key associated with certificate\&. 
.br
\fIkey_len\fP Length of private key\&. 
.br
\fIcrt\fP Certificate\&. 
.br
\fIcrt_len\fP Length of certificate\&. 
.br
\fIintermediate\fP Intermediate certificate chain\&. 
.br
\fIintermediate_len\fP Length of intermediate certificate chain\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Server context\&. 
.RE
.PP

.SS "\fBM_tls_serverctx_t\fP* M_tls_serverctx_create_from_files (const char * keypath, const char * crtpath, const char * intermediatepath)"
Create a server TLS context from files\&.
.PP
\fBParameters:\fP
.RS 4
\fIkeypath\fP Path to key file\&. 
.br
\fIcrtpath\fP Path to certificate file\&. 
.br
\fIintermediatepath\fP Path to intermediate certificate file\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Server context\&. 
.RE
.PP

.SS "M_bool M_tls_serverctx_upref (\fBM_tls_serverctx_t\fP * ctx)"
Increment reference counters\&.
.PP
Intended for APIs that might take ownership\&. Can only be Dereferenced via \fBM_tls_serverctx_destroy()\fP
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "void M_tls_serverctx_destroy (\fBM_tls_serverctx_t\fP * ctx)"
Destroy a server context\&.
.PP
Server CTXs use reference counters, and will delay destruction until after last consumer is destroyed\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "M_bool M_tls_serverctx_SNI_ctx_add (\fBM_tls_serverctx_t\fP * ctx, \fBM_tls_serverctx_t\fP * child)"
Add a sub context under this one to allow multiple certificates to be used with SNI\&.
.PP
For SNI support, if a certificate does not list a subject alt name, a server context needs to be created for each certificate\&. The certificate to be used as the default when the client does not support SNI will be the parent context\&. All of the additional contexts are added to this one\&.
.PP
This is not necessary if a certificate lists all expected host names as subject alt names\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&. 
.br
\fIchild\fP Child server context\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "size_t M_tls_serverctx_SNI_count (\fBM_tls_serverctx_t\fP * ctx)"
Number of child contexts associated with this server context used for SNI\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Count\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_tls_serverctx_SNI_at\fP 
.RE
.PP

.SS "\fBM_tls_serverctx_t\fP* M_tls_serverctx_SNI_lookup (\fBM_tls_serverctx_t\fP * ctx, const char * hostname)"
Get a child SNI context from a context based on host name\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&. 
.br
\fIhostname\fP Host name to look for\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Server context on success, otherwise NULL if not found\&. 
.RE
.PP

.SS "\fBM_tls_serverctx_t\fP* M_tls_serverctx_SNI_at (\fBM_tls_serverctx_t\fP * ctx, size_t idx)"
Get a child SNI context from a context at a given index\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&. 
.br
\fIidx\fP Index\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Server context on success, otherwise NULL on error\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_tls_serverctx_SNI_count\fP 
.RE
.PP

.SS "char* M_tls_serverctx_get_cert (\fBM_tls_serverctx_t\fP * ctx)"

.SS "M_bool M_tls_serverctx_set_protocols (\fBM_tls_serverctx_t\fP * ctx, int protocols)"
Set the TLS protocols that the context should use\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&. 
.br
\fIprotocols\fP M_tls_protocols_t bitmap of TLS protocols that should be supported\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "M_bool M_tls_serverctx_set_ciphers (\fBM_tls_serverctx_t\fP * ctx, const char * ciphers)"
Set the ciphers that the context should support\&.
.PP
A default list of secure ciphers is used if it is not explicitly changed by this function\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&. 
.br
\fIciphers\fP OpenSSL cipher string\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_tls_clientctx_get_cipherlist\fP 
.RE
.PP

.SS "M_bool M_tls_serverctx_set_trust_ca (\fBM_tls_serverctx_t\fP * ctx, const unsigned char * ca, size_t len)"
Load a CA certificate for validating the certificate presented by the client\&.
.PP
If set the client will be required to present a certificate\&.
.PP
This will not clear existing CAs that were already loaded\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&. 
.br
\fIca\fP CA data\&. 
.br
\fIlen\fP CA length\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "M_bool M_tls_serverctx_set_trust_ca_file (\fBM_tls_serverctx_t\fP * ctx, const char * path)"
Load a CA certificate from a file for validating the certificate presented by the client\&.
.PP
This will not clear existing CAs that were already loaded\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&. 
.br
\fIpath\fP Path to CA file\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_tls_serverctx_set_trust_ca\fP 
.RE
.PP

.SS "M_bool M_tls_serverctx_set_trust_ca_dir (\fBM_tls_serverctx_t\fP * ctx, const char * path)"
Load a certificate for validation of the certificate presented by the client\&.
.PP
This is for loading intermediate certificate used as part of the trust chain\&.
.PP
This will not clear existing certificates that were already loaded\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&. 
.br
\fIpath\fP Path to CA directory\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_tls_serverctx_set_trust_ca\fP 
.RE
.PP

.SS "M_bool M_tls_serverctx_set_trust_cert (\fBM_tls_serverctx_t\fP * ctx, const unsigned char * crt, size_t len)"
Load a certificate for validation of the certificate presented by the client\&.
.PP
This is for loading intermediate certificate used as part of the trust chain\&.
.PP
This will not clear existing certificates that were already loaded\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&. 
.br
\fIcrt\fP Certificate\&. 
.br
\fIlen\fP Certificate length\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "M_bool M_tls_serverctx_set_trust_cert_file (\fBM_tls_serverctx_t\fP * ctx, const char * path)"
Load a certificate from a file for validation of the certificate presented by the client\&.
.PP
This is for loading intermediate certificate used as part of the trust chain\&.
.PP
This will not clear existing certificates that were already loaded\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&. 
.br
\fIpath\fP Path to certificate file\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_tls_serverctx_set_trust_cert\fP 
.RE
.PP

.SS "M_bool M_tls_serverctx_add_trust_crl (\fBM_tls_serverctx_t\fP * ctx, const unsigned char * crl, size_t len)"
Load a certificate revocation list to validate the certificate presented by the client\&.
.PP
This will not clear existing revocations already loaded\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&. 
.br
\fIcrl\fP CRL\&. 
.br
\fIlen\fP CRL Length\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "M_bool M_tls_serverctx_add_trust_crl_file (\fBM_tls_serverctx_t\fP * ctx, const char * path)"
Load a certificate revocation from a file list to validate the certificate presented by the client\&.
.PP
This will not clear existing revocations already loaded\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&. 
.br
\fIpath\fP Path to certificate revocation list file\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_tls_serverctx_set_trust_cert_file\fP 
.RE
.PP

.SS "M_bool M_tls_serverctx_set_dhparam (\fBM_tls_serverctx_t\fP * ctx, const unsigned char * dhparam, size_t dhparam_len)"
Set the dhparam for the context\&.
.PP
If not set, uses internal 2236 dhparam\&. DHparam data must be PEM-encoded\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&. 
.br
\fIdhparam\fP DHparam data\&. If dhparam is NULL, disables the use of DHE negotiation\&. 
.br
\fIdhparam_len\fP Length of data\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "M_bool M_tls_serverctx_set_dhparam_file (\fBM_tls_serverctx_t\fP * ctx, const char * dhparam_path)"
Set the dhparam for the context from a file\&.
.PP
If not set, uses internal 2236 dhparam\&. DHparam data must be PEM-encoded\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&. 
.br
\fIdhparam_path\fP Path to DHparam data\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_tls_serverctx_set_dhparam\fP 
.RE
.PP

.SS "M_bool M_tls_serverctx_set_session_resumption (\fBM_tls_serverctx_t\fP * ctx, M_bool enable)"
Enable or disable session resumption\&.
.PP
Session resumption is enabled by default\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&. 
.br
\fIenable\fP M_TRUE to enable\&. M_FALSE to disable\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "char* M_tls_serverctx_get_cipherlist (\fBM_tls_serverctx_t\fP * ctx)"
Retrieves a colon separated list of ciphers that are enabled\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "M_bool M_tls_serverctx_set_applications (\fBM_tls_serverctx_t\fP * ctx, \fBM_list_str_t\fP * applications)"
Set ALPN supported applications\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&. 
.br
\fIapplications\fP List of supported applications\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "M_bool M_tls_serverctx_set_negotiation_timeout_ms (\fBM_tls_serverctx_t\fP * ctx, M_uint64 timeout_ms)"
Set the negotiation timeout\&.
.PP
How long the server should wait to establish a connection\&.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP Server context\&. 
.br
\fItimeout_ms\fP Time in milliseconds\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE on error\&. 
.RE
.PP

.SS "\fBM_io_error_t\fP M_io_tls_server_add (\fBM_io_t\fP * io, \fBM_tls_serverctx_t\fP * ctx, size_t * layer_id)"
Wrap existing IO channel with TLS\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIctx\fP Server context\&. 
.br
\fIlayer_id\fP Layer id this is added at\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SS "const char* M_tls_server_get_hostname (\fBM_io_t\fP * io, size_t id)"
Get the host name the connected client requested\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIid\fP Layer id\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "\fBM_tls_protocols_t\fP M_tls_get_protocol (\fBM_io_t\fP * io, size_t id)"
Get the protocol the connection was establish with\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIid\fP Layer id\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Protocol\&. 
.RE
.PP

.SS "M_bool M_tls_get_sessionreused (\fBM_io_t\fP * io, size_t id)"
Was the session for this connection reused from a previous connection?
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIid\fP Layer id\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if reused, otherwise M_FALSE\&. 
.RE
.PP

.SS "const char* M_tls_get_cipher (\fBM_io_t\fP * io, size_t id)"
Get the cipher negotiated\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIid\fP Layer id\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "char* M_tls_get_application (\fBM_io_t\fP * io, size_t id)"
Get the application negotiated\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIid\fP Layer id\&.
.RE
.PP
\fBReturns:\fP
.RS 4
NULL if there is no ALPN support or on error, or will return the application\&. 
.RE
.PP

.SS "char* M_tls_get_peer_cert (\fBM_io_t\fP * io, size_t id)"
Get the certificate presented by the other end\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIid\fP Layer id\&.
.RE
.PP
\fBReturns:\fP
.RS 4
X509 PEM encoded certificate\&. 
.RE
.PP

.SS "M_uint64 M_tls_get_negotiation_time_ms (\fBM_io_t\fP * io, size_t id)"
How long negotiated took\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIid\fP Layer id\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Negotiation time (success or fail) in ms 
.RE
.PP

.SS "const char* M_tls_protocols_to_str (\fBM_tls_protocols_t\fP protocol)"
Convert a protocol to string\&.
.PP
If multiple protocols are present only one will be returned\&. It is undefined which will be used\&. Used primarily for logging to print what protocol a connection is using\&.
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
