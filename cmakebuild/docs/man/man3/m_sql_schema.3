.TH "m_sql_schema" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_sql_schema
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct M_sql_table \fBM_sql_table_t\fP"
.br
.ti -1c
.RI "typedef struct M_sql_index \fBM_sql_index_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_sql_table_col_flags_t\fP { \fBM_SQL_TABLE_COL_FLAG_NONE\fP = 0, \fBM_SQL_TABLE_COL_FLAG_NOTNULL\fP = 1 << 0 }"
.br
.ti -1c
.RI "enum \fBM_sql_table_index_flags_t\fP { \fBM_SQL_INDEX_FLAG_NONE\fP = 0, \fBM_SQL_INDEX_FLAG_UNIQUE\fP = 1 << 0 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "M_bool \fBM_sql_table_exists\fP (\fBM_sql_connpool_t\fP *pool, const char *name)"
.br
.ti -1c
.RI "\fBM_sql_table_t\fP * \fBM_sql_table_create\fP (const char *name)"
.br
.ti -1c
.RI "void \fBM_sql_table_destroy\fP (\fBM_sql_table_t\fP *table)"
.br
.ti -1c
.RI "M_bool \fBM_sql_table_add_col\fP (\fBM_sql_table_t\fP *table, M_uint32 flags, const char *col_name, \fBM_sql_data_type_t\fP datatype, size_t max_len, const char *default_value)"
.br
.ti -1c
.RI "M_bool \fBM_sql_table_add_pk_col\fP (\fBM_sql_table_t\fP *table, const char *col_name)"
.br
.ti -1c
.RI "\fBM_sql_index_t\fP * \fBM_sql_table_add_index\fP (\fBM_sql_table_t\fP *table, M_uint32 flags, const char *idx_name)"
.br
.ti -1c
.RI "M_bool \fBM_sql_index_add_col\fP (\fBM_sql_index_t\fP *idx, const char *col_name)"
.br
.ti -1c
.RI "M_bool \fBM_sql_table_add_index_str\fP (\fBM_sql_table_t\fP *table, M_uint32 flags, const char *idx_name, const char *idx_cols_csv)"
.br
.ti -1c
.RI "\fBM_sql_error_t\fP \fBM_sql_table_execute\fP (\fBM_sql_connpool_t\fP *pool, \fBM_sql_table_t\fP *table, char *error, size_t error_size)"
.br
.in -1c
.SH "Detailed Description"
.PP 
SQL Table/Schema Management 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct M_sql_table \fBM_sql_table_t\fP"
Type holding table definition 
.SS "typedef struct M_sql_index \fBM_sql_index_t\fP"
Type holding index definition 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_sql_table_col_flags_t\fP"
Flags passed to \fBM_sql_table_add_col()\fP for a column 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_SQL_TABLE_COL_FLAG_NONE \fP\fP
Default, no special flags 
.TP
\fB\fIM_SQL_TABLE_COL_FLAG_NOTNULL \fP\fP
Column is not allowed to be NULL 
.SS "enum \fBM_sql_table_index_flags_t\fP"
Index creation flags used by \fBM_sql_table_add_index()\fP 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_SQL_INDEX_FLAG_NONE \fP\fP
Default, no special flags 
.TP
\fB\fIM_SQL_INDEX_FLAG_UNIQUE \fP\fP
Index enforces a unique constraint 
.SH "Function Documentation"
.PP 
.SS "M_bool M_sql_table_exists (\fBM_sql_connpool_t\fP * pool, const char * name)"
Check to see if a table exists by name\&.
.PP
\fBParameters:\fP
.RS 4
\fIpool\fP Initialized \fBM_sql_connpool_t\fP object 
.br
\fIname\fP Table name to check for 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if table exists, M_FALSE otherwise 
.RE
.PP

.SS "\fBM_sql_table_t\fP* M_sql_table_create (const char * name)"
Create a table object which aids in creating a table definition, including indexes to be added to a database\&.
.PP
Table names must start with an alpha character or underscore, and can only contain alpha-numerics and underscores\&.
.PP
\fBWarning:\fP
.RS 4
Table names have a maximum length of 58 bytes, however if there are any indexes also created, then this maximum length cannot be used as the length of the table name and the length of the index name combined are limited to 58 bytes\&. Some older databases (like Oracle before 12c R2 [March 2017]) were limited to much smaller sizes (30), it is therefore recommended to keep table names as short as possible, as a rule of thumb, 15 or fewer characters should be safe\&.
.RE
.PP
\fBNote:\fP
.RS 4
All tables require primary keys (added via \fBM_sql_table_add_pk_col()\fP) and failure will occur if one tries to add a table without a primary key\&.
.RE
.PP
The table will not be created until \fBM_sql_table_execute()\fP is called\&.
.PP
\fBParameters:\fP
.RS 4
\fIname\fP Table name to create 
.RE
.PP
\fBReturns:\fP
.RS 4
Table object, or NULL on error\&. Use \fBM_sql_table_destroy()\fP to free the object\&. 
.RE
.PP

.SS "void M_sql_table_destroy (\fBM_sql_table_t\fP * table)"
Destroy a table object created with \fBM_sql_table_create()\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fItable\fP Table object initialized by \fBM_sql_table_create()\fP 
.RE
.PP

.SS "M_bool M_sql_table_add_col (\fBM_sql_table_t\fP * table, M_uint32 flags, const char * col_name, \fBM_sql_data_type_t\fP datatype, size_t max_len, const char * default_value)"
Add a column to a table\&.
.PP
Column names have a maximum length of 63 characters and must start with an alpha character or underscore, and can only contain alpha-numerics and underscores\&. However, some older databases might have shorter limits, such as versions of Oracle prior to 12c R2 (March 2017), were limited to 30 characters\&.
.PP
\fBParameters:\fP
.RS 4
\fItable\fP Table object initialized by \fBM_sql_table_create()\fP 
.br
\fIflags\fP Bitmap of \fBM_sql_table_col_flags_t\fP flags 
.br
\fIcol_name\fP Column name to create\&. 
.br
\fIdatatype\fP Datatype of column 
.br
\fImax_len\fP Maximum length of column (meant for text or binary columns)\&. Use 0 for the maximum size supported by the database for the data type\&. It is strongly recommended to specify a reasonable maximum size as it may have a significant impact on performance of some databases\&. Typically databases have maximum row sizes, and data over these limits will be stored separately (meaning the sum of all columns also matters)\&. 
.br
\fIdefault_value\fP Default value to assign to column\&. There is little to no validation performed on this value, use caution as it is inserted directly into the create statement\&. Strings must be quoted with single quotes\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, M_FALSE on error (most likely usage, bad name or type) 
.RE
.PP

.SS "M_bool M_sql_table_add_pk_col (\fBM_sql_table_t\fP * table, const char * col_name)"
Add a column in the table to the primary key\&.
.PP
The order in which the columns are added to the primary key is how the primary key will be indexed/created\&.
.PP
The column name specified must exist in the table object\&.
.PP
\fBParameters:\fP
.RS 4
\fItable\fP Table object initialized by \fBM_sql_table_create()\fP 
.br
\fIcol_name\fP Column name to add to the primary key 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, M_FALSE on error (such as misuse) 
.RE
.PP

.SS "\fBM_sql_index_t\fP* M_sql_table_add_index (\fBM_sql_table_t\fP * table, M_uint32 flags, const char * idx_name)"
Add an index to the table
.PP
\fBWarning:\fP
.RS 4
Index names have a maximum length of 58 bytes minus the table name length
.RE
.PP
\fBParameters:\fP
.RS 4
\fItable\fP Table object initialized by \fBM_sql_table_create()\fP 
.br
\fIflags\fP Bitmap of \fBM_sql_table_index_flags_t\fP flags 
.br
\fIidx_name\fP User-chosen index name\&. This should be as short as reasonably possible\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Index object on success, NULL on failure (misuse) 
.RE
.PP

.SS "M_bool M_sql_index_add_col (\fBM_sql_index_t\fP * idx, const char * col_name)"
Add a column to an index
.PP
The order in which the columns are added to the index is how the it will be indexed/created\&.
.PP
The referenced column name must exist in the table definition\&.
.PP
\fBParameters:\fP
.RS 4
\fIidx\fP Index object initialized by \fBM_sql_table_add_index()\fP 
.br
\fIcol_name\fP Column name to add to index 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, M_FALSE on failure/misuse\&. 
.RE
.PP

.SS "M_bool M_sql_table_add_index_str (\fBM_sql_table_t\fP * table, M_uint32 flags, const char * idx_name, const char * idx_cols_csv)"
Simplified method to add an index to a table using a comma-delimited string of column names\&.
.PP
Identical to \fBM_sql_table_add_index()\fP followed by \fBM_sql_index_add_col()\fP for each column in the comma-separated string\&.
.PP
\fBParameters:\fP
.RS 4
\fItable\fP Table object initialized by \fBM_sql_table_create()\fP 
.br
\fIflags\fP Bitmap of \fBM_sql_table_index_flags_t\fP flags 
.br
\fIidx_name\fP User-chosen index name\&. This should be as short as reasonably possible\&. 
.br
\fIidx_cols_csv\fP Comma separated list of column names to add to the index\&. The columns must already exist in the table object\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, M_FALSE on error/misuse 
.RE
.PP

.SS "\fBM_sql_error_t\fP M_sql_table_execute (\fBM_sql_connpool_t\fP * pool, \fBM_sql_table_t\fP * table, char * error, size_t error_size)"
Apply the table object definition to the database\&.
.PP
\fBNote:\fP
.RS 4
This does not destroy the table object\&. Use \fBM_sql_table_destroy()\fP for that\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIpool\fP Initialized \fBM_sql_connpool_t\fP object 
.br
\fItable\fP Table object initialized by \fBM_sql_table_create()\fP and populated with columns/indexes and primary keys\&. 
.br
\fIerror\fP User-supplied error buffer to output error message\&. 
.br
\fIerror_size\fP Size of user-supplied error buffer 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBM_SQL_ERROR_SUCCESS\fP on success, or one of the \fBM_sql_error_t\fP return values on failure\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
