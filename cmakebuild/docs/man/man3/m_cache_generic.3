.TH "m_cache_generic" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_cache_generic
.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBM_cache_callbacks\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct M_cache \fBM_cache_t\fP"
.br
.ti -1c
.RI "typedef void *(* \fBM_cache_duplicate_func\fP) (const void *)"
.br
.ti -1c
.RI "typedef void(* \fBM_cache_free_func\fP) (void *)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_cache_flags_t\fP { \fBM_CACHE_NONE\fP = 0 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_cache_t\fP * \fBM_cache_create\fP (size_t max_size, \fBM_hashtable_hash_func\fP key_hash, \fBM_sort_compar_t\fP key_equality, M_uint32 flags, const struct \fBM_cache_callbacks\fP *callbacks) M_MALLOC"
.br
.ti -1c
.RI "void \fBM_cache_destroy\fP (\fBM_cache_t\fP *c)"
.br
.ti -1c
.RI "M_bool \fBM_cache_insert\fP (\fBM_cache_t\fP *c, const void *key, const void *value)"
.br
.ti -1c
.RI "M_bool \fBM_cache_remove\fP (\fBM_cache_t\fP *c, const void *key)"
.br
.ti -1c
.RI "M_bool \fBM_cache_get\fP (const \fBM_cache_t\fP *c, const void *key, void **value)"
.br
.ti -1c
.RI "size_t \fBM_cache_size\fP (const \fBM_cache_t\fP *c)"
.br
.ti -1c
.RI "size_t \fBM_cache_max_size\fP (const \fBM_cache_t\fP *c)"
.br
.ti -1c
.RI "M_bool \fBM_cache_set_max_size\fP (\fBM_cache_t\fP *c, size_t max_size)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Hot cache\&. 
.SH "Data Structure Documentation"
.PP 
.SH "struct M_cache_callbacks"
.PP 
Structure of callbacks that can be registered to override default behavior for implementation\&. 
.PP
\fBData Fields:\fP
.RS 4
\fBM_cache_duplicate_func\fP \fIkey_duplicate\fP Callback to duplicate a key\&. Default if NULL is pass-thru pointer 
.br
.PP
\fBM_cache_free_func\fP \fIkey_free\fP Callback to free a key\&. Default if NULL is no-op 
.br
.PP
\fBM_cache_duplicate_func\fP \fIvalue_duplicate\fP Callback to duplicate a value\&. Default if NULL is pass-thru pointer 
.br
.PP
\fBM_cache_free_func\fP \fIvalue_free\fP Callback to free a value\&. Default if NULL is a no-op 
.br
.PP
.RE
.PP
.SH "Typedef Documentation"
.PP 
.SS "typedef struct M_cache \fBM_cache_t\fP"

.SS "typedef void*(* M_cache_duplicate_func) (const void *)"
Function definition to duplicate a value\&. 
.SS "typedef void(* M_cache_free_func) (void *)"
Function definition to free a value\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_cache_flags_t\fP"
Flags for controlling the behavior of the hash 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_CACHE_NONE \fP\fP
Default\&. 
.SH "Function Documentation"
.PP 
.SS "\fBM_cache_t\fP* M_cache_create (size_t max_size, \fBM_hashtable_hash_func\fP key_hash, \fBM_sort_compar_t\fP key_equality, M_uint32 flags, const struct \fBM_cache_callbacks\fP * callbacks)"
Create a cache\&.
.PP
\fBParameters:\fP
.RS 4
\fImax_size\fP Maximum number of entries in the cache\&. 
.br
\fIkey_hash\fP The function to use for hashing a key\&. If not specified will use the pointer address as the key\&. 
.br
\fIkey_equality\fP The function to use to determine if two keys are equal\&. If not specified, will compare pointer addresses\&. 
.br
\fIflags\fP M_hash_strvp_flags_t flags for modifying behavior\&. 
.br
\fIcallbacks\fP Register callbacks for overriding default behavior\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Allocated cache\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_cache_destroy\fP 
.RE
.PP

.SS "void M_cache_destroy (\fBM_cache_t\fP * c)"
Destroy the cache\&.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP Cache to destroy 
.RE
.PP

.SS "M_bool M_cache_insert (\fBM_cache_t\fP * c, const void * key, const void * value)"
Insert an entry into the cache\&.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP Cache being referenced\&. 
.br
\fIkey\fP Key to insert\&. 
.br
\fIvalue\fP Value to insert into h\&. The c will take ownership of the value\&. Maybe NULL\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, or M_FALSE on failure\&. 
.RE
.PP

.SS "M_bool M_cache_remove (\fBM_cache_t\fP * c, const void * key)"
Remove an entry from the cache\&.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP Cache being referenced\&. 
.br
\fIkey\fP Key to remove from the h\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, or M_FALSE if key does not exist\&. 
.RE
.PP

.SS "M_bool M_cache_get (const \fBM_cache_t\fP * c, const void * key, void ** value)"
Retrieve the value for a key from the cache\&.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP Cache being referenced\&. 
.br
\fIkey\fP Key for value\&. 
.br
\fIvalue\fP Pointer to value stored in the h\&. Optional, pass NULL if not needed\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if value retrieved, M_FALSE if key does not exist\&. 
.RE
.PP

.SS "size_t M_cache_size (const \fBM_cache_t\fP * c)"
Get the number of items in the cache\&.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP Cache being referenced\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Count\&. 
.RE
.PP

.SS "size_t M_cache_max_size (const \fBM_cache_t\fP * c)"
Get the maximum number of items allowed in the cache\&.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP Cache being referenced\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Max\&. 
.RE
.PP

.SS "M_bool M_cache_set_max_size (\fBM_cache_t\fP * c, size_t max_size)"
Set the maximum number of items allowed in the cache\&.
.PP
This can be used to increase or decrease the maximum size of the cache\&. If the max size is smaller than the number of items in the cache, older items will be removed\&.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP Cache being referenced\&. 
.br
\fImax_size\fP Maximum size\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the max size was changed, otherwise M_FALSE on error\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
