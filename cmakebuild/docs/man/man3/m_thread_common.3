.TH "m_thread_common" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_thread_common
.SH SYNOPSIS
.br
.PP
.SS "Modules"

.in +1c
.ti -1c
.RI "\fBThread System Initialization, Destruction, and Information\fP"
.br
.ti -1c
.RI "\fBThread Creation and Management\fP"
.br
.ti -1c
.RI "\fBThread Mutexes (Locks/Critical Sections)\fP"
.br
.ti -1c
.RI "\fBThread Conditionals\fP"
.br
.ti -1c
.RI "\fBRead/Write locks\fP"
.br
.ti -1c
.RI "\fBThread Local Storage\fP"
.br
.ti -1c
.RI "\fBSpinlocks\fP"
.br
.ti -1c
.RI "\fBThreadsafe initialization helpers (Thread Once)\fP"
.br
.ti -1c
.RI "\fBThread \- System Specific\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Thread handling\&.
.PP
System specific threading model as well as a cooperative threading model is available\&. Cooperative should only be used on system that do not natively support threads\&. Such as some embedded systems\&.
.PP
By default threads are created in a detached state\&. M_thread_attr_t must be used in order to have a thread created in a joinable state\&.
.PP
Example:
.PP
.PP
.nf
static M_uint32 count = 0;

static void td(void)
{
    M_printf("Thread finished\n");
}

static void *runner(void *arg)
{
    M_thread_mutex_t *m = arg;

    M_thread_mutex_lock(m);
    count++;
    M_thread_mutex_unlock(m);
}

int main(int argc, char **argv)
{
    M_threadid_t      t1;
    M_threadid_t      t2;
    M_thread_attr_t  *tattr;
    M_thread_mutex_t *m

    M_thread_destructor_insert(td);

    tattr   = M_thread_attr_create();
    M_thread_attr_set_create_joinable(tattr, M_TRUE);

    m = M_thread_mutex_create(M_THREAD_MUTEXATTR_NONE);

    t1 = M_thread_create(tattr, runner, m);
    t2 = M_thread_create(tattr, runner, m);

    M_thread_attr_destroy(tattr);
    M_thread_join(t1, NULL);
    M_thread_join(t2, NULL);

    M_thread_mutex_destroy(m);

    M_printf("count='%u'\n", count);

    return 0;
}
.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
