.TH "m_io_block" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_io_block
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_block_connect\fP (\fBM_io_t\fP *io)"
.br
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_block_accept\fP (\fBM_io_t\fP **io_out, \fBM_io_t\fP *server_io, M_uint64 timeout_ms)"
.br
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_block_read\fP (\fBM_io_t\fP *io, unsigned char *buf, size_t buf_len, size_t *len_read, M_uint64 timeout_ms)"
.br
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_block_read_into_buf\fP (\fBM_io_t\fP *io, \fBM_buf_t\fP *buf, M_uint64 timeout_ms)"
.br
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_block_read_into_parser\fP (\fBM_io_t\fP *io, \fBM_parser_t\fP *parser, M_uint64 timeout_ms)"
.br
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_block_write\fP (\fBM_io_t\fP *io, const unsigned char *buf, size_t buf_len, size_t *len_written, M_uint64 timeout_ms)"
.br
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_block_write_from_buf\fP (\fBM_io_t\fP *io, \fBM_buf_t\fP *buf, M_uint64 timeout_ms)"
.br
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_block_disconnect\fP (\fBM_io_t\fP *io)"
.br
.in -1c
.SH "Detailed Description"
.PP 
The io system can be used with blocking operations\&. An explicit event loop is not required\&. This allows the stacked layers to be utilized with a more traditional blocking design\&.
.PP
Here is an example of the system using the loopback io back end to simulate a network connection to a remote server\&.
.PP
.PP
.nf
#include <mstdlib/mstdlib\&.h>
#include <mstdlib/mstdlib_io\&.h>

int main(int argc, char *argv)
{
    M_io_t     *io = NULL;
    M_buf_t    *buf;
    M_parser_t *parser;
    char       *out;

    buf    = M_buf_create();
    parser = M_parser_create(M_PARSER_FLAG_NONE);
    M_io_loopback_create(&io);

    M_io_block_connect(io);

    M_buf_add_str(buf, "TEST 123");
    M_io_block_write_from_buf(io, buf, M_TIMEOUT_INF);

    M_io_block_read_into_parser(io, parser, M_TIMEOUT_INF);
    out = M_parser_read_strdup(parser, M_parser_len(parser));
    M_printf("%s\n", out);
    M_free(out);

    M_buf_add_str(buf, "abc 456");
    M_io_block_write_from_buf(io, buf, M_TIMEOUT_INF);

    M_io_block_read_into_parser(io, parser, M_TIMEOUT_INF);
    out = M_parser_read_strdup(parser, M_parser_len(parser));
    M_printf("%s\n", out);
    M_free(out);

    M_parser_destroy(parser);
    M_buf_cancel(buf);
    M_io_block_disconnect(io);
    return 0;
}
.fi
.PP
 
.SH "Function Documentation"
.PP 
.SS "\fBM_io_error_t\fP M_io_block_connect (\fBM_io_t\fP * io)"
Connect the io object to the remote end point\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SS "\fBM_io_error_t\fP M_io_block_accept (\fBM_io_t\fP ** io_out, \fBM_io_t\fP * server_io, M_uint64 timeout_ms)"
Accept an io connection\&.
.PP
\fBParameters:\fP
.RS 4
\fIio_out\fP io object created from the accept\&. 
.br
\fIserver_io\fP io object which was listening\&. 
.br
\fItimeout_ms\fP Amount of time in milliseconds to wait for data\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SS "\fBM_io_error_t\fP M_io_block_read (\fBM_io_t\fP * io, unsigned char * buf, size_t buf_len, size_t * len_read, M_uint64 timeout_ms)"
Read from an io object\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIbuf\fP Buffer to store data read from io object\&. 
.br
\fIbuf_len\fP Lenght of provided buffer\&. 
.br
\fIlen_read\fP Number of bytes fread from the io object\&. 
.br
\fItimeout_ms\fP Amount of time in milliseconds to wait for data\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SS "\fBM_io_error_t\fP M_io_block_read_into_buf (\fBM_io_t\fP * io, \fBM_buf_t\fP * buf, M_uint64 timeout_ms)"
Read from an io object into an M_buf_t\&.
.PP
This will read all available data into the buffer\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIbuf\fP Buffer to store data read from io object\&. 
.br
\fItimeout_ms\fP Amount of time in milliseconds to wait for data\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SS "\fBM_io_error_t\fP M_io_block_read_into_parser (\fBM_io_t\fP * io, \fBM_parser_t\fP * parser, M_uint64 timeout_ms)"
Read from an io object into an M_parser_t\&.
.PP
This will read all available data into the buffer\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIparser\fP Parser to store data read from io object\&. 
.br
\fItimeout_ms\fP Amount of time in milliseconds to wait for data\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SS "\fBM_io_error_t\fP M_io_block_write (\fBM_io_t\fP * io, const unsigned char * buf, size_t buf_len, size_t * len_written, M_uint64 timeout_ms)"
Write data to an io object\&.
.PP
This function will attempt to write as much data as possible\&. If not all data is written the application should try again\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIbuf\fP Buffer to write from\&. 
.br
\fIbuf_len\fP Number of bytes in buffer to write\&. 
.br
\fIlen_written\fP Number of bytes from the buffer written\&. 
.br
\fItimeout_ms\fP Amount of time in milliseconds to wait for data\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SS "\fBM_io_error_t\fP M_io_block_write_from_buf (\fBM_io_t\fP * io, \fBM_buf_t\fP * buf, M_uint64 timeout_ms)"
Write data to an io object from an M_buf_t\&.
.PP
This function will attempt to write as much data as possible\&. If not all data is written the application should try again\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&. 
.br
\fIbuf\fP Buffer to write from\&. 
.br
\fItimeout_ms\fP Amount of time in milliseconds to wait for data\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SS "\fBM_io_error_t\fP M_io_block_disconnect (\fBM_io_t\fP * io)"
Gracefully issue a disconnect to the communications object\&.
.PP
\fBParameters:\fP
.RS 4
\fIio\fP io object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
