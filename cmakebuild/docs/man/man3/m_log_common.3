.TH "m_log_common" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_log_common
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct M_log \fBM_log_t\fP"
.br
.ti -1c
.RI "typedef struct M_log_module \fBM_log_module_t\fP"
.br
.ti -1c
.RI "typedef void(* \fBM_log_prefix_cb\fP) (\fBM_buf_t\fP *msg_buf, M_uint64 tag, void *prefix_thunk, void *msg_thunk)"
.br
.ti -1c
.RI "typedef M_bool(* \fBM_log_filter_cb\fP) (M_uint64 tag, void *filter_thunk, void *msg_thunk)"
.br
.ti -1c
.RI "typedef void(* \fBM_log_expire_cb\fP) (\fBM_log_module_t\fP *module, void *thunk)"
.br
.ti -1c
.RI "typedef void(* \fBM_log_destroy_cb\fP) (void *thunk)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_log_error_t\fP { \fBM_LOG_SUCCESS\fP = 0, \fBM_LOG_INVALID_PARAMS\fP, \fBM_LOG_INVALID_PATH\fP, \fBM_LOG_INVALID_TAG\fP, \fBM_LOG_NO_EVENT_LOOP\fP, \fBM_LOG_SUSPENDED\fP, \fBM_LOG_DUPLICATE_TAG_NAME\fP, \fBM_LOG_UNREACHABLE\fP, \fBM_LOG_INVALID_TIME_FORMAT\fP, \fBM_LOG_MODULE_UNSUPPORTED\fP, \fBM_LOG_MODULE_NOT_FOUND\fP, \fBM_LOG_WRONG_MODULE\fP, \fBM_LOG_GENERIC_FAIL\fP }"
.br
.ti -1c
.RI "enum \fBM_log_module_type_t\fP { \fBM_LOG_MODULE_NULL\fP = 0, \fBM_LOG_MODULE_STREAM\fP, \fBM_LOG_MODULE_NSLOG\fP, \fBM_LOG_MODULE_ANDROID\fP, \fBM_LOG_MODULE_FILE\fP, \fBM_LOG_MODULE_SYSLOG\fP, \fBM_LOG_MODULE_TSYSLOG\fP, \fBM_LOG_MODULE_MEMBUF\fP }"
.br
.ti -1c
.RI "enum \fBM_log_line_end_mode_t\fP { \fBM_LOG_LINE_END_NATIVE\fP, \fBM_LOG_LINE_END_UNIX\fP, \fBM_LOG_LINE_END_WINDOWS\fP }"
.br
.ti -1c
.RI "enum \fBM_stream_type_t\fP { \fBM_STREAM_STDOUT\fP, \fBM_STREAM_STDERR\fP }"
.br
.ti -1c
.RI "enum \fBM_syslog_facility_t\fP { \fBM_SYSLOG_FACILITY_USER\fP = 1 << 3, \fBM_SYSLOG_FACILITY_DAEMON\fP = 3 << 3, \fBM_SYSLOG_FACILITY_LOCAL0\fP = 16 << 3, \fBM_SYSLOG_FACILITY_LOCAL1\fP = 17 << 3, \fBM_SYSLOG_FACILITY_LOCAL2\fP = 18 << 3, \fBM_SYSLOG_FACILITY_LOCAL3\fP = 19 << 3, \fBM_SYSLOG_FACILITY_LOCAL4\fP = 20 << 3, \fBM_SYSLOG_FACILITY_LOCAL5\fP = 21 << 3, \fBM_SYSLOG_FACILITY_LOCAL6\fP = 22 << 3, \fBM_SYSLOG_FACILITY_LOCAL7\fP = 23 << 3 }"
.br
.ti -1c
.RI "enum \fBM_syslog_priority_t\fP { \fBM_SYSLOG_EMERG\fP = 0, \fBM_SYSLOG_ALERT\fP = 1, \fBM_SYSLOG_CRIT\fP = 2, \fBM_SYSLOG_ERR\fP = 3, \fBM_SYSLOG_WARNING\fP = 4, \fBM_SYSLOG_NOTICE\fP = 5, \fBM_SYSLOG_INFO\fP = 6, \fBM_SYSLOG_DEBUG\fP = 7 }"
.br
.ti -1c
.RI "enum \fBM_android_log_priority_t\fP { \fBM_ANDROID_LOG_FATAL\fP = 0, \fBM_ANDROID_LOG_ERROR\fP = 1, \fBM_ANDROID_LOG_WARN\fP = 2, \fBM_ANDROID_LOG_INFO\fP = 3, \fBM_ANDROID_LOG_DEBUG\fP = 4, \fBM_ANDROID_LOG_VERBOSE\fP = 5 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "const char * \fBM_log_err_to_str\fP (\fBM_log_error_t\fP err)"
.br
.ti -1c
.RI "\fBM_log_t\fP * \fBM_log_create\fP (\fBM_log_line_end_mode_t\fP mode, M_bool flush_on_destroy, \fBM_event_t\fP *event)"
.br
.ti -1c
.RI "void \fBM_log_destroy\fP (\fBM_log_t\fP *log)"
.br
.ti -1c
.RI "void \fBM_log_destroy_blocking\fP (\fBM_log_t\fP *log, M_uint64 timeout_ms)"
.br
.ti -1c
.RI "\fBM_log_error_t\fP \fBM_log_set_time_format\fP (\fBM_log_t\fP *log, const char *fmt)"
.br
.ti -1c
.RI "\fBM_log_error_t\fP \fBM_log_set_tag_name\fP (\fBM_log_t\fP *log, M_uint64 tag, const char *name)"
.br
.ti -1c
.RI "const char * \fBM_log_get_tag_name\fP (\fBM_log_t\fP *log, M_uint64 tag)"
.br
.ti -1c
.RI "M_uint64 \fBM_log_get_tag\fP (\fBM_log_t\fP *log, const char *name)"
.br
.ti -1c
.RI "\fBM_log_error_t\fP \fBM_log_set_tag_names_padded\fP (\fBM_log_t\fP *log, M_bool padded)"
.br
.ti -1c
.RI "\fBM_log_error_t\fP \fBM_log_printf\fP (\fBM_log_t\fP *log, M_uint64 tag, void *msg_thunk, const char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "\fBM_log_error_t\fP \fBM_log_vprintf\fP (\fBM_log_t\fP *log, M_uint64 tag, void *msg_thunk, const char *fmt, va_list ap)"
.br
.ti -1c
.RI "\fBM_log_error_t\fP \fBM_log_write\fP (\fBM_log_t\fP *log, M_uint64 tag, void *msg_thunk, const char *msg)"
.br
.ti -1c
.RI "void \fBM_log_emergency\fP (\fBM_log_t\fP *log, const char *msg)"
.br
.ti -1c
.RI "void \fBM_log_reopen_all\fP (\fBM_log_t\fP *log)"
.br
.ti -1c
.RI "void \fBM_log_suspend\fP (\fBM_log_t\fP *log)"
.br
.ti -1c
.RI "void \fBM_log_resume\fP (\fBM_log_t\fP *log, \fBM_event_t\fP *event)"
.br
.ti -1c
.RI "\fBM_list_t\fP * \fBM_log_all_modules\fP (\fBM_log_t\fP *log)"
.br
.ti -1c
.RI "M_bool \fBM_log_module_present\fP (\fBM_log_t\fP *log, \fBM_log_module_t\fP *module)"
.br
.ti -1c
.RI "\fBM_log_module_type_t\fP \fBM_log_module_type\fP (\fBM_log_t\fP *log, \fBM_log_module_t\fP *module)"
.br
.ti -1c
.RI "\fBM_log_error_t\fP \fBM_log_module_set_accepted_tags\fP (\fBM_log_t\fP *log, \fBM_log_module_t\fP *module, M_uint64 tags)"
.br
.ti -1c
.RI "\fBM_log_error_t\fP \fBM_log_module_get_accepted_tags\fP (\fBM_log_t\fP *log, \fBM_log_module_t\fP *module, M_uint64 *out_tags)"
.br
.ti -1c
.RI "\fBM_log_error_t\fP \fBM_log_module_set_prefix\fP (\fBM_log_t\fP *log, \fBM_log_module_t\fP *module, \fBM_log_prefix_cb\fP prefix_cb, void *prefix_thunk, \fBM_log_destroy_cb\fP thunk_destroy_cb)"
.br
.ti -1c
.RI "\fBM_log_error_t\fP \fBM_log_module_set_filter\fP (\fBM_log_t\fP *log, \fBM_log_module_t\fP *module, \fBM_log_filter_cb\fP filter_cb, void *filter_thunk, \fBM_log_destroy_cb\fP thunk_destroy_cb)"
.br
.ti -1c
.RI "\fBM_log_error_t\fP \fBM_log_module_reopen\fP (\fBM_log_t\fP *log, \fBM_log_module_t\fP *module)"
.br
.ti -1c
.RI "\fBM_log_error_t\fP \fBM_log_module_remove\fP (\fBM_log_t\fP *log, \fBM_log_module_t\fP *module)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Common logging functions\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct M_log \fBM_log_t\fP"
Opaque struct that maintains state for the logging system\&. 
.SS "typedef struct M_log_module \fBM_log_module_t\fP"
Opaque handle used to refer to individual log modules\&. DON'T FREE THIS\&. 
.SS "typedef void(* M_log_prefix_cb) (\fBM_buf_t\fP *msg_buf, M_uint64 tag, void *prefix_thunk, void *msg_thunk)"
Function type for per-module prefix callbacks\&.
.PP
This will be called every time a log message is sent to the module\&. It allows you to add a custom prefix after the timestamp string, by letting you append to the message buffer before the log message is added:
.PP
.PP
.nf
03-02-2012 08:05:32<your prefix here>... log message ...<line end char> .fi
.PP
.PP
Note that no spaces or separator chars are automatically added between the timestamp string, your prefix, and the log message\&.
.PP
If no prefix callback is provided, the default prefix \fC': '\fP will be added instead\&.
.PP
\fBWarning:\fP
.RS 4
Do not call any M_log_* or M_log_module_* functions from inside a prefix callback, it will cause a deadlock\&.
.PP
Do not write line-end characters in a prefix\&. Some logging modules don't handle multiple-line messages very well, and line-end chars are not automatically removed from custom prefixes\&.
.PP
May be called simultaneously from multiple threads\&. If the content of prefix_thunk may be modified after it's passed to a module, you should include your own locks inside the thunk and use them inside the callback\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_log_module_set_prefix()\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIprefix_thunk\fP thunk passed to \fBM_log_module_set_prefix()\fP 
.br
\fImsg_thunk\fP thunk passed to \fBM_printf()\fP or \fBM_vprintf()\fP 
.br
\fImsg_buf\fP message buffer (append prefix to this) 
.br
\fItag\fP tag of message we're prefixing 
.RE
.PP

.SS "typedef M_bool(* M_log_filter_cb) (M_uint64 tag, void *filter_thunk, void *msg_thunk)"
Function type for per-module filtering callbacks\&.
.PP
This will be called every time a log message is sent to the module\&. If the function returns M_FALSE, the message will be ignored by the module\&.
.PP
\fBWarning:\fP
.RS 4
Do not call any M_log_* or M_log_module_* functions from inside a filter callback, it will cause a deadlock\&.
.PP
May be called simultaneously from multiple threads\&. If the content of filter_thunk may be modified after it's passed to a module, you should include your own locks inside the thunk and use them inside the callback\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_log_module_set_filter()\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIfilter_thunk\fP thunk passed to \fBM_log_module_set_filter()\fP 
.br
\fImsg_thunk\fP thunk passed to \fBM_log_printf()\fP or \fBM_log_vprintf()\fP 
.br
\fItag\fP tag of message we're filtering 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if this module will accept the given tag, M_FALSE otherwise 
.RE
.PP

.SS "typedef void(* M_log_expire_cb) (\fBM_log_module_t\fP *module, void *thunk)"
Function type for callback that's called when a module expires\&.
.PP
This will be called by the log whenever a module expires and is automatically removed\&. Currently, only the membuf module has an automatic expiration date\&. The callback is not called when a module is removed by normal, user-initiated means like \fBM_log_module_remove()\fP or \fBM_log_module_take_membuf()\fP\&.
.PP
Note that the callback is called AFTER the module is removed from the log\&. So, at the time the callback is called, the module handle is already invalid\&.
.PP
\fBWarning:\fP
.RS 4
This callback may be called simultaneously by multiple internal threads\&. If the callback modifies some shared datastructure, you MUST use your own locks to prevent concurrent access to that datastructure\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_log_module_add_membuf()\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fImodule\fP handle of membuf module that was just removed (invalid) 
.br
\fIthunk\fP thunk passed to \fBM_log_module_add_membuf()\fP 
.RE
.PP

.SS "typedef void(* M_log_destroy_cb) (void *thunk)"
Function type for destructors\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_log_error_t\fP"
Error codes for the logging system\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_LOG_SUCCESS \fP\fP
Operation succeeded\&. 
.TP
\fB\fIM_LOG_INVALID_PARAMS \fP\fP
Given parameters invalid (usually a NULL pointer) 
.TP
\fB\fIM_LOG_INVALID_PATH \fP\fP
Given filesystem path couldn't be normalized 
.TP
\fB\fIM_LOG_INVALID_TAG \fP\fP
Single tags must be non-zero and a power of two 
.TP
\fB\fIM_LOG_NO_EVENT_LOOP \fP\fP
No event loop specified for log, can't use event-based modules\&. 
.TP
\fB\fIM_LOG_SUSPENDED \fP\fP
Log has been suspended, can't take the requested action until resume is called 
.TP
\fB\fIM_LOG_DUPLICATE_TAG_NAME \fP\fP
Given name has already been assigned to a different tag 
.TP
\fB\fIM_LOG_UNREACHABLE \fP\fP
Requested resource unreachable (can't connect to host, can't open file on disk) 
.TP
\fB\fIM_LOG_INVALID_TIME_FORMAT \fP\fP
Given time format string is invalid (can't be parsed) 
.TP
\fB\fIM_LOG_MODULE_UNSUPPORTED \fP\fP
The given module type is not supported on this OS 
.TP
\fB\fIM_LOG_MODULE_NOT_FOUND \fP\fP
The requested module has already been removed from the logger 
.TP
\fB\fIM_LOG_WRONG_MODULE \fP\fP
Module-specific function was run on the wrong module 
.TP
\fB\fIM_LOG_GENERIC_FAIL \fP\fP
Generic internal module failure occurred (usually an IO error) 
.SS "enum \fBM_log_module_type_t\fP"
Logging module types\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_LOG_MODULE_NULL \fP\fP
Type that represents invalid or unset module type 
.TP
\fB\fIM_LOG_MODULE_STREAM \fP\fP
Module that outputs to stdout or stderr 
.TP
\fB\fIM_LOG_MODULE_NSLOG \fP\fP
Module that outputs to macOS/iOS logging system (NSLog) 
.TP
\fB\fIM_LOG_MODULE_ANDROID \fP\fP
Module that outputs to android logging system 
.TP
\fB\fIM_LOG_MODULE_FILE \fP\fP
Module that outputs to a set of files on the filesystem 
.TP
\fB\fIM_LOG_MODULE_SYSLOG \fP\fP
Module that outputs directly to a local syslog daemon 
.TP
\fB\fIM_LOG_MODULE_TSYSLOG \fP\fP
Module that outputs to a remove syslog daemon using TCP 
.TP
\fB\fIM_LOG_MODULE_MEMBUF \fP\fP
Module that outputs to a temporary memory buffer 
.SS "enum \fBM_log_line_end_mode_t\fP"
Control what type of line endings get automatically appended to log messages\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_LOG_LINE_END_NATIVE \fP\fP
\fC'\\n'\fP if running on Unix, \fC'\\r\\n'\fP if running on Windows 
.TP
\fB\fIM_LOG_LINE_END_UNIX \fP\fP
always use \fC'\\n'\fP 
.TP
\fB\fIM_LOG_LINE_END_WINDOWS \fP\fP
always use \fC'\\r\\n'\fP 
.SS "enum \fBM_stream_type_t\fP"
Types of output streams that can be used for the stream module\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_STREAM_STDOUT \fP\fP
Output log messages to \fCstdout\fP 
.TP
\fB\fIM_STREAM_STDERR \fP\fP
Output log messages to \fCstderr\fP 
.SS "enum \fBM_syslog_facility_t\fP"
Standard facility types for syslog and tcp_syslog modules\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_SYSLOG_FACILITY_USER \fP\fP
.TP
\fB\fIM_SYSLOG_FACILITY_DAEMON \fP\fP
.TP
\fB\fIM_SYSLOG_FACILITY_LOCAL0 \fP\fP
.TP
\fB\fIM_SYSLOG_FACILITY_LOCAL1 \fP\fP
.TP
\fB\fIM_SYSLOG_FACILITY_LOCAL2 \fP\fP
.TP
\fB\fIM_SYSLOG_FACILITY_LOCAL3 \fP\fP
.TP
\fB\fIM_SYSLOG_FACILITY_LOCAL4 \fP\fP
.TP
\fB\fIM_SYSLOG_FACILITY_LOCAL5 \fP\fP
.TP
\fB\fIM_SYSLOG_FACILITY_LOCAL6 \fP\fP
.TP
\fB\fIM_SYSLOG_FACILITY_LOCAL7 \fP\fP
.SS "enum \fBM_syslog_priority_t\fP"
Standard log priority types for syslog and tcp_syslog modules\&.
.PP
Listed in enum in order of descending priority (highest priority --> lowest priority)\&.
.PP
It is up to the caller to define the mapping between their own logging tags and the syslog priority levels\&. These mappings are defined on a per-module basis\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_log_module_syslog_set_tag_priority\fP 
.PP
\fBM_log_module_tcp_syslog_set_tag_priority\fP 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_SYSLOG_EMERG \fP\fP
.TP
\fB\fIM_SYSLOG_ALERT \fP\fP
.TP
\fB\fIM_SYSLOG_CRIT \fP\fP
.TP
\fB\fIM_SYSLOG_ERR \fP\fP
.TP
\fB\fIM_SYSLOG_WARNING \fP\fP
.TP
\fB\fIM_SYSLOG_NOTICE \fP\fP
.TP
\fB\fIM_SYSLOG_INFO \fP\fP
.TP
\fB\fIM_SYSLOG_DEBUG \fP\fP
.SS "enum \fBM_android_log_priority_t\fP"
Standard log priority types for android log module\&.
.PP
Listed in enum in order of descending priority (highest priority --> lowest priority)\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_log_module_android_set_tag_priority\fP 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_ANDROID_LOG_FATAL \fP\fP
.TP
\fB\fIM_ANDROID_LOG_ERROR \fP\fP
.TP
\fB\fIM_ANDROID_LOG_WARN \fP\fP
.TP
\fB\fIM_ANDROID_LOG_INFO \fP\fP
.TP
\fB\fIM_ANDROID_LOG_DEBUG \fP\fP
.TP
\fB\fIM_ANDROID_LOG_VERBOSE \fP\fP
.SH "Function Documentation"
.PP 
.SS "const char* M_log_err_to_str (\fBM_log_error_t\fP err)"
Return human-readable string describing the given error code\&.
.PP
\fBParameters:\fP
.RS 4
\fIerr\fP error code 
.RE
.PP
\fBReturns:\fP
.RS 4
human-readable descriptive string 
.RE
.PP

.SS "\fBM_log_t\fP* M_log_create (\fBM_log_line_end_mode_t\fP mode, M_bool flush_on_destroy, \fBM_event_t\fP * event)"
Create a new log manager\&.
.PP
When first created, the log manager will accept messages, but won't output anything\&. The desired output modules must be added and configured after the logger is created\&. You can add any number or combination of the output modules\&.
.PP
To free the logger object, you must call \fBM_log_destroy()\fP or \fBM_log_destroy_blocking()\fP\&.
.PP
If \fIflush_on_destroy\fP is set to M_TRUE, log modules won't be destroyed until all messages in their queue (if any) are written\&. Otherwise, log modules will be destroyed immediately after the message currently being written is done\&.
.PP
If you don't plan on adding any event-based modules (like tcp_syslog), you can pass \fCNULL\fP for the event pointer\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_log_module_add_stream\fP 
.PP
\fBM_log_module_add_file\fP 
.PP
\fBM_log_module_add_syslog\fP 
.PP
\fBM_log_module_add_tcp_syslog\fP 
.PP
\fBM_log_module_add_membuf\fP 
.PP
\fBM_log_destroy\fP 
.PP
\fBM_log_destroy_blocking\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fImode\fP line-ending mode 
.br
\fIflush_on_destroy\fP if M_TRUE, wait until message queue is empty when destroying a module 
.br
\fIevent\fP external event loop to use for event-based modules (not owned by logger)
.RE
.PP
\fBReturns:\fP
.RS 4
new logger object 
.RE
.PP

.SS "void M_log_destroy (\fBM_log_t\fP * log)"
Destroy the logger (non-blocking)\&.
.PP
Sends a message to each module requesting that it stop at the next opportunity and destroy itself, then immediately destroys the logger\&.
.PP
Worker threads will try to clean themselves up gracefully, after this function returns (if the process doesn't end before they have a chance to)\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_log_destroy_blocking\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.RE
.PP

.SS "void M_log_destroy_blocking (\fBM_log_t\fP * log, M_uint64 timeout_ms)"
Destroy the logger (blocking)\&.
.PP
Sends a message to each module requesting that it stop at the next opportunity\&. Once all internal worker threads have stopped, destroys all the modules and the logger\&.
.PP
If the timeout is reached before all modules have stopped, non-blocking destroys will be triggered for the remaining modules\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_log_destroy\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fItimeout_ms\fP amount of time to wait for modules to finish before giving up, or 0 to never give up 
.RE
.PP

.SS "\fBM_log_error_t\fP M_log_set_time_format (\fBM_log_t\fP * log, const char * fmt)"
Set timestamp format for all future log messages\&.
.PP
If not set, the default timestamp format \fC'%a %D %H:%m:%s\&.%u %z'\fP will be used\&.
.PP
If the given time format string is empty or invalid, an error will be returned and the old time format string will be preserved\&.
.PP
Specifiers accepted in time format string:
.IP "\(bu" 2
%t -- Unix timestamp
.IP "\(bu" 2
%M -- 2 digit month
.IP "\(bu" 2
%a -- abbreviated month (Jan/Feb/Mar, etc)
.IP "\(bu" 2
%D -- 2 digit day of month
.IP "\(bu" 2
%d -- abbreviated day of week (Sun/Mon/Tue, etc)
.IP "\(bu" 2
%Y -- 4 digit year
.IP "\(bu" 2
%y -- 2 digit year
.IP "\(bu" 2
%H -- 2 digit hour
.IP "\(bu" 2
%m -- 2 digit minute
.IP "\(bu" 2
%s -- 2 digit second
.IP "\(bu" 2
%u -- 6 digit microsecond
.IP "\(bu" 2
%z -- timezone offset
.PP
.PP
For example '[%D/%a/%Y:%H:%m:%s\&.%u %z]' might give a prefix like: [11/Jan/2008:09:19:11\&.654 -0500]
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fIfmt\fP time format string 
.RE
.PP
\fBReturns:\fP
.RS 4
error code 
.RE
.PP

.SS "\fBM_log_error_t\fP M_log_set_tag_name (\fBM_log_t\fP * log, M_uint64 tag, const char * name)"
Associate a name with the given tag\&.
.PP
If a name is specified for the given tag, it will be added to the message prefix, in between the timestamp and the custom prefix\&.
.PP
Alternatively, since the tag gets passed into the custom prefix callback, you can add the tag name there instead of using this\&.
.PP
Tag names must be unique (case-insensitive)\&. If you try to assign the same name to two tags, you'll get an error code on the second (M_LOG_DUPLICATE_NAME)\&.
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fItag\fP user-defined tag (must be a single power-of-two tag) 
.br
\fIname\fP name to associate with this tag (NULL or empty string to remove an existing name association) 
.RE
.PP
\fBReturns:\fP
.RS 4
error code 
.RE
.PP

.SS "const char* M_log_get_tag_name (\fBM_log_t\fP * log, M_uint64 tag)"
Get the name associated with the given tag\&.
.PP
\fBWarning:\fP
.RS 4
DO NOT call this method from a prefix or filter callback, it will cause a deadlock\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fItag\fP user-defined tag (must be a single power-of-two tag) 
.RE
.PP
\fBReturns:\fP
.RS 4
name of tag, or NULL if there's no name stored or some other error occurred 
.RE
.PP

.SS "M_uint64 M_log_get_tag (\fBM_log_t\fP * log, const char * name)"
Get the tag associated with the given name (case-insensitive)\&.
.PP
\fBWarning:\fP
.RS 4
DO NOT call this method from a prefix or filter callback, it will cause a deadlock\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fIname\fP name that has been previously associated with a tag (case doesn't matter) 
.RE
.PP
\fBReturns:\fP
.RS 4
tag associated with the given name, or 0 if there's no tag with this name or some other error occurred 
.RE
.PP

.SS "\fBM_log_error_t\fP M_log_set_tag_names_padded (\fBM_log_t\fP * log, M_bool padded)"
Control whether the log should pad names out to a common width or not\&.
.PP
By default, tag names are unpadded\&. However, if you use this function to enable padding, all tag names will be padded with spaces on the right out to the width of the longest name added to the log so far\&.
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fIpadded\fP M_TRUE if tag names should be padded on output, M_FALSE if not (the default) 
.RE
.PP
\fBReturns:\fP
.RS 4
error code 
.RE
.PP

.SS "\fBM_log_error_t\fP M_log_printf (\fBM_log_t\fP * log, M_uint64 tag, void * msg_thunk, const char * fmt,  \&.\&.\&.)"
Write a formatted message to the log\&.
.PP
Multi-line messages will be split into a separate log message for each line\&.
.PP
A timestamp prefix will be automatically added to the start of each line, formatted according to the string set in \fBM_log_set_time_format()\fP\&. All the lines from a single call to \fBM_printf()\fP will be given identical timestamps\&.
.PP
The message will then be sent to each individual logging module for further processing, if the given message tag is in the list of accepted tags for the module (as set by \fBM_log_module_set_accepted_tags()\fP)\&. A given module may also be skipped if a filter callback was set for the module and it rejected the message\&.
.PP
For each module that accepts the message, a prefix callback is called (if set) that appends additional text to each line's prefix, immediately following the timestamp string\&. The formatted message itself is then added, followed by the line-end characters corresponding to the current line-ending mode\&. The finished message is then sent on to the module\&.
.PP
Note that the per-message thunk only needs to be valid until \fBM_log_printf()\fP returns - you can put non-const data in here\&. This thunk is caller-managed - it's not freed or otherwise kept track of internally\&.
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fItag\fP user-defined tag attached to this message (must be a single power-of-two tag) 
.br
\fImsg_thunk\fP per-message thunk to pass to filter and prefix callbacks (only needs to be valid until function returns) 
.br
\fIfmt\fP format string, accepts same tags as \fBM_printf()\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
error code 
.RE
.PP

.SS "\fBM_log_error_t\fP M_log_vprintf (\fBM_log_t\fP * log, M_uint64 tag, void * msg_thunk, const char * fmt, va_list ap)"
Write a formatted message to the log (var arg)\&.
.PP
Same as \fBM_log_printf()\fP, but accepts a variable argument list explicitly as a va_list\&. This is inteded to allow the user to define their own wrapper functions that take variable argument lists (\&.\&.\&.) and call \fBM_log_vprintf()\fP internally\&.
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fItag\fP user-defined tag attached to this message (must be a single power-of-two tag) 
.br
\fImsg_thunk\fP per-message thunk to pass to filter and prefix callbacks (only needs to be valid until function returns) 
.br
\fIfmt\fP format string, accepts same tags as \fBM_printf()\fP 
.br
\fIap\fP list of arguments passed in from the calling vararg function 
.RE
.PP
\fBReturns:\fP
.RS 4
error code 
.RE
.PP

.SS "\fBM_log_error_t\fP M_log_write (\fBM_log_t\fP * log, M_uint64 tag, void * msg_thunk, const char * msg)"
Write a message directly to the log\&.
.PP
Same as \fBM_log_printf()\fP, but it takes a message directly, instead of a format string and a list of arguments\&.
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fItag\fP user-defined tag attached to this message (must be a single power-of-two tag) 
.br
\fImsg_thunk\fP per-message thunk to pass to filter and prefix callbacks (only needs to be valid until function returns) 
.br
\fImsg\fP message string 
.RE
.PP

.SS "void M_log_emergency (\fBM_log_t\fP * log, const char * msg)"
Perform an emergency message write, to all modules that allow such writes\&.
.PP
\fBWarning:\fP
.RS 4
This function is EXTREMELY dangerous\&. It's meant to be called in a signal handler as the program is crashing, so it doesn't acquire any mutex locks, and it tries not to malloc anything\&. DON'T USE THIS FUNCTION IN NORMAL USAGE, IT IS NOT SAFE\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fImsg\fP emergency message to output 
.RE
.PP

.SS "void M_log_reopen_all (\fBM_log_t\fP * log)"
Reopen/refresh connections for all modules in the logger\&.
.PP
This closes then re-opens existing file streams, syslog, TCP connections, etc\&. for every loaded module\&.
.PP
Modules that don't open or close anything (membuf, stream, Android log, etc\&.) are unaffected by this command\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_log_module_reopen\fP (if you only want to reopen a specific module)
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.RE
.PP

.SS "void M_log_suspend (\fBM_log_t\fP * log)"
Suspend connections for all modules in the logger (BLOCKING)\&.
.PP
This closes existing file streams, syslog, TCP connections, etc\&. for every loaded module\&.
.PP
For modules that have resources closed, messages will accumulate without any being written while suspended\&.
.PP
Modules that don't open or close anything (membuf, stream, Android log, etc\&.) are unaffected by this command\&.
.PP
\fBWarning:\fP
.RS 4
This call will block until every module that can be suspended reports that it is finished suspending itself\&. At worst, this means that we'll be blocked until whatever message is in the process of being written is done\&.
.PP
If you have modules that depend on an external event loop (like tcp_syslog), you must wait for the event loop to finish after calling suspend, and then destroy it\&. You then create a new event loop once you're ready to resume, and pass it into \fBM_log_resume()\fP\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_log_resume\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.RE
.PP

.SS "void M_log_resume (\fBM_log_t\fP * log, \fBM_event_t\fP * event)"
Resume connections for all modules in the logger\&.
.PP
This opens file streams, syslog, TCP connections, etc\&. that were closed by \fBM_log_suspend()\fP\&.
.PP
Modules that were previously suspended will now start pulling messages of the queue and writing them again\&.
.PP
If you have any modules that use an external event loop, you must pass the new loop to use into this function (since you should have destroyed the old one after calling suspend)\&. If you're not using event-based modules, you can just set this to NULL\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_log_suspend\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fIevent\fP external event loop to use for event-based modules (not owned by logger) 
.RE
.PP

.SS "\fBM_list_t\fP* M_log_all_modules (\fBM_log_t\fP * log)"
Return list of handles of all currently loaded modules\&.
.PP
The returned list is a snapshot of what modules were loaded when the function was called\&. Other threads may modify the internal list of modules after you get a copy, so the list of modules may not be accurate\&.
.PP
The caller is responsible for freeing the returned list with \fBM_list_destroy()\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.RE
.PP
\fBReturns:\fP
.RS 4
list of M_log_module_t pointers (module handles) 
.RE
.PP

.SS "M_bool M_log_module_present (\fBM_log_t\fP * log, \fBM_log_module_t\fP * module)"
Check to see if the given module handle is still loaded in the logger\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_log_module_remove\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fImodule\fP handle of module to operate on 
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE if module hasn't been removed from the log yet, M_FALSE otherwise 
.RE
.PP

.SS "\fBM_log_module_type_t\fP M_log_module_type (\fBM_log_t\fP * log, \fBM_log_module_t\fP * module)"
Return the type of the given module (file, stream, etc\&.)\&.
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fImodule\fP handle of module to operate on 
.RE
.PP
\fBReturns:\fP
.RS 4
type of module, or M_LOG_MODULE_NULL if module has already been removed 
.RE
.PP

.SS "\fBM_log_error_t\fP M_log_module_set_accepted_tags (\fBM_log_t\fP * log, \fBM_log_module_t\fP * module, M_uint64 tags)"
Associate the given user-defined tag(s) with the given module handle\&.
.PP
If you don't associate any tags with a module, nothing will get written to it\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_LOG_ALL_TAGS\fP 
.PP
\fBM_log_all_tags_lt\fP 
.PP
\fBM_log_all_tags_lte\fP 
.PP
\fBM_log_all_tags_gt\fP 
.PP
\fBM_log_all_tags_gte\fP
.PP
\fBM_log_module_get_accepted_tags\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fImodule\fP handle of module to operate on 
.br
\fItags\fP user-defined power-of-two tag (or multiple power-of-two tags, OR'd together) 
.RE
.PP
\fBReturns:\fP
.RS 4
error code 
.RE
.PP

.SS "\fBM_log_error_t\fP M_log_module_get_accepted_tags (\fBM_log_t\fP * log, \fBM_log_module_t\fP * module, M_uint64 * out_tags)"
Return a snapshot of the user-defined tag(s) currently associated with the given module handle\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_log_module_set_accepted_tags\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fImodule\fP handle of module to operate on 
.br
\fIout_tags\fP tag snapshot will be placed here, or 0 if no tags are associated with this module 
.RE
.PP
\fBReturns:\fP
.RS 4
error code 
.RE
.PP

.SS "\fBM_log_error_t\fP M_log_module_set_prefix (\fBM_log_t\fP * log, \fBM_log_module_t\fP * module, \fBM_log_prefix_cb\fP prefix_cb, void * prefix_thunk, \fBM_log_destroy_cb\fP thunk_destroy_cb)"
Associate a prefix callback with the given module handle\&.
.PP
The prefix callback allows the user to add a string between the timestamp and the body of the log message\&. If no prefix callback is provided, the default prefix of ': ' will be used\&. See \fBM_log_prefix_cb\fP for more details\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_log_prefix_cb\fP 
.PP
\fBM_log_set_time_format\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fImodule\fP handle of module to operate on 
.br
\fIprefix_cb\fP prefix callback (function pointer) 
.br
\fIprefix_thunk\fP any state used by prefix callback 
.br
\fIthunk_destroy_cb\fP function to call when destroying the prefix thunk 
.RE
.PP
\fBReturns:\fP
.RS 4
error code 
.RE
.PP

.SS "\fBM_log_error_t\fP M_log_module_set_filter (\fBM_log_t\fP * log, \fBM_log_module_t\fP * module, \fBM_log_filter_cb\fP filter_cb, void * filter_thunk, \fBM_log_destroy_cb\fP thunk_destroy_cb)"
Associate a filter callback with the given module handle\&.
.PP
The filter callback allows the user to reject additional log messages\&. It is applied after the messages are filtered according to the list of accepted tags set by \fBM_log_module_set_accepted_tags()\fP\&. If no filter callback is provided, no additional filtering beyond the list of accepted tags will be performed\&. See \fBM_log_filter_cb\fP for more details\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_log_filter_cb\fP 
.PP
\fBM_log_module_set_accepted_tags\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fImodule\fP handle of module to operate on 
.br
\fIfilter_cb\fP filter callback (function pointer) 
.br
\fIfilter_thunk\fP any state used by filter callback 
.br
\fIthunk_destroy_cb\fP function to call when destroying the filter thunk 
.RE
.PP
\fBReturns:\fP
.RS 4
error code 
.RE
.PP

.SS "\fBM_log_error_t\fP M_log_module_reopen (\fBM_log_t\fP * log, \fBM_log_module_t\fP * module)"
Trigger a disconnect/reconnect of the given module's internal resource\&.
.PP
The exact action taken by this command depends on the module\&. For example, the file module will close and reopen the internal connection to the main log file\&. Modules without closeable resources (like membuf and stream) treat this as a no-op\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_log_reopen_all\fP (if you want to reopen all modules in the logger)
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fImodule\fP handle of module to operate on 
.RE
.PP
\fBReturns:\fP
.RS 4
error code 
.RE
.PP

.SS "\fBM_log_error_t\fP M_log_module_remove (\fBM_log_t\fP * log, \fBM_log_module_t\fP * module)"
Remove a module from the running log and destroy it\&.
.PP
This function does not block\&. If the module is busy writing a message, it is removed from the list of active modules, and then it destroys itself asynchronously when the module is finished with its current chunk of work\&.
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fImodule\fP handle of module to destroy 
.RE
.PP
\fBReturns:\fP
.RS 4
error code 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
