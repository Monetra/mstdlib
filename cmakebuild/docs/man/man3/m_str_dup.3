.TH "m_str_dup" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_str_dup
.SH SYNOPSIS
.br
.PP
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_str_justify_type_t\fP { \fBM_STR_JUSTIFY_RIGHT\fP = 0, \fBM_STR_JUSTIFY_LEFT\fP = 1, \fBM_STR_JUSTIFY_RIGHT_TRUNC_RIGHT\fP = 2, \fBM_STR_JUSTIFY_LEFT_TRUNC_RIGHT\fP = 3, \fBM_STR_JUSTIFY_RIGHT_NOTRUNC\fP = 4, \fBM_STR_JUSTIFY_LEFT_NOTRUNC\fP = 5, \fBM_STR_JUSTIFY_TRUNC_RIGHT\fP = 6, \fBM_STR_JUSTIFY_TRUNC_LEFT\fP = 7, \fBM_STR_JUSTIFY_CENTER\fP = 8, \fBM_STR_JUSTIFY_CENTER_TRUNC_RIGHT\fP = 9, \fBM_STR_JUSTIFY_CENTER_NO_TRUNC\fP = 10, \fBM_STR_JUSTIFY_END\fP = 11 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "char * \fBM_strdup\fP (const char *s) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_strdup_upper\fP (const char *s) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_strdup_lower\fP (const char *s) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_strdup_trim\fP (const char *s) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_strdup_unquote\fP (const char *s, unsigned char quote, unsigned char escape) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_strdup_max\fP (const char *s, size_t max) M_ALLOC_SIZE(2) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_strdup_upper_max\fP (const char *s, size_t max) M_ALLOC_SIZE(2) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_strdup_lower_max\fP (const char *s, size_t max) M_ALLOC_SIZE(2) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_strdup_trim_max\fP (const char *s, size_t max) M_ALLOC_SIZE(2) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_strdup_unquote_max\fP (const char *s, unsigned char quote, unsigned char escape, size_t max) M_ALLOC_SIZE(2) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_strdup_justify\fP (const char *src, \fBM_str_justify_type_t\fP justtype, unsigned char justchar, size_t justlen) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_strdup_replace_charset\fP (const char *s, const unsigned char *bcs, size_t bcs_len, const char *a)"
.br
.ti -1c
.RI "char * \fBM_strdup_replace_str\fP (const char *s, const char *b, const char *a)"
.br
.in -1c
.SH "Detailed Description"
.PP 
String Manipulation (and Duplication) Functions 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_str_justify_type_t\fP"
Justify Flags 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_STR_JUSTIFY_RIGHT \fP\fP
Data is right-justified (padded on left)\&. If src exceeds justification length, it is truncated on the left 
.TP
\fB\fIM_STR_JUSTIFY_LEFT \fP\fP
Data is left-justified (padded on right)\&. If src exceeds justification length, it is truncated on the left 
.TP
\fB\fIM_STR_JUSTIFY_RIGHT_TRUNC_RIGHT \fP\fP
Data is right-justified (padded on left)\&. If src exceeds justification length, it is truncated on the right 
.TP
\fB\fIM_STR_JUSTIFY_LEFT_TRUNC_RIGHT \fP\fP
Data is left-justified (padded on right)\&. If src exceeds justification length, it is truncated on the right 
.TP
\fB\fIM_STR_JUSTIFY_RIGHT_NOTRUNC \fP\fP
Data is right-justified (padded on left)\&. If src exceeds justification length, destination is not written, error is returned 
.TP
\fB\fIM_STR_JUSTIFY_LEFT_NOTRUNC \fP\fP
Data is left-justified (padded on right)\&. If src exceeds justification length, destination is not written, error is returned 
.TP
\fB\fIM_STR_JUSTIFY_TRUNC_RIGHT \fP\fP
Data is truncated on the right if length is exceeded\&. No padding is performed 
.TP
\fB\fIM_STR_JUSTIFY_TRUNC_LEFT \fP\fP
Data is truncated on the left if length is exceeded\&. No padding is performed 
.TP
\fB\fIM_STR_JUSTIFY_CENTER \fP\fP
Data is center-justified (padded on left and right)\&. If src exceeds justification length, it is truncated on the left 
.TP
\fB\fIM_STR_JUSTIFY_CENTER_TRUNC_RIGHT \fP\fP
Data is center-justified (padded on left and right)\&. If src exceeds justification length, it is truncated on the right 
.TP
\fB\fIM_STR_JUSTIFY_CENTER_NO_TRUNC \fP\fP
Data is center-justified (padded on left and right)\&. If src exceeds justification length, destination is not writtern, error is returned 
.TP
\fB\fIM_STR_JUSTIFY_END \fP\fP
Non-used value that marks end of list\&. 
.SH "Function Documentation"
.PP 
.SS "char* M_strdup (const char * s)"
Create a duplicate of the NULL-terminated string s\&.
.PP
s must be passed to M_free to release the memory space associated with it\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
NULL when insufficient memory or s is NULL\&. Otherwise a NULL-terminated string\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_free\fP 
.RE
.PP

.SS "char* M_strdup_upper (const char * s)"
Create a duplicate of the NULL-terminated string s and additionally applies M_str_upper to the new string\&.
.PP
Later s can be passed to M_free to release the memory space associated with it\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
NULL when insufficient memory or s is NULL\&. Otherwise a NULL-terminated string\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_strdup\fP 
.PP
\fBM_str_upper\fP 
.PP
\fBM_free\fP 
.RE
.PP

.SS "char* M_strdup_lower (const char * s)"
Create a duplicate of the NULL-terminated string s and additionally applies M_str_lower to the new string\&.
.PP
s must be passed to M_free to release the memory space associated with it\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
NULL when insufficient memory or s is NULL\&. Otherwise a NULL-terminated string\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_strdup\fP 
.PP
\fBM_str_lower\fP 
.PP
\fBM_free\fP 
.RE
.PP

.SS "char* M_strdup_trim (const char * s)"
Create a duplicate of the NULL-terminated string s and additionally applies M_str_trim to the new string\&.
.PP
s must be passed to M_free to release the memory space associated with it\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
NULL when insufficient memory or s is NULL\&. Otherwise a NULL-terminated string\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_strdup\fP 
.PP
\fBM_str_trim\fP 
.PP
\fBM_free\fP 
.RE
.PP

.SS "char* M_strdup_unquote (const char * s, unsigned char quote, unsigned char escape)"
Create a duplicate of the NULL-terminated string s and additionally applies M_str_unquote to the new string\&.
.PP
s must be passed to M_free to release the memory space associated with it\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fIquote\fP Quote character that should be removed\&. 
.br
\fIescape\fP Character that escapes a quote that is within the quoted string\&.
.RE
.PP
\fBReturns:\fP
.RS 4
NULL when insufficient memory or s is NULL\&. Otherwise a NULL-terminated string\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_strdup\fP 
.PP
\fBM_str_unquote\fP 
.PP
\fBM_free\fP 
.RE
.PP

.SS "char* M_strdup_max (const char * s, size_t max)"
Create a duplicate of the NULL-terminated string s, but copy at most max bytes\&.
.PP
If s is longer than max, only max bytes are copied\&. The returned string will always be NULL-terminated\&.
.PP
s must be passed to M_free to release the memory space associated with it\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string (or up to max bytes of s)\&. 
.br
\fImax\fP Maximum number of bytes to copy from s\&.
.RE
.PP
\fBReturns:\fP
.RS 4
NULL when insufficient memory or s is NULL\&. Otherwise a NULL-terminated substring s[0\&.\&.MAX(max-1,strlen(s))]\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_free\fP 
.RE
.PP

.SS "char* M_strdup_upper_max (const char * s, size_t max)"
Create a duplicate of the NULL-terminated string s, but copy at most max bytes and additionally applies M_str_lower_max to the new string\&.
.PP
If s is longer than max, only max bytes are copied\&. The returned string will always be NULL-terminated\&.
.PP
s must be passed to M_free to release the memory space associated with it\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string (or up to max bytes of s)\&. 
.br
\fImax\fP Maximum number of bytes to copy from s\&.
.RE
.PP
\fBReturns:\fP
.RS 4
NULL when insufficient memory or s is NULL\&. Otherwise a NULL-terminated substring s[0\&.\&.MAX(max-1,strlen(s))]\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_strdup_max\fP 
.PP
\fBM_str_upper_max\fP 
.PP
\fBM_free\fP 
.RE
.PP

.SS "char* M_strdup_lower_max (const char * s, size_t max)"
Create a duplicate of the NULL-terminated string s, but copy at most max bytes and additionally applies M_str_lower_max to the new string\&.
.PP
If s is longer than max, only max bytes are copied\&. The returned string will always be NULL-terminated\&.
.PP
s must be passed to M_free to release the memory space associated with it\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string (or up to max bytes of s)\&. 
.br
\fImax\fP Maximum number of bytes to copy from s\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_strdup_max\fP 
.PP
\fBM_str_lower_max\fP 
.PP
\fBM_free\fP 
.RE
.PP

.SS "char* M_strdup_trim_max (const char * s, size_t max)"
Create a duplicate of the NULL-terminated string s, but copy at most max bytes and additionally applies M_str_trim_max to the new string\&.
.PP
If s is longer than max, only max bytes are copied\&. The returned string will always be NULL-terminated\&.
.PP
s must be passed to M_free to release the memory space associated with it\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string (or up to max bytes of s)\&. 
.br
\fImax\fP Maximum number of bytes to copy from s\&.
.RE
.PP
\fBReturns:\fP
.RS 4
NULL when insufficient memory or s is NULL\&. Otherwise a NULL-terminated substring s[0\&.\&.MAX(max-1,strlen(s))]\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_strdup_max\fP 
.PP
\fBM_str_trim_max\fP 
.PP
\fBM_free\fP 
.RE
.PP

.SS "char* M_strdup_unquote_max (const char * s, unsigned char quote, unsigned char escape, size_t max)"
Create a duplicate of the NULL-terminated string s, but copy at most max bytes and additionally applies M_str_unquote_max to the new string\&.
.PP
If s is longer than max, only max bytes are copied\&. The returned string will always be NULL-terminated\&.
.PP
s must be passed to M_free to release the memory space associated with it\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string (or up to max bytes of s)\&. 
.br
\fIquote\fP Quote character that should be removed\&. 
.br
\fIescape\fP Character that escapes a quote that is within the quoted string\&. 
.br
\fImax\fP Maximum number of bytes to copy from s\&.
.RE
.PP
\fBReturns:\fP
.RS 4
NULL when insufficient memory or s is NULL\&. Otherwise a NULL-terminated substring s[0\&.\&.MAX(max-1,strlen(s))]\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_strdup_max\fP 
.PP
\fBM_free\fP 
.RE
.PP

.SS "char* M_strdup_justify (const char * src, \fBM_str_justify_type_t\fP justtype, unsigned char justchar, size_t justlen)"
Justifies the input source as specified by the parameters and writes it to a new duplicate string\&.
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP Null-terminated input string to be justified\&. 
.br
\fIjusttype\fP Type of justification to be performed\&. 
.br
\fIjustchar\fP Character to use as padding/filler for justification\&. (ignored if M_JUSTIFY_TRUNC_RIGHT or M_JUSTIFY_TRUNC_LEFT) 
.br
\fIjustlen\fP Length requested for justification (or truncation)\&.
.RE
.PP
\fBReturns:\fP
.RS 4
NULL on error (such as if it would truncate when requested not to, or invalid use)\&. New null-terminated string containing justified output on success\&. 
.RE
.PP

.SS "char* M_strdup_replace_charset (const char * s, const unsigned char * bcs, size_t bcs_len, const char * a)"
Replace a all characters matching a given character set with a string\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fIbcs\fP Character set\&. 
.br
\fIbcs_len\fP Number of characters in the given set\&. 
.br
\fIa\fP Replacement string for every character in the character set\&.
.RE
.PP
\fBReturns:\fP
.RS 4
NULL terminated string on success, Otherwise NULL\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_str_replace_chr\fP 
.PP
\fBM_strdup_replace_str\fP 
.RE
.PP

.SS "char* M_strdup_replace_str (const char * s, const char * b, const char * a)"
Replace a string with another string\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP NULL-terminated string\&. 
.br
\fIb\fP NULL-terminated string to replace\&. 
.br
\fIa\fP NULL-terminated string o replace with\&. b is replaced with a\&.
.RE
.PP
\fBReturns:\fP
.RS 4
NULL terminated string on success, Otherwise NULL\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_str_replace_chr\fP 
.PP
\fBM_strdup_replace_charset\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
