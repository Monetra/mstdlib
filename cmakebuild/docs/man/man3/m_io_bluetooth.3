.TH "m_io_bluetooth" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_io_bluetooth
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBM_io_bluetooth_enum\fP \fBM_io_bluetooth_enum_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_io_bluetooth_enum_t\fP * \fBM_io_bluetooth_enum\fP (void)"
.br
.ti -1c
.RI "void \fBM_io_bluetooth_enum_destroy\fP (\fBM_io_bluetooth_enum_t\fP *btenum)"
.br
.ti -1c
.RI "size_t \fBM_io_bluetooth_enum_count\fP (const \fBM_io_bluetooth_enum_t\fP *btenum)"
.br
.ti -1c
.RI "const char * \fBM_io_bluetooth_enum_name\fP (const \fBM_io_bluetooth_enum_t\fP *btenum, size_t idx)"
.br
.ti -1c
.RI "const char * \fBM_io_bluetooth_enum_mac\fP (const \fBM_io_bluetooth_enum_t\fP *btenum, size_t idx)"
.br
.ti -1c
.RI "M_bool \fBM_io_bluetooth_enum_connected\fP (const \fBM_io_bluetooth_enum_t\fP *btenum, size_t idx)"
.br
.ti -1c
.RI "const char * \fBM_io_bluetooth_enum_service_name\fP (const \fBM_io_bluetooth_enum_t\fP *btenum, size_t idx)"
.br
.ti -1c
.RI "const char * \fBM_io_bluetooth_enum_service_uuid\fP (const \fBM_io_bluetooth_enum_t\fP *btenum, size_t idx)"
.br
.ti -1c
.RI "\fBM_io_error_t\fP \fBM_io_bluetooth_create\fP (\fBM_io_t\fP **io_out, const char *mac, const char *uuid)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Bluetooth IO functions\&.
.PP
This is a connectivity layer and uses rfcomm\&. Protocols, such as AVDTP, should be implemented at a layer above this one\&. The generic rfcomm uuid that the vast majority of devices use is 00001101-0000-1000-8000-00805f9b34fb\&.
.PP
Supported OS:
.IP "\(bu" 2
Android
.IP "\(bu" 2
macOS 
.PP

.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBM_io_bluetooth_enum\fP \fBM_io_bluetooth_enum_t\fP"

.SH "Function Documentation"
.PP 
.SS "\fBM_io_bluetooth_enum_t\fP* M_io_bluetooth_enum (void)"
Create a bluetooth enumeration object\&.
.PP
Use to determine what bluetooth devices are connected and what services are being offered\&. This is a list of associated devices not necessarily what's actively connected\&.
.PP
The enumeration is based on available services\&. Meaning a device may be listed multiple times if it exposes multiple services\&.
.PP
\fBReturns:\fP
.RS 4
Bluetooth enumeration object\&. 
.RE
.PP

.SS "void M_io_bluetooth_enum_destroy (\fBM_io_bluetooth_enum_t\fP * btenum)"
Destroy a bluetooth enumeration object\&.
.PP
\fBParameters:\fP
.RS 4
\fIbtenum\fP Bluetooth enumeration object\&. 
.RE
.PP

.SS "size_t M_io_bluetooth_enum_count (const \fBM_io_bluetooth_enum_t\fP * btenum)"
Number of bluetooth objects in the enumeration\&.
.PP
\fBParameters:\fP
.RS 4
\fIbtenum\fP Bluetooth enumeration object\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Count of bluetooth devices\&. 
.RE
.PP

.SS "const char* M_io_bluetooth_enum_name (const \fBM_io_bluetooth_enum_t\fP * btenum, size_t idx)"
Name of bluetooth device as reported by the device\&.
.PP
\fBParameters:\fP
.RS 4
\fIbtenum\fP Bluetooth enumeration object\&. 
.br
\fIidx\fP Index in bluetooth enumeration\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "const char* M_io_bluetooth_enum_mac (const \fBM_io_bluetooth_enum_t\fP * btenum, size_t idx)"
MAC of bluetooth device\&.
.PP
\fBParameters:\fP
.RS 4
\fIbtenum\fP Bluetooth enumeration object\&. 
.br
\fIidx\fP Index in bluetooth enumeration\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "M_bool M_io_bluetooth_enum_connected (const \fBM_io_bluetooth_enum_t\fP * btenum, size_t idx)"
Whether the device is connected\&.
.PP
Not all systems are able to report the connected status making this function less useful than you would think\&.
.PP
\fBReturns:\fP
.RS 4
M_TRUE if the device is connected, otherwise M_FALSE\&. If it is not possible to determine the connected status this function will return M_TRUE\&. 
.RE
.PP

.SS "const char* M_io_bluetooth_enum_service_name (const \fBM_io_bluetooth_enum_t\fP * btenum, size_t idx)"
Name of service reported by device\&.
.PP
\fBParameters:\fP
.RS 4
\fIbtenum\fP Bluetooth enumeration object\&. 
.br
\fIidx\fP Index in bluetooth enumeration\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "const char* M_io_bluetooth_enum_service_uuid (const \fBM_io_bluetooth_enum_t\fP * btenum, size_t idx)"
Uuid of service reported by device\&.
.PP
\fBParameters:\fP
.RS 4
\fIbtenum\fP Bluetooth enumeration object\&. 
.br
\fIidx\fP Index in bluetooth enumeration\&.
.RE
.PP
\fBReturns:\fP
.RS 4
String\&. 
.RE
.PP

.SS "\fBM_io_error_t\fP M_io_bluetooth_create (\fBM_io_t\fP ** io_out, const char * mac, const char * uuid)"
Create a bluetooth connection\&.
.PP
\fBParameters:\fP
.RS 4
\fIio_out\fP io object for communication\&. 
.br
\fImac\fP Required MAC of the device\&. 
.br
\fIuuid\fP Optional UUID of the device\&. For rfcomm (used by this io interface) the uuid is almost always 00001101-0000-1000-8000-00805f9b34fb unless the device is providing multiple services\&. Such as a device that can do multiple things like bar code scanner, and integrated printer\&. If not specified the generic rfcomm generic uuid will be used\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
