.TH "m_fmt" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_fmt
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "ssize_t \fBM_vfprintf\fP (FILE *stream, const char *fmt, va_list ap)"
.br
.ti -1c
.RI "ssize_t \fBM_fprintf\fP (FILE *stream, const char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "ssize_t \fBM_vmdprintf\fP (\fBM_fs_file_t\fP *fd, const char *fmt, va_list ap)"
.br
.ti -1c
.RI "ssize_t \fBM_mdprintf\fP (\fBM_fs_file_t\fP *fd, const char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "ssize_t \fBM_vdprintf\fP (int fd, const char *fmt, va_list ap)"
.br
.ti -1c
.RI "ssize_t \fBM_dprintf\fP (int fd, const char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "ssize_t \fBM_vprintf\fP (const char *fmt, va_list ap)"
.br
.ti -1c
.RI "ssize_t \fBM_printf\fP (const char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "size_t \fBM_vsnprintf\fP (char *str, size_t size, const char *fmt, va_list ap)"
.br
.ti -1c
.RI "size_t \fBM_snprintf\fP (char *buf, size_t size, const char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "size_t \fBM_vasprintf\fP (char **ret, const char *fmt, va_list ap)"
.br
.ti -1c
.RI "size_t \fBM_asprintf\fP (char **ret, const char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "size_t \fBM_vbprintf\fP (\fBM_buf_t\fP *buf, const char *fmt, va_list ap)"
.br
.ti -1c
.RI "size_t \fBM_bprintf\fP (\fBM_buf_t\fP *buf, const char *fmt,\&.\&.\&.)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Formatted String output\&.
.PP
%<character> is used to denote the data type of the argument\&. Arguments are passed after the format string\&.
.PP
.SH "Supported features"
.PP
.PP
.SS "Flags"
.PP
Flag Description  '-' Left justify output\&. Default is to right justify\&. Overrides the '0' flag if both are set\&. '+' Always add the sign for numeric output\&. Default is only to add sign for negative\&. Overrides the ' ' flag if both are set\&. '#' Add the appropriate prefix to the output of numerics\&. 0x or 0X for Hex\&. 0 for Octal\&. ' ' Use a space as if it were the sign for positive numbers\&. '0' Pad numerics with 0\&. Default padding is space (' ')\&. 
.SS "Width and precision"
.PP
A decimal (\&.) separated value with each side is option can be specified, <width>\&.<precision>\&.
.PP
The width is the minimum output size\&. Padding will be added if the output would be smaller than the width\&. If the output size exceeds the width the width is ignored and the full output will be used\&.
.PP
Precision for strings is how much to read of the string\&. If the value is larger than the length of the string, the string length will be used\&. E\&.g\&. ('%\&.2s', 'abc') will result in 'ab' for the output\&.
.PP
Precision for floating point determines the number of decimal places to output\&. The default is 6\&. It's recommended the maximum precision specified be no large than 14 digits\&. Digits over 14 can have platform specific rounding differences\&.
.PP
If either or both sides of the decimal do not have a value the side is ignored\&. This allows any combination of width and precision to be specified\&.
.PP
A '*' can be specified for either which will read the value from an argument\&. The argument is an int\&. The arguments are read right to left\&. E\&.g\&. ('%*\&.*s', 4, 2, 'abc') will result in '  ab'\&.
.PP
.SS "Size modifiers"
.PP
Specify the data size of a given argument\&.
.PP
Modifier Description  hh Size of char\&. 8 bit\&. h Size of short\&. 16 bit\&. l Size of long\&. 8 or 16 bit (system dependant)\&. ll Size of long long\&. 64 bit\&. I, z size of size_t\&. Based on system size\&. 32 or 64 bit\&. I64 64 bit\&. I32 32 bit\&. 
.SS "Conversion"
.PP
Specifies the data type of the argument\&.
.PP
Type Description  d, i Signed integer\&. o, O Unsigned integer\&. Output as octal\&. u Unsigned integer\&. x, X Unsigned integer\&. Output as hex\&. 'x' outputs lowercase, 'X' outputs uppercase\&. P, P Unsigned pointer\&. Output as hex\&. 'x' outputs lowercase, 'X' outputs uppercase\&. e, E, f, F, g, G Double\&. All will output in the form [-]ddd\&.ddd\&. Default 6 decimal digits unless otherwise precision is otherwise specified\&. c signed character\&. s Strong (const char *)\&. 
.SH "Function Documentation"
.PP 
.SS "ssize_t M_vfprintf (FILE * stream, const char * fmt, va_list ap)"
Output format string to FILE\&.
.PP
\fBParameters:\fP
.RS 4
\fIstream\fP FILE stream\&. 
.br
\fIfmt\fP Format string\&. 
.br
\fIap\fP arguments\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Number of characters output\&. -1 on fatal error\&. 
.RE
.PP

.SS "ssize_t M_fprintf (FILE * stream, const char * fmt,  \&.\&.\&.)"
Output format string to FILE (varargs)\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_vfprintf\fP 
.RE
.PP

.SS "ssize_t M_vmdprintf (\fBM_fs_file_t\fP * fd, const char * fmt, va_list ap)"
Output format string to mstdlib file descriptor\&.
.PP
\fBParameters:\fP
.RS 4
\fIfd\fP mstdlib file descriptor\&. 
.br
\fIfmt\fP Format string\&. 
.br
\fIap\fP arguments\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Number of characters output\&. -1 on fatal error\&. 
.RE
.PP

.SS "ssize_t M_mdprintf (\fBM_fs_file_t\fP * fd, const char * fmt,  \&.\&.\&.)"
Output format string to mstdlib file descriptor (varargs)\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_vmdprintf\fP 
.RE
.PP

.SS "ssize_t M_vdprintf (int fd, const char * fmt, va_list ap)"
Output format string to OS file descriptor\&.
.PP
\fBParameters:\fP
.RS 4
\fIfd\fP OS file descriptor\&. 
.br
\fIfmt\fP Format string\&. 
.br
\fIap\fP arguments\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Number of characters output\&. -1 on fatal error\&. 
.RE
.PP

.SS "ssize_t M_dprintf (int fd, const char * fmt,  \&.\&.\&.)"
Output format string to OS file descriptor (varargs)\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_vdprintf\fP 
.RE
.PP

.SS "ssize_t M_vprintf (const char * fmt, va_list ap)"
Output format string to stdout\&.
.PP
\fBParameters:\fP
.RS 4
\fIfmt\fP Format string\&. 
.br
\fIap\fP arguments\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Number of characters output\&. -1 on fatal error\&. 
.RE
.PP

.SS "ssize_t M_printf (const char * fmt,  \&.\&.\&.)"
Output format string to stdout (varargs)\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_vprintf\fP 
.RE
.PP

.SS "size_t M_vsnprintf (char * str, size_t size, const char * fmt, va_list ap)"
Output format string to pre-allocated string buffer\&.
.PP
Output is NULL terminated\&.
.PP
The output will not exceed size of buffer - 1\&. 1 byte is reserved for the NULL terminator\&.
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP Storage location for string\&. 
.br
\fIsize\fP Size of location\&. 
.br
\fIfmt\fP Format string\&. 
.br
\fIap\fP arguments\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The length of the fully formatted string\&. If the size of the buffer is smaller than the length the string is truncated but the returned length is not\&. To determine truncation check is this return against the str buffer\&. 
.RE
.PP

.SS "size_t M_snprintf (char * buf, size_t size, const char * fmt,  \&.\&.\&.)"
Output format string to pre-allocated string buffer\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_vsnprintf\fP 
.RE
.PP

.SS "size_t M_vasprintf (char ** ret, const char * fmt, va_list ap)"
Output format string to a newly allocated string buffer\&.
.PP
Output is NULL terminated\&.
.PP
\fBParameters:\fP
.RS 4
\fIret\fP Allocated string\&. 
.br
\fIfmt\fP Format string\&. 
.br
\fIap\fP arguments\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Number of characters output\&. 
.RE
.PP

.SS "size_t M_asprintf (char ** ret, const char * fmt,  \&.\&.\&.)"
Output format string to a newly allocated string buffer (varargs)\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_vasprintf\fP 
.RE
.PP

.SS "size_t M_vbprintf (\fBM_buf_t\fP * buf, const char * fmt, va_list ap)"
Output format string to an M_buf buffer\&.
.PP
Output is NULL terminated\&.
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP Buffer 
.br
\fIfmt\fP Format string\&. 
.br
\fIap\fP arguments\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Number of characters output\&. 
.RE
.PP

.SS "size_t M_bprintf (\fBM_buf_t\fP * buf, const char * fmt,  \&.\&.\&.)"
Output format string to an M_buf buffer\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_vbprintf\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
