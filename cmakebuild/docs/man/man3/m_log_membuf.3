.TH "m_log_membuf" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_log_membuf
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_log_error_t\fP \fBM_log_module_add_membuf\fP (\fBM_log_t\fP *log, size_t buf_size, M_uint64 buf_time_s, \fBM_log_expire_cb\fP expire_cb, void *expire_thunk, \fBM_log_module_t\fP **out_mod)"
.br
.ti -1c
.RI "\fBM_log_error_t\fP \fBM_log_module_take_membuf\fP (\fBM_log_t\fP *log, \fBM_log_module_t\fP *module, \fBM_buf_t\fP **out_buf)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Functions to enable logging sensitive data to a temporary memory buffer\&.
.PP
Membuf modules only accept messages until they are full, then they stop accepting messages and hang out in memory until they're either explicitly retrieved by the caller with \fBM_log_module_take_membuf()\fP, or they reach their expiration time and are automatically destroyed\&. 
.SH "Function Documentation"
.PP 
.SS "\fBM_log_error_t\fP M_log_module_add_membuf (\fBM_log_t\fP * log, size_t buf_size, M_uint64 buf_time_s, \fBM_log_expire_cb\fP expire_cb, void * expire_thunk, \fBM_log_module_t\fP ** out_mod)"
Add a module to output to a buffer in memory\&.
.PP
This is intended for temporary, in-memory storage of sensitive data that can't be stored long-term\&.
.PP
Messages are accepted from the time the buffer is added, until the buffer is full\&. After that, no new messages are stored, and the contents are preserved until either the module is removed, or the expiration time is reached\&.
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fIbuf_size\fP max size (in bytes) of memory buffer 
.br
\fIbuf_time_s\fP max time (in seconds) to allow buffer to exist in memory before it's automatically deleted 
.br
\fIexpire_cb\fP callback to call when a memory buffer is automatically deleted 
.br
\fIexpire_thunk\fP any state used by the expire callback (not owned by log, you must delete it yourself) 
.br
\fIout_mod\fP handle for created module, or \fCNULL\fP if there was an error 
.RE
.PP
\fBReturns:\fP
.RS 4
error code 
.RE
.PP

.SS "\fBM_log_error_t\fP M_log_module_take_membuf (\fBM_log_t\fP * log, \fBM_log_module_t\fP * module, \fBM_buf_t\fP ** out_buf)"
Remove a membuf module from the log and return the internal memory store\&.
.PP
This method should be used if you need to preserve the data stored in the buffer\&. If you just want to remove the module and you don't care about the memory buffer contents, you should call the normal \fBM_log_module_remove()\fP function instead\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_log_module_remove\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlog\fP logger object 
.br
\fImodule\fP handle of module to operate on 
.br
\fIout_buf\fP buffer containing membuf data, or \fCNULL\fP if there was an error 
.RE
.PP
\fBReturns:\fP
.RS 4
error code 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
