.TH "m_xml" 3 "Tue Feb 20 2018" "Mstdlib-1.0.0" \" -*- nroff -*-
.ad l
.nh
.SH NAME
m_xml
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct M_xml_node \fBM_xml_node_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBM_xml_node_type_t\fP { \fBM_XML_NODE_TYPE_UNKNOWN\fP = 0, \fBM_XML_NODE_TYPE_DOC\fP = 1, \fBM_XML_NODE_TYPE_ELEMENT\fP = 2, \fBM_XML_NODE_TYPE_TEXT\fP = 3, \fBM_XML_NODE_TYPE_PROCESSING_INSTRUCTION\fP = 4, \fBM_XML_NODE_TYPE_DECLARATION\fP = 5, \fBM_XML_NODE_TYPE_COMMENT\fP = 6 }"
.br
.ti -1c
.RI "enum \fBM_xml_reader_flags_t\fP { \fBM_XML_READER_NONE\fP = 0, \fBM_XML_READER_IGNORE_COMMENTS\fP = 1 << 0, \fBM_XML_READER_TAG_CASECMP\fP = 1 << 1, \fBM_XML_READER_DONT_DECODE_TEXT\fP = 1 << 2, \fBM_XML_READER_DONT_DECODE_ATTRS\fP = 1 << 3 }"
.br
.ti -1c
.RI "enum \fBM_xml_writer_flags_t\fP { \fBM_XML_WRITER_NONE\fP = 0, \fBM_XML_WRITER_IGNORE_COMMENTS\fP = 1 << 0, \fBM_XML_WRITER_LOWER_TAGS\fP = 1 << 1, \fBM_XML_WRITER_LOWER_ATTRS\fP = 1 << 2, \fBM_XML_WRITER_DONT_ENCODE_TEXT\fP = 1 << 3, \fBM_XML_WRITER_DONT_ENCODE_ATTRS\fP = 1 << 4, \fBM_XML_WRITER_PRETTYPRINT_SPACE\fP = 1 << 5, \fBM_XML_WRITER_PRETTYPRINT_TAB\fP = 1 << 6, \fBM_XML_WRITER_SELFCLOSE_SPACE\fP = 1 << 7 }"
.br
.ti -1c
.RI "enum \fBM_xml_error_t\fP { \fBM_XML_ERROR_SUCCESS\fP = 0, \fBM_XML_ERROR_GENERIC\fP, \fBM_XML_ERROR_MISUSE\fP, \fBM_XML_ERROR_ATTR_EXISTS\fP, \fBM_XML_ERROR_NO_ELEMENTS\fP, \fBM_XML_ERROR_INVALID_START_TAG\fP, \fBM_XML_ERROR_INVALID_CHAR_IN_START_TAG\fP, \fBM_XML_ERROR_EMPTY_START_TAG\fP, \fBM_XML_ERROR_MISSING_DECLARATION_NAME\fP, \fBM_XML_ERROR_INELIGIBLE_FOR_CLOSE\fP, \fBM_XML_ERROR_UNEXPECTED_CLOSE\fP, \fBM_XML_ERROR_MISSING_CLOSE_TAG\fP, \fBM_XML_ERROR_MISSING_PROCESSING_INSTRUCTION_END\fP, \fBM_XML_ERROR_EXPECTED_END\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBM_xml_node_t\fP * \fBM_xml_create_doc\fP (void) M_MALLOC"
.br
.ti -1c
.RI "\fBM_xml_node_t\fP * \fBM_xml_create_element\fP (const char *name, \fBM_xml_node_t\fP *parent) M_MALLOC"
.br
.ti -1c
.RI "\fBM_xml_node_t\fP * \fBM_xml_create_element_with_text\fP (const char *name, const char *text, size_t max_len, \fBM_xml_node_t\fP *parent) M_MALLOC"
.br
.ti -1c
.RI "\fBM_xml_node_t\fP * \fBM_xml_create_text\fP (const char *text, size_t max_len, \fBM_xml_node_t\fP *parent) M_MALLOC"
.br
.ti -1c
.RI "\fBM_xml_node_t\fP * \fBM_xml_create_xml_declaration\fP (const char *encoding, \fBM_xml_node_t\fP *parent) M_MALLOC"
.br
.ti -1c
.RI "\fBM_xml_node_t\fP * \fBM_xml_create_declaration\fP (const char *name, \fBM_xml_node_t\fP *parent) M_MALLOC"
.br
.ti -1c
.RI "\fBM_xml_node_t\fP * \fBM_xml_create_declaration_with_tag_data\fP (const char *name, const char *data, \fBM_xml_node_t\fP *parent) M_MALLOC"
.br
.ti -1c
.RI "\fBM_xml_node_t\fP * \fBM_xml_create_processing_instruction\fP (const char *name, \fBM_xml_node_t\fP *parent) M_MALLOC"
.br
.ti -1c
.RI "\fBM_xml_node_t\fP * \fBM_xml_create_comment\fP (const char *comment, \fBM_xml_node_t\fP *parent) M_MALLOC"
.br
.ti -1c
.RI "void \fBM_xml_node_destroy\fP (\fBM_xml_node_t\fP *node) M_FREE(1)"
.br
.ti -1c
.RI "\fBM_xml_node_t\fP * \fBM_xml_read\fP (const char *data, size_t data_len, M_uint32 flags, size_t *processed_len, \fBM_xml_error_t\fP *error, size_t *error_line, size_t *error_pos) M_MALLOC"
.br
.ti -1c
.RI "\fBM_xml_node_t\fP * \fBM_xml_read_file\fP (const char *path, M_uint32 flags, size_t max_read, \fBM_xml_error_t\fP *error, size_t *error_line, size_t *error_pos) M_MALLOC"
.br
.ti -1c
.RI "char * \fBM_xml_write\fP (const \fBM_xml_node_t\fP *node, M_uint32 flags, size_t *len) M_WARN_UNUSED_RESULT M_MALLOC"
.br
.ti -1c
.RI "\fBM_fs_error_t\fP \fBM_xml_write_file\fP (const \fBM_xml_node_t\fP *node, const char *path, M_uint32 flags)"
.br
.ti -1c
.RI "\fBM_xml_node_type_t\fP \fBM_xml_node_type\fP (const \fBM_xml_node_t\fP *node)"
.br
.ti -1c
.RI "\fBM_xml_node_t\fP ** \fBM_xml_xpath\fP (\fBM_xml_node_t\fP *node, const char *search, M_uint32 flags, size_t *num_matches) M_MALLOC"
.br
.ti -1c
.RI "const char * \fBM_xml_xpath_text_first\fP (\fBM_xml_node_t\fP *node, const char *search)"
.br
.ti -1c
.RI "\fBM_xml_node_t\fP * \fBM_xml_node_parent\fP (const \fBM_xml_node_t\fP *node)"
.br
.ti -1c
.RI "void \fBM_xml_take_from_parent\fP (\fBM_xml_node_t\fP *node)"
.br
.ti -1c
.RI "M_bool \fBM_xml_node_insert_node\fP (\fBM_xml_node_t\fP *parent, \fBM_xml_node_t\fP *child)"
.br
.ti -1c
.RI "M_bool \fBM_xml_node_insert_node_at\fP (\fBM_xml_node_t\fP *parent, \fBM_xml_node_t\fP *child, size_t idx)"
.br
.ti -1c
.RI "size_t \fBM_xml_node_num_children\fP (const \fBM_xml_node_t\fP *node)"
.br
.ti -1c
.RI "\fBM_xml_node_t\fP * \fBM_xml_node_child\fP (const \fBM_xml_node_t\fP *node, size_t idx)"
.br
.ti -1c
.RI "\fBM_xml_node_t\fP * \fBM_xml_node_sibling\fP (const \fBM_xml_node_t\fP *node, M_bool after)"
.br
.ti -1c
.RI "M_bool \fBM_xml_node_set_name\fP (\fBM_xml_node_t\fP *node, const char *name)"
.br
.ti -1c
.RI "const char * \fBM_xml_node_name\fP (const \fBM_xml_node_t\fP *node)"
.br
.ti -1c
.RI "M_bool \fBM_xml_node_set_text\fP (\fBM_xml_node_t\fP *node, const char *text, size_t max_len)"
.br
.ti -1c
.RI "const char * \fBM_xml_node_text\fP (const \fBM_xml_node_t\fP *node)"
.br
.ti -1c
.RI "M_bool \fBM_xml_node_set_tag_data\fP (\fBM_xml_node_t\fP *node, const char *data)"
.br
.ti -1c
.RI "const char * \fBM_xml_node_tag_data\fP (const \fBM_xml_node_t\fP *node)"
.br
.ti -1c
.RI "M_bool \fBM_xml_node_insert_attribute\fP (\fBM_xml_node_t\fP *node, const char *key, const char *val, size_t max_len, M_bool overwrite)"
.br
.ti -1c
.RI "M_bool \fBM_xml_node_remove_attribute\fP (\fBM_xml_node_t\fP *node, const char *key)"
.br
.ti -1c
.RI "\fBM_list_str_t\fP * \fBM_xml_node_attribute_keys\fP (const \fBM_xml_node_t\fP *node) M_MALLOC"
.br
.ti -1c
.RI "const \fBM_hash_dict_t\fP * \fBM_xml_node_attributes\fP (const \fBM_xml_node_t\fP *node)"
.br
.ti -1c
.RI "const char * \fBM_xml_node_attribute\fP (const \fBM_xml_node_t\fP *node, const char *key)"
.br
.in -1c
.SH "Detailed Description"
.PP 
DOM based XML data processing\&.
.PP
This is a simple API for reading, creating, manipulating, searching, and writing XML data\&.
.PP
It is possible to construct an invalid XML document\&. It is also possible that an invalid XML document created with M_xml will not be readable by M_xml\&. Specifically, when dealing with attribute and text encoding options for M_xml_read and M_xml_write\&. Also, attribute keys and tag names are not validated to ensure they are valid XML names\&. This must happen outside of M_xml\&.
.PP
M_xml is not susceptible to common XML entity expansion attaches such as billion laughs, quadratic blowup, and external entity expansion\&. Only basic XML entities are expanded and only one level is expanded\&. Further external entity references are not downloaded\&. Neither are external DTDs\&. This will mitigate against network based attacks relying on retrieval\&.
.PP
Example:
.PP
.PP
.nf
M_xml_node_t *xml;
const char   *data = "<r><tag1>abc</tag1><tag2>123</tag2><tag3>xyz</tag3></r>";
char         *out;

xml = M_xml_read(data, M_str_len(data), M_XML_READER_NONE, NULL, NULL, NULL);
if (xml == NULL) {
    M_printf("xml parse error\n");
    return M_FALSE;
}

M_xml_create_element_with_text("AbCd", "blah blah blah", 0, xml);

out = M_xml_write(xml, M_XML_WRITER_LOWER_TAGS|M_XML_WRITER_LOWER_ATTRS|M_XML_WRITER_PRETTYPRINT_SPACE, NULL);
M_printf("out=\n%s\n", out);
M_free(out);
.fi
.PP
 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct M_xml_node \fBM_xml_node_t\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBM_xml_node_type_t\fP"
Node types in our XML tree structure 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_XML_NODE_TYPE_UNKNOWN \fP\fP
An invalid node type\&. 
.TP
\fB\fIM_XML_NODE_TYPE_DOC \fP\fP
The base of every XML tree and provides access to the documents data\&. Supports: Nodes\&. Does not support: Name, Attributes, Text, Tag data\&. 
.TP
\fB\fIM_XML_NODE_TYPE_ELEMENT \fP\fP
Element (tag)\&. E\&.g:
.PP
.nf
<name key="val" />, <name>\&.\&.\&.</name>

.fi
.PP
\&. Supports: Attributes, Nodes, Name\&. Does not support: Text, Tag data\&. 
.TP
\fB\fIM_XML_NODE_TYPE_TEXT \fP\fP
Text\&. E\&.g: abc\&. Supports: Text\&. Does not support: Nodes, Name, Attributes, Tag data\&. 
.TP
\fB\fIM_XML_NODE_TYPE_PROCESSING_INSTRUCTION \fP\fP
Conveys information\&. E\&.g:
.PP
.nf
<?xml version="1\&.0" encoding="UTF-8" ?>

.fi
.PP
 Supports: Name, Attributes, Tag data\&. Does not support: Nodes, Text\&. 
.TP
\fB\fIM_XML_NODE_TYPE_DECLARATION \fP\fP
HTML/DTD declaration\&. E\&.g:
.PP
.nf
<!DOCTYPE html>, <!ELEMENT element-name category>, <!ATTLIST payment type CDATA "check">

.fi
.PP
 Supports: Name, Tag data\&. Does not support: Nodes, Attributes, text\&. 
.TP
\fB\fIM_XML_NODE_TYPE_COMMENT \fP\fP
Comment\&. E\&.g:
.PP
.nf
<!-- comment -->

.fi
.PP
 Supports: Tag data\&. Does not support: Nodes, Name, Attributes, Text\&. 
.SS "enum \fBM_xml_reader_flags_t\fP"
Flags to control the behavior of the XML writer\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_XML_READER_NONE \fP\fP
Normal operation\&. 
.TP
\fB\fIM_XML_READER_IGNORE_COMMENTS \fP\fP
Don't include comments as part of the output during parse\&. 
.TP
\fB\fIM_XML_READER_TAG_CASECMP \fP\fP
Compare open and close tags case insensitive\&. 
.TP
\fB\fIM_XML_READER_DONT_DECODE_TEXT \fP\fP
By default text data will be xml entity decoded\&. This prevents the decode from taking place\&. It should be paired with the equivalent don't encode option when writing\&. 
.TP
\fB\fIM_XML_READER_DONT_DECODE_ATTRS \fP\fP
By default attribute values will be attribute entity decoded\&. This prevents the decode from taking place\&. It should be paired with the equivalent don't encode option when writing\&. 
.SS "enum \fBM_xml_writer_flags_t\fP"
Flags to control the behavior of the XML reader\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_XML_WRITER_NONE \fP\fP
No indent\&. All data on a single line\&. 
.TP
\fB\fIM_XML_WRITER_IGNORE_COMMENTS \fP\fP
Comments are not included\&. 
.TP
\fB\fIM_XML_WRITER_LOWER_TAGS \fP\fP
All tags are written lower case\&. 
.TP
\fB\fIM_XML_WRITER_LOWER_ATTRS \fP\fP
All attribute keys are written lower case\&. 
.TP
\fB\fIM_XML_WRITER_DONT_ENCODE_TEXT \fP\fP
By default text data will be xml entity encoded\&. This prevents the encode from taking place\&. It should be paired with the equivalent don't decode option when reading\&. 
.TP
\fB\fIM_XML_WRITER_DONT_ENCODE_ATTRS \fP\fP
By default attribute values will be attribute entity encoded\&. This prevents the encode from taking place\&. It should be paired with the equivalent don't decode option when reading\&. 
.TP
\fB\fIM_XML_WRITER_PRETTYPRINT_SPACE \fP\fP
2 space indent\&. 
.TP
\fB\fIM_XML_WRITER_PRETTYPRINT_TAB \fP\fP
Tab indent\&. 
.TP
\fB\fIM_XML_WRITER_SELFCLOSE_SPACE \fP\fP
Add a space before the closing slash for self closing tags\&. 
.SS "enum \fBM_xml_error_t\fP"
Error codes\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIM_XML_ERROR_SUCCESS \fP\fP
success 
.TP
\fB\fIM_XML_ERROR_GENERIC \fP\fP
generic error 
.TP
\fB\fIM_XML_ERROR_MISUSE \fP\fP
API misuse 
.TP
\fB\fIM_XML_ERROR_ATTR_EXISTS \fP\fP
the attribute already exists on the node 
.TP
\fB\fIM_XML_ERROR_NO_ELEMENTS \fP\fP
unexpected end of XML, no elements in data 
.TP
\fB\fIM_XML_ERROR_INVALID_START_TAG \fP\fP
invalid tag start character 
.TP
\fB\fIM_XML_ERROR_INVALID_CHAR_IN_START_TAG \fP\fP
invalid character '<' found in tag 
.TP
\fB\fIM_XML_ERROR_EMPTY_START_TAG \fP\fP
only whitespace after tag start 
.TP
\fB\fIM_XML_ERROR_MISSING_DECLARATION_NAME \fP\fP
missing name after ! 
.TP
\fB\fIM_XML_ERROR_INELIGIBLE_FOR_CLOSE \fP\fP
cannot close element of this type 
.TP
\fB\fIM_XML_ERROR_UNEXPECTED_CLOSE \fP\fP
cannot close element with the given tag 
.TP
\fB\fIM_XML_ERROR_MISSING_CLOSE_TAG \fP\fP
missing closing element statement(s) 
.TP
\fB\fIM_XML_ERROR_MISSING_PROCESSING_INSTRUCTION_END \fP\fP
missing processing instruction close 
.TP
\fB\fIM_XML_ERROR_EXPECTED_END \fP\fP
expected end but more data found 
.SH "Function Documentation"
.PP 
.SS "\fBM_xml_node_t\fP* M_xml_create_doc (void)"
Create an XML document\&.
.PP
\fBReturns:\fP
.RS 4
A XML node on success\&. NULL on failure\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_xml_node_destroy\fP 
.RE
.PP

.SS "\fBM_xml_node_t\fP* M_xml_create_element (const char * name, \fBM_xml_node_t\fP * parent)"
Create an XML element node\&.
.PP
\fBParameters:\fP
.RS 4
\fIname\fP The tag name for the element\&. 
.br
\fIparent\fP The parent this node should be inserted into\&. Optional, pass NULL if the node should be created without a parent\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A XML node on success\&. NULL on failure\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_xml_node_destroy\fP 
.RE
.PP

.SS "\fBM_xml_node_t\fP* M_xml_create_element_with_text (const char * name, const char * text, size_t max_len, \fBM_xml_node_t\fP * parent)"
Create an XML element with text node\&.
.PP
\fBParameters:\fP
.RS 4
\fIname\fP The tag name for the element\&. 
.br
\fItext\fP The text for the element\&. 
.br
\fImax_len\fP The maximum length the text is allowed to be when xml encoded\&. If the encoded length is greater an error will result\&. Use 0 to specify that the text length should not be checked and any length is allowed\&. 
.br
\fIparent\fP The parent this node should be inserted into\&. Optional, pass NULL if the node should be created without a parent\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A XML node on success\&. NULL on failure\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_xml_node_destroy\fP 
.RE
.PP

.SS "\fBM_xml_node_t\fP* M_xml_create_text (const char * text, size_t max_len, \fBM_xml_node_t\fP * parent)"
Create an XML text node\&.
.PP
\fBParameters:\fP
.RS 4
\fItext\fP The text\&. 
.br
\fImax_len\fP The maximum length the text is allowed to be when xml encoded\&. If the encoded length is greater an error will result\&. Use 0 to specify that the text length should not be checked and any length is allowed\&. 
.br
\fIparent\fP The parent this node should be inserted into\&. Optional, pass NULL if the node should be created without a parent\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A XML node on success\&. NULL on failure\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_xml_node_destroy\fP 
.RE
.PP

.SS "\fBM_xml_node_t\fP* M_xml_create_xml_declaration (const char * encoding, \fBM_xml_node_t\fP * parent)"
Create an XML declaration node\&.
.PP
E\&.g:
.IP "\(bu" 2
<?xml version='1\&.0' encoding='UTF-8' ?>
.PP
.PP
\fBParameters:\fP
.RS 4
\fIencoding\fP The encoding\&. 
.br
\fIparent\fP The parent this node should be inserted into\&. Optional, pass NULL if the node should be created without a parent\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A XML node on success\&. NULL on failure\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_xml_node_destroy\fP 
.RE
.PP

.SS "\fBM_xml_node_t\fP* M_xml_create_declaration (const char * name, \fBM_xml_node_t\fP * parent)"
Create a declaration node\&.
.PP
E\&.g:
.IP "\(bu" 2
.PP
.nf
<!DOCTYPE html>
.fi
.PP

.IP "\(bu" 2
.PP
.nf
<!ELEMENT element-name category>
.fi
.PP

.IP "\(bu" 2
.PP
.nf
<!ATTLIST payment type CDATA "check">
.fi
.PP

.PP
.PP
\fBParameters:\fP
.RS 4
\fIname\fP The tag name for the declaration\&. 
.br
\fIparent\fP The parent this node should be inserted into\&. Optional, pass NULL if the node should be created without a parent\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A XML node on success\&. NULL on failure\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_xml_node_destroy\fP 
.RE
.PP

.SS "\fBM_xml_node_t\fP* M_xml_create_declaration_with_tag_data (const char * name, const char * data, \fBM_xml_node_t\fP * parent)"
Create a declaration node\&.
.PP
E\&.g:
.IP "\(bu" 2
.PP
.nf
<!DOCTYPE html>
.fi
.PP

.IP "\(bu" 2
.PP
.nf
<!ELEMENT element-name category>
.fi
.PP

.IP "\(bu" 2
.PP
.nf
<!ATTLIST payment type CDATA "check">
.fi
.PP

.PP
.PP
\fBParameters:\fP
.RS 4
\fIname\fP The tag name for the declaration\&. 
.br
\fIdata\fP The tag data\&. 
.br
\fIparent\fP The parent this node should be inserted into\&. Optional, pass NULL if the node should be created without a parent\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A XML node on success\&. NULL on failure\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_xml_node_destroy\fP 
.RE
.PP

.SS "\fBM_xml_node_t\fP* M_xml_create_processing_instruction (const char * name, \fBM_xml_node_t\fP * parent)"
Create an XML processing instruction node\&.
.PP
\fBParameters:\fP
.RS 4
\fIname\fP The instruction name for the node\&. 
.br
\fIparent\fP The parent this node should be inserted into\&. Optional, pass NULL if the node should be created without a parent\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A XML node on success\&. NULL on failure\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_xml_node_destroy\fP 
.RE
.PP

.SS "\fBM_xml_node_t\fP* M_xml_create_comment (const char * comment, \fBM_xml_node_t\fP * parent)"
Create an XML comment node\&.
.PP
\fBParameters:\fP
.RS 4
\fIcomment\fP The comment\&. 
.br
\fIparent\fP The parent this node should be inserted into\&. Optional, pass NULL if the node should be created without a parent\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A XML node on success\&. NULL on failure\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_xml_node_destroy\fP 
.RE
.PP

.SS "void M_xml_node_destroy (\fBM_xml_node_t\fP * node)"
Destroy an XML node\&.
.PP
Destroying a node will destroy every node under it and remove it from it's parent node if it is a child\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node to destroy\&. 
.RE
.PP

.SS "\fBM_xml_node_t\fP* M_xml_read (const char * data, size_t data_len, M_uint32 flags, size_t * processed_len, \fBM_xml_error_t\fP * error, size_t * error_line, size_t * error_pos)"
Parse a string into an XML object\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP The data to parse\&. 
.br
\fIdata_len\fP The length of the data to parse\&. 
.br
\fIflags\fP M_xml_reader_flags_t flags to control the behavior of the reader\&. 
.br
\fIprocessed_len\fP Length of data processed\&. Useful if you could have multiple XML documents in a stream\&. Optional pass NULL if not needed\&. 
.br
\fIerror\fP Error code if creation failed\&. Optional, Pass NULL if not needed\&. 
.br
\fIerror_line\fP The line the error occurred\&. Optional, pass NULL if not needed\&. 
.br
\fIerror_pos\fP The column the error occurred if error_line is not NULL, otherwise the position in the stream the error occurred\&. Optional, pass NULL if not needed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The XML doc node of the parsed data, or NULL on error\&. 
.RE
.PP

.SS "\fBM_xml_node_t\fP* M_xml_read_file (const char * path, M_uint32 flags, size_t max_read, \fBM_xml_error_t\fP * error, size_t * error_line, size_t * error_pos)"
Parse a file into a XML object\&.
.PP
\fBParameters:\fP
.RS 4
\fIpath\fP The file to read\&. 
.br
\fIflags\fP M_xml_reader_flags_t flags to control the behavior of the reader\&. 
.br
\fImax_read\fP The maximum amount of data to read from the file\&. If the data in the file is larger than max_read an error will most likely result\&. Optional pass 0 to read all data\&. 
.br
\fIerror\fP Error code if creation failed\&. Optional, Pass NULL if not needed\&. 
.br
\fIerror_line\fP The line the error occurred\&. Optional, pass NULL if not needed\&. 
.br
\fIerror_pos\fP The column the error occurred if error_line is not NULL, otherwise the position in the stream the error occurred\&. Optional, pass NULL if not needed\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The XML doc node of the parsed data, or NULL on error\&. 
.RE
.PP

.SS "char* M_xml_write (const \fBM_xml_node_t\fP * node, M_uint32 flags, size_t * len)"
Write XML to a string\&.
.PP
This writes nodes to a string\&. The string may not be directly usable by M_xml_read\&. E\&.g\&. If you are only writing a string node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node to write\&. This will write the node and any nodes under it\&. 
.br
\fIflags\fP M_xml_writer_flags_t flags to control writing\&. 
.br
\fIlen\fP The length of the string that was returned\&. Optional, pass NULL if not needed\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A string with data or NULL on error\&. 
.RE
.PP

.SS "\fBM_fs_error_t\fP M_xml_write_file (const \fBM_xml_node_t\fP * node, const char * path, M_uint32 flags)"
Write XML to a file\&.
.PP
This writes nodes to a string\&. The string may not be directly usable by M_xml_read_file\&. E\&.g\&. If you are only writing a string node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node to write\&. This will write the node and any nodes under it\&. 
.br
\fIpath\fP The filename and path to write the data to\&. 
.br
\fIflags\fP M_xml_writer_flags_t flags to control writing\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Result\&. 
.RE
.PP

.SS "\fBM_xml_node_type_t\fP M_xml_node_type (const \fBM_xml_node_t\fP * node)"
Get the type of node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The type\&. 
.RE
.PP

.SS "\fBM_xml_node_t\fP** M_xml_xpath (\fBM_xml_node_t\fP * node, const char * search, M_uint32 flags, size_t * num_matches)"
Using XPath expressions, scan for matches\&.
.PP
Note that full XPath support does not yet exist\&. Also only element nodes are currently returned unless text() is used to return text nodes\&.
.PP
Supports: Syntax Meaning  tag Selects children of the current element node with the given tag name\&. *:tag Selects children of the current element node with the given tag name ignoring any namespace on the tag\&. Also matches tags without a namespace\&. * Selects all children of the current element node\&. / Selects children one level below the current element node\&. // Selects children on all levels bellow the current element node\&. \&. Selects the current element node\&. \&.\&. Selects the parent of the current element node\&. text() Selects all text nodes\&. [@attrib] Selects elements which have an attribute attrib\&. [@attrib=val] Selects elements which have an sttribute attrib with a value of val\&. [@attrib='val'] Selects elements which have an sttribute attrib with a value of val\&. [@attrib='val'] Selects elements which have an sttribute attrib with a value of val\&. [@*] Selects elements which have an (any) attribute set\&. [idx] Select an element at a given position\&. [position() ? idx] Select an element at a given position\&. More information about [idx]:
.PP
Index matching can either be an integer (starting from 1) or the expression 'last()'\&. 'last()' can be followed by a negative integer in order to count backwards from the last elements\&. For example: 'last()-1' is the second to last element\&. The idx is not the index within the parent the node but the index of the matching nodes\&. idx must be preceded by either a tag or text()\&.
.PP
More information about [position() ? idx]:
.PP
Position matching can use the equality modifiers '=', '<=', '>=', '<', '>'\&. These will select one or more nodes that match the given criteria\&. 'last()' can be used as the index\&.
.PP
E\&.g: 'a/b[2]' for \fC<a><b/><c/><b/></a>\fP will select the second 'b' after 'c'\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node\&. 
.br
\fIsearch\fP search expression 
.br
\fIflags\fP M_xml_reader_flags_t flags to control the behavior of the search\&. valid flags are:
.IP "\(bu" 2
M_XML_READER_NONE
.IP "\(bu" 2
M_XML_READER_TAG_CASECMP 
.PP
.br
\fInum_matches\fP Number of matches found
.RE
.PP
\fBReturns:\fP
.RS 4
array of M_xml_node_t pointers on success (must free array, but not internal pointers), NULL on failure 
.RE
.PP

.SS "const char* M_xml_xpath_text_first (\fBM_xml_node_t\fP * node, const char * search)"
Using XPath expressions, scan for matches and return the first text value\&.
.PP
This will only return the first text node\&. Meaning if multiple text nodes are inserted in a row only the text from the first will be returned\&. If the XML tree was created using M_xml_read or M_xml_read_file then the fist text node will contain all of the text\&.
.PP
\fBSee also:\fP
.RS 4
\fBM_xml_xpath\fP for information about supported XPath features\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node\&. 
.br
\fIsearch\fP search expression
.RE
.PP
\fBReturns:\fP
.RS 4
Text on success otherwise NULL\&. 
.RE
.PP

.SS "\fBM_xml_node_t\fP* M_xml_node_parent (const \fBM_xml_node_t\fP * node)"
Get the parent node of a given node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The parent node or NULL if there is no parent\&. 
.RE
.PP

.SS "void M_xml_take_from_parent (\fBM_xml_node_t\fP * node)"
Take a node from its parent but does not destroy the node\&.
.PP
This allows a node to be moved between different parents\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node\&. 
.RE
.PP

.SS "M_bool M_xml_node_insert_node (\fBM_xml_node_t\fP * parent, \fBM_xml_node_t\fP * child)"
Insert a node into a doc or element node\&.
.PP
The parent node will take ownership of the child node\&.
.PP
Only parentless nodes can be insert into other nodes\&. You must use M_xml_take_from_parent first if you are moving nodes from one parent to another\&.
.PP
\fBParameters:\fP
.RS 4
\fIparent\fP The parent node\&. 
.br
\fIchild\fP The child node\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_xml_node_insert_node_at (\fBM_xml_node_t\fP * parent, \fBM_xml_node_t\fP * child, size_t idx)"
Insert a node into a doc or element node at a given position\&.
.PP
The parent node will take ownership of the child node\&.
.PP
\fBParameters:\fP
.RS 4
\fIparent\fP The parent node\&. 
.br
\fIchild\fP The child node\&. 
.br
\fIidx\fP The location where the node should be inserted\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success otherwise M_FALSE\&. 
.RE
.PP

.SS "size_t M_xml_node_num_children (const \fBM_xml_node_t\fP * node)"
Get the number of child nodes for a doc or element node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The number of children\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_xml_node_child\fP 
.RE
.PP

.SS "\fBM_xml_node_t\fP* M_xml_node_child (const \fBM_xml_node_t\fP * node, size_t idx)"
Get the child node at the given position for a doc or element node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node\&. 
.br
\fIidx\fP The position for the child to retrieve\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The child node or NULL if a child does not exist at the given position\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBM_xml_node_num_children\fP 
.RE
.PP

.SS "\fBM_xml_node_t\fP* M_xml_node_sibling (const \fBM_xml_node_t\fP * node, M_bool after)"
Get the sibling for the node\&.
.PP
The sibling is the node at the same level as the current node which is either before or after the node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node\&. 
.br
\fIafter\fP M_TRUE to return the node after\&. M_FALSE to return the one before\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The sibling node\&. NULL if there is no sibling in the given direction\&. 
.RE
.PP

.SS "M_bool M_xml_node_set_name (\fBM_xml_node_t\fP * node, const char * name)"
Set the tag name for an element or processing instruction node\&.
.PP
The name is the tag name\&. E\&.g\&. '<name>'\&. This will change the name of the node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node\&. 
.br
\fIname\fP The name\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on sucess otherwise M_FALSE\&. 
.RE
.PP

.SS "const char* M_xml_node_name (const \fBM_xml_node_t\fP * node)"
Get the tag name for node an element or processing instruction node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The name\&. 
.RE
.PP

.SS "M_bool M_xml_node_set_text (\fBM_xml_node_t\fP * node, const char * text, size_t max_len)"
Set the text for a text node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node\&. 
.br
\fItext\fP The text\&. 
.br
\fImax_len\fP The maximum length the text is allowed to be when xml encoded\&. If the encoded length is greater an error will result\&. Use 0 to specify that the text length should not be checked and any length is allowed\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE\&. 
.RE
.PP

.SS "const char* M_xml_node_text (const \fBM_xml_node_t\fP * node)"
Get the text for a text node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node
.RE
.PP
\fBReturns:\fP
.RS 4
The node's text\&. 
.RE
.PP

.SS "M_bool M_xml_node_set_tag_data (\fBM_xml_node_t\fP * node, const char * data)"
Set the tag data for a node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node\&. 
.br
\fIdata\fP The tag data\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE\&. 
.RE
.PP

.SS "const char* M_xml_node_tag_data (const \fBM_xml_node_t\fP * node)"
Get the tag data for a node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node
.RE
.PP
\fBReturns:\fP
.RS 4
The node's tag data\&. 
.RE
.PP

.SS "M_bool M_xml_node_insert_attribute (\fBM_xml_node_t\fP * node, const char * key, const char * val, size_t max_len, M_bool overwrite)"
Insert an attribute into an element or processing instruction node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node\&. 
.br
\fIkey\fP The attribute key\&. 
.br
\fIval\fP The attribute value\&. 
.br
\fImax_len\fP The maximum length the text is allowed to be when xml encoded\&. If the encoded length is greater an error will result\&. Use 0 to specify that the text length should not be checked and any length is allowed\&. 
.br
\fIoverwrite\fP Action to take when the given key exists\&. If M_TRUE the value will be overwritten when with the given value\&. If M_FALSE the attribute will not be written\&. This will be treated as an error condition\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE\&. 
.RE
.PP

.SS "M_bool M_xml_node_remove_attribute (\fBM_xml_node_t\fP * node, const char * key)"
Remove an attribute from an element or processing instruction node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node\&. 
.br
\fIkey\fP The attribute key\&.
.RE
.PP
\fBReturns:\fP
.RS 4
M_TRUE on success, otherwise M_FALSE\&. 
.RE
.PP

.SS "\fBM_list_str_t\fP* M_xml_node_attribute_keys (const \fBM_xml_node_t\fP * node)"
Get a list of all attribute keys set for an element or processing instruction node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A list of keys\&. 
.RE
.PP

.SS "const \fBM_hash_dict_t\fP* M_xml_node_attributes (const \fBM_xml_node_t\fP * node)"
Get a dictionary of all attribute set for an element or processing instruction node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A dictionary with attributes\&. 
.RE
.PP

.SS "const char* M_xml_node_attribute (const \fBM_xml_node_t\fP * node, const char * key)"
Get the value of a given attribute for an element or processing instruction node\&.
.PP
\fBParameters:\fP
.RS 4
\fInode\fP The node\&. 
.br
\fIkey\fP The attribute key\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The value of the attribute\&. NULL if the key does not exist\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Mstdlib-1\&.0\&.0 from the source code\&.
